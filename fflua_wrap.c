/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGLUA
#define SWIG_LUA_TARGET SWIG_LUA_FLAVOR_LUA
#define SWIG_LUA_MODULE_GLOBAL

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Lua flavors */
#define SWIG_LUA_FLAVOR_LUA 1
#define SWIG_LUA_FLAVOR_ELUA 2
#define SWIG_LUA_FLAVOR_ELUAC 3

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
#  define SWIG_LUA_CONSTTAB_INT(B, C) LSTRKEY(B), LNUMVAL(C)
#  define SWIG_LUA_CONSTTAB_FLOAT(B, C) LSTRKEY(B), LNUMVAL(C)
#  define SWIG_LUA_CONSTTAB_STRING(B, C) LSTRKEY(B), LSTRVAL(C)
#  define SWIG_LUA_CONSTTAB_CHAR(B, C) LSTRKEY(B), LNUMVAL(C)
# else /* SWIG_LUA_FLAVOR_LUA */
#  define SWIG_LUA_CONSTTAB_INT(B, C) SWIG_LUA_INT, (char *)B, (long)C, 0, 0, 0
#  define SWIG_LUA_CONSTTAB_FLOAT(B, C) SWIG_LUA_FLOAT, (char *)B, 0, (double)C, 0, 0
#  define SWIG_LUA_CONSTTAB_STRING(B, C) SWIG_LUA_STRING, (char *)B, 0, 0, (void *)C, 0
#  define SWIG_LUA_CONSTTAB_CHAR(B, C) SWIG_LUA_CHAR, (char *)B, (long)C, 0, 0, 0
#endif

#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC)
#  define LRO_STRVAL(v) {{.p = (char *) v}, LUA_TSTRING}
#  define LSTRVAL LRO_STRVAL
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return an integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * luarun.swg
 *
 * This file contains the runtime support for Lua modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

#include "lua.h"
#include "lauxlib.h"
#include <stdlib.h>  /* for malloc */
#include <assert.h>  /* for a few sanity tests */

/* -----------------------------------------------------------------------------
 * compatibility defines
 * ----------------------------------------------------------------------------- */

/* History of Lua C API length functions:  In Lua 5.0 (and before?)
   there was "lua_strlen".  In Lua 5.1, this was renamed "lua_objlen",
   but a compatibility define of "lua_strlen" was added.  In Lua 5.2,
   this function was again renamed, to "lua_rawlen" (to emphasize that
   it doesn't call the "__len" metamethod), and the compatibility
   define of lua_strlen was removed.  All SWIG uses have been updated
   to "lua_rawlen", and we add our own defines of that here for older
   versions of Lua.  */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 501
# define lua_rawlen lua_strlen
#elif LUA_VERSION_NUM == 501
# define lua_rawlen lua_objlen
#endif


/* lua_pushglobaltable is the recommended "future-proof" way to get
   the global table for Lua 5.2 and later.  Here we define
   lua_pushglobaltable ourselves for Lua versions before 5.2.  */
#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
# define lua_pushglobaltable(L) lua_pushvalue(L, LUA_GLOBALSINDEX)
#endif


/* -----------------------------------------------------------------------------
 * global swig types
 * ----------------------------------------------------------------------------- */
/* Constant table */
#define SWIG_LUA_INT     1
#define SWIG_LUA_FLOAT   2
#define SWIG_LUA_STRING  3
#define SWIG_LUA_POINTER 4
#define SWIG_LUA_BINARY  5
#define SWIG_LUA_CHAR    6

/* Structure for variable linking table */
typedef struct {
  const char *name;
  lua_CFunction get;
  lua_CFunction set;
} swig_lua_var_info;

/* Constant information structure */
typedef struct {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_lua_const_info;

typedef struct {
  const char     *name;
  lua_CFunction   method;
} swig_lua_method;

typedef struct {
  const char     *name;
  lua_CFunction   getmethod;
  lua_CFunction   setmethod;
} swig_lua_attribute;

typedef struct swig_lua_class {
  const char    *name;
  swig_type_info   **type;
  lua_CFunction  constructor;
  void    (*destructor)(void *);
  swig_lua_method   *methods;
  swig_lua_attribute     *attributes;
  struct swig_lua_class **bases;
  const char **base_names;
} swig_lua_class;

/* this is the struct for wrappering all pointers in SwigLua
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  void        *ptr;
} swig_lua_userdata;

/* this is the struct for wrapping arbitary packed binary data
(currently it is only used for member function pointers)
the data ordering is similar to swig_lua_userdata, but it is currently not possible
to tell the two structures apart within SWIG, other than by looking at the type
*/
typedef struct {
  swig_type_info   *type;
  int     own;  /* 1 if owned & must be destroyed */
  char data[1];       /* arbitary amount of data */    
} swig_lua_rawdata;

/* Common SWIG API */
#define SWIG_NewPointerObj(L, ptr, type, owner)       SWIG_Lua_NewPointerObj(L, (void *)ptr, type, owner)
#define SWIG_ConvertPtr(L,idx, ptr, type, flags)    SWIG_Lua_ConvertPtr(L,idx,ptr,type,flags)
#define SWIG_MustGetPtr(L,idx, type,flags, argnum,fnname)  SWIG_Lua_MustGetPtr(L,idx, type,flags, argnum,fnname)
/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(L, idx, ptr, sz, ty)       SWIG_Lua_ConvertPacked(L, idx, ptr, sz, ty)
#define SWIG_NewMemberObj(L, ptr, sz, type)      SWIG_Lua_NewPackedObj(L, ptr, sz, type)

/* Runtime API */
#define SWIG_GetModule(clientdata) SWIG_Lua_GetModule((lua_State*)(clientdata))
#define SWIG_SetModule(clientdata, pointer) SWIG_Lua_SetModule((lua_State*) (clientdata), pointer)
#define SWIG_MODULE_CLIENTDATA_TYPE lua_State*

/* Contract support */
#define SWIG_contract_assert(expr, msg)  \
  if (!(expr)) { lua_pushstring(L, (char *) msg); goto fail; } else

/* helper #defines */
#define SWIG_fail {goto fail;}
#define SWIG_fail_arg(func_name,argnum,type) \
  {lua_pushfstring(L,"Error in %s (arg %d), expected '%s' got '%s'",\
  func_name,argnum,type,SWIG_Lua_typename(L,argnum));\
  goto fail;}
#define SWIG_fail_ptr(func_name,argnum,type) \
  SWIG_fail_arg(func_name,argnum,(type && type->str)?type->str:"void*")
#define SWIG_check_num_args(func_name,a,b) \
  if (lua_gettop(L)<a || lua_gettop(L)>b) \
  {lua_pushfstring(L,"Error in %s expected %d..%d args, got %d",func_name,a,b,lua_gettop(L));\
  goto fail;}


#define SWIG_Lua_get_table(L,n) \
  (lua_pushstring(L, n), lua_rawget(L,-2))

#define SWIG_Lua_add_function(L,n,f) \
  (lua_pushstring(L, n), \
      lua_pushcfunction(L, f), \
      lua_rawset(L,-3))

/* special helper for allowing 'nil' for usertypes */
#define SWIG_isptrtype(L,I) (lua_isuserdata(L,I) || lua_isnil(L,I))

#ifdef __cplusplus
/* Special helper for member function pointers 
it gets the address, casts it, then dereferences it */
//#define SWIG_mem_fn_as_voidptr(a)  (*((char**)&(a)))
#endif

/* storing/access of swig_module_info */
SWIGRUNTIME swig_module_info *
SWIG_Lua_GetModule(lua_State* L) {
  swig_module_info *ret = 0;
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_rawget(L,LUA_REGISTRYINDEX);
  if (lua_islightuserdata(L,-1))
    ret=(swig_module_info*)lua_touserdata(L,-1);
  lua_pop(L,1);  /* tidy */
  return ret;
}

SWIGRUNTIME void
SWIG_Lua_SetModule(lua_State* L, swig_module_info *module) {
  /* add this all into the Lua registry: */
  lua_pushstring(L,"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  lua_pushlightuserdata(L,(void*)module);
  lua_rawset(L,LUA_REGISTRYINDEX);
}

/* -----------------------------------------------------------------------------
 * global variable support code: modules
 * ----------------------------------------------------------------------------- */

/* this function is called when trying to set an immutable.
default value is to print an error.
This can removed with a compile flag SWIGLUA_IGNORE_SET_IMMUTABLE */
SWIGINTERN int SWIG_Lua_set_immutable(lua_State* L)
{
/*  there should be 1 param passed in: the new value */
#ifndef SWIGLUA_IGNORE_SET_IMMUTABLE
  lua_pop(L,1);  /* remove it */
  lua_pushstring(L,"This variable is immutable");
  lua_error(L);
#endif
    return 0;   /* should not return anything */
}

/* the module.get method used for getting linked data */
SWIGINTERN int SWIG_Lua_module_get(lua_State* L)
{
/*  there should be 2 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  printf("SWIG_Lua_module_get %p(%s) '%s'\n",
   lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
   lua_tostring(L,2));
*/
  /* get the metatable */
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
  assert(lua_isrotable(L,1)); /* just in case */
#else
  assert(lua_istable(L,1)); /* default Lua action */
#endif
  lua_getmetatable(L,1);  /* get the metatable */
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
  assert(lua_isrotable(L,-1));  /* just in case */
#else
  assert(lua_istable(L,-1));
#endif
  SWIG_Lua_get_table(L,".get");  /* get the .get table */
  lua_remove(L,3);  /* remove metatable */
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
  if (lua_isrotable(L,-1))
#else
  if (lua_istable(L,-1))
#endif
  {
    /* look for the key in the .get table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,3);  /* remove .get */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_call(L,0,1);
      return 1;
    }
    lua_pop(L,1);  /* remove the top */
  }
  lua_pop(L,1);  /* remove the .get */
  lua_pushnil(L);  /* return a nil */
  return 1;
}

/* the module.set method used for setting linked data */
SWIGINTERN int SWIG_Lua_module_set(lua_State* L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
*/
  /* get the metatable */
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
  assert(lua_isrotable(L,1));  /* just in case */
#else
  assert(lua_istable(L,1)); /* default Lua action */
#endif
  lua_getmetatable(L,1);  /* get the metatable */
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
  assert(lua_isrotable(L,-1));  /* just in case */
#else
  assert(lua_istable(L,-1));
#endif
  SWIG_Lua_get_table(L,".set");  /* get the .set table */
  lua_remove(L,4);  /* remove metatable */
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
  if (lua_isrotable(L,-1))
#else
  if (lua_istable(L,-1))
#endif
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    lua_remove(L,4);  /* remove .set */
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,1,0);
      return 0;
    }
#if (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) 
    else {
      return 0; // Exits stoically if an invalid key is initialized.
    }
#endif
  }
  lua_settop(L,3);  /* reset back to start */
  /* we now have the table, key & new value, so just set directly */
  lua_rawset(L,1);  /* add direct */
  return 0;
}

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC))
/* registering a module in lua. Pushes the module table on the stack. */
SWIGINTERN void  SWIG_Lua_module_begin(lua_State* L,const char* name)
{
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushstring(L,name);
  lua_newtable(L);   /* the table */
  /* add meta table */
  lua_newtable(L);    /* the meta table */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_module_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_module_set);
  lua_pushstring(L,".get");
  lua_newtable(L);    /* the .get table */
  lua_rawset(L,-3);  /* add .get into metatable */
  lua_pushstring(L,".set");
  lua_newtable(L);    /* the .set table */
  lua_rawset(L,-3);  /* add .set into metatable */
  lua_setmetatable(L,-2);  /* sets meta table in module */
#ifdef SWIG_LUA_MODULE_GLOBAL
  /* If requested, install the module directly into the global namespace. */
  lua_rawset(L,-3);        /* add module into parent */
  SWIG_Lua_get_table(L,name);   /* get the table back out */
#else
  /* Do not install the module table as global name. The stack top has
     the module table with the name below. We pop the top and replace
     the name with it. */
  lua_replace(L,-2);
#endif
}

/* ending the register */
SWIGINTERN void  SWIG_Lua_module_end(lua_State* L)
{
  lua_pop(L,1);       /* tidy stack (remove module) */
}

/* adding a linked variable to the module */
SWIGINTERN void SWIG_Lua_module_add_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  lua_getmetatable(L,-1);  /* get the metatable */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* should be a table: */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)  /* if there is a set fn */
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* should be a table: */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
  lua_pop(L,1);       /* tidy stack (remove meta) */
}
#endif

/* adding a function module */
SWIGINTERN void  SWIG_Lua_module_add_function(lua_State* L,const char* name,lua_CFunction fn)
{
  SWIG_Lua_add_function(L,name,fn);
}

/* -----------------------------------------------------------------------------
 * global variable support code: classes
 * ----------------------------------------------------------------------------- */

/* the class.get method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_get(lua_State* L)
{
/*  there should be 2 params passed in
  (1) userdata (not the meta table)
  (2) string name of the attribute
*/
  assert(lua_isuserdata(L,-2));  /* just in case */
  lua_getmetatable(L,-2);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  /* look for the key in the .get table */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);
  lua_remove(L,-2); /* stack tidy, remove .get table */
  if (lua_iscfunction(L,-1))
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_call(L,1,1);  /* 1 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* ok, so try the .fn table */
  SWIG_Lua_get_table(L,".fn"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  lua_pushvalue(L,2);  /* key */
  lua_rawget(L,-2);  /* look for the fn */
  lua_remove(L,-2); /* stack tidy, remove .fn table */
  if (lua_isfunction(L,-1)) /* note: if its a C function or lua function */
  {  /* found it so return the fn & let lua call it */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  lua_pop(L,1);  /* remove whatever was there */
  /* NEW: looks for the __getitem() fn
  this is a user provided get fn */
  SWIG_Lua_get_table(L,"__getitem"); /* find the __getitem fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_pushvalue(L,2);  /* the parameter */
    lua_call(L,2,1);  /* 2 value in (userdata),1 out (result) */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  return 0;  /* sorry not known */
}

/* the class.set method, performs the lookup of class attributes */
SWIGINTERN int  SWIG_Lua_class_set(lua_State* L)
{
/*  there should be 3 params passed in
  (1) table (not the meta table)
  (2) string name of the attribute
  (3) any for the new value
printf("SWIG_Lua_class_set %p(%s) '%s' %p(%s)\n",
      lua_topointer(L,1),lua_typename(L,lua_type(L,1)),
      lua_tostring(L,2),
      lua_topointer(L,3),lua_typename(L,lua_type(L,3)));*/

  assert(lua_isuserdata(L,1));  /* just in case */
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */

  SWIG_Lua_get_table(L,".set"); /* find the .set table */
  if (lua_istable(L,-1))
  {
    /* look for the key in the .set table */
    lua_pushvalue(L,2);  /* key */
    lua_rawget(L,-2);
    if (lua_iscfunction(L,-1))
    {  /* found it so call the fn & return its value */
      lua_pushvalue(L,1);  /* userdata */
      lua_pushvalue(L,3);  /* value */
      lua_call(L,2,0);
      return 0;
    }
    lua_pop(L,1);  /* remove the value */
  }
  lua_pop(L,1);  /* remove the value .set table */
  /* NEW: looks for the __setitem() fn
  this is a user provided set fn */
  SWIG_Lua_get_table(L,"__setitem"); /* find the fn */
  if (lua_iscfunction(L,-1))  /* if its there */
  {  /* found it so call the fn & return its value */
    lua_pushvalue(L,1);  /* the userdata */
    lua_pushvalue(L,2);  /* the parameter */
    lua_pushvalue(L,3);  /* the value */
    lua_call(L,3,0);  /* 3 values in ,0 out */
    lua_remove(L,-2); /* stack tidy, remove metatable */
    return 1;
  }
  return 0;
}

/* the class.destruct method called by the interpreter */
SWIGINTERN int  SWIG_Lua_class_destruct(lua_State* L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata* usr;
  swig_lua_class* clss;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  /* if must be destroyed & has a destructor */
  if (usr->own) /* if must be destroyed */
  {
    clss=(swig_lua_class*)usr->type->clientdata;  /* get the class */
    if (clss && clss->destructor)  /* there is a destroy fn */
    {
      clss->destructor(usr->ptr);  /* bye bye */
    }
  }
  return 0;
}

/* the class.__tostring method called by the interpreter and print */
SWIGINTERN int  SWIG_Lua_class_tostring(lua_State* L)
{
/*  there should be 1 param passed in
  (1) userdata (not the metatable) */
  assert(lua_isuserdata(L,1));  /* just in case */
  unsigned long userData = (unsigned long)lua_touserdata(L,1); /* get the userdata address for later */
  lua_getmetatable(L,1);    /* get the meta table */
  assert(lua_istable(L,-1));  /* just in case */
  
  lua_getfield(L, -1, ".type");
  const char* className = lua_tostring(L, -1);
  
  char output[256];
  sprintf(output, "<%s userdata: %lX>", className, userData);
  
  lua_pushstring(L, (const char*)output);
  return 1;
}

/* to manually disown some userdata */
SWIGINTERN int  SWIG_Lua_class_disown(lua_State* L)
{
/*  there should be 1 params passed in
  (1) userdata (not the meta table) */
  swig_lua_userdata* usr;
  assert(lua_isuserdata(L,-1));  /* just in case */
  usr=(swig_lua_userdata*)lua_touserdata(L,-1);  /* get it */
  
  usr->own = 0; /* clear our ownership */
  return 0;
}

/* gets the swig class registry (or creates it) */
SWIGINTERN void  SWIG_Lua_get_class_registry(lua_State* L)
{
  /* add this all into the swig registry: */
  lua_pushstring(L,"SWIG");
  lua_rawget(L,LUA_REGISTRYINDEX);  /* get the registry */
  if (!lua_istable(L,-1))  /* not there */
  {  /* must be first time, so add it */
    lua_pop(L,1);  /* remove the result */
    lua_pushstring(L,"SWIG");
    lua_newtable(L);
    lua_rawset(L,LUA_REGISTRYINDEX);
    /* then get it */
    lua_pushstring(L,"SWIG");
    lua_rawget(L,LUA_REGISTRYINDEX);
  }
}

/* helper fn to get the classes metatable from the register */
SWIGINTERN void  SWIG_Lua_get_class_metatable(lua_State* L,const char* cname)
{
  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,cname);  /* get the name */
  lua_rawget(L,-2);    /* get it */
  lua_remove(L,-2);    /* tidy up (remove registry) */
}

/* helper add a variable to a registered class */
SWIGINTERN void  SWIG_Lua_add_class_variable(lua_State* L,const char* name,lua_CFunction getFn,lua_CFunction setFn)
{
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_get_table(L,".get"); /* find the .get table */
  assert(lua_istable(L,-1));  /* just in case */
  SWIG_Lua_add_function(L,name,getFn);
  lua_pop(L,1);       /* tidy stack (remove table) */
  if (setFn)
  {
    SWIG_Lua_get_table(L,".set"); /* find the .set table */
    assert(lua_istable(L,-1));  /* just in case */
    SWIG_Lua_add_function(L,name,setFn);
    lua_pop(L,1);       /* tidy stack (remove table) */
  }
}

/* helper to recursively add class details (attributes & operations) */
SWIGINTERN void  SWIG_Lua_add_class_details(lua_State* L,swig_lua_class* clss)
{
  int i;
  /* call all the base classes first: we can then override these later: */
  for(i=0;clss->bases[i];i++)
  {
    SWIG_Lua_add_class_details(L,clss->bases[i]);
  }
  /* add fns */
  for(i=0;clss->attributes[i].name;i++){
    SWIG_Lua_add_class_variable(L,clss->attributes[i].name,clss->attributes[i].getmethod,clss->attributes[i].setmethod);
  }
  /* add methods to the metatable */
  SWIG_Lua_get_table(L,".fn"); /* find the .fn table */
  assert(lua_istable(L,-1));  /* just in case */
  for(i=0;clss->methods[i].name;i++){
    SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
  }
  lua_pop(L,1);       /* tidy stack (remove table) */
  /*   add operator overloads
    these look ANY method which start with "__" and assume they
    are operator overloads & add them to the metatable
    (this might mess up is someone defines a method __gc (the destructor)*/
  for(i=0;clss->methods[i].name;i++){
    if (clss->methods[i].name[0]=='_' && clss->methods[i].name[1]=='_'){
      SWIG_Lua_add_function(L,clss->methods[i].name,clss->methods[i].method);
    }
  }
}

/* set up the base classes pointers.
Each class structure has a list of pointers to the base class structures.
This function fills them.
It cannot be done at compile time, as this will not work with hireachies
spread over more than one swig file. 
Therefore it must be done at runtime, querying the SWIG type system.
*/
SWIGINTERN void SWIG_Lua_init_base_class(lua_State* L,swig_lua_class* clss)
{
  int i=0;
  swig_module_info* module=SWIG_GetModule(L);
  for(i=0;clss->base_names[i];i++)
  {
    if (clss->bases[i]==0) /* not found yet */
    {
      /* lookup and cache the base class */
      swig_type_info *info = SWIG_TypeQueryModule(module,module,clss->base_names[i]);
      if (info) clss->bases[i] = (swig_lua_class *) info->clientdata;
    }
  }	
}

/* performs the entire class registration process */
SWIGINTERN void  SWIG_Lua_class_register(lua_State* L,swig_lua_class* clss)
{
  /*  add its constructor to module with the name of the class
  so you can do MyClass(...) as well as new_MyClass(...)
  BUT only if a constructor is defined
  (this overcomes the problem of pure virtual classes without constructors)*/
  if (clss->constructor)
    SWIG_Lua_add_function(L,clss->name,clss->constructor);

  SWIG_Lua_get_class_registry(L);  /* get the registry */
  lua_pushstring(L,clss->name);  /* get the name */
  lua_newtable(L);    /* create the metatable */
  /* add string of class name called ".type" */
  lua_pushstring(L,".type");
  lua_pushstring(L,clss->name);
  lua_rawset(L,-3);
  /* add a table called ".get" */
  lua_pushstring(L,".get");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".set" */
  lua_pushstring(L,".set");
  lua_newtable(L);
  lua_rawset(L,-3);
  /* add a table called ".fn" */
  lua_pushstring(L,".fn");
  lua_newtable(L);
  /* add manual disown method */
  SWIG_Lua_add_function(L,"__disown",SWIG_Lua_class_disown);
  lua_rawset(L,-3);
  /* add accessor fns for using the .get,.set&.fn */
  SWIG_Lua_add_function(L,"__index",SWIG_Lua_class_get);
  SWIG_Lua_add_function(L,"__newindex",SWIG_Lua_class_set);
  SWIG_Lua_add_function(L,"__gc",SWIG_Lua_class_destruct);
  /* add tostring method for better output */
  SWIG_Lua_add_function(L,"__tostring",SWIG_Lua_class_tostring);
  /* add it */
  lua_rawset(L,-3);  /* metatable into registry */
  lua_pop(L,1);      /* tidy stack (remove registry) */

  SWIG_Lua_get_class_metatable(L,clss->name);
  SWIG_Lua_add_class_details(L,clss);  /* recursive adding of details (atts & ops) */
  lua_pop(L,1);      /* tidy stack (remove class metatable) */
}

/* -----------------------------------------------------------------------------
 * Class/structure conversion fns
 * ----------------------------------------------------------------------------- */

/* helper to add metatable to new lua object */
SWIGINTERN void _SWIG_Lua_AddMetatable(lua_State* L,swig_type_info *type)
{
  if (type->clientdata)  /* there is clientdata: so add the metatable */
  {
    SWIG_Lua_get_class_metatable(L,((swig_lua_class*)(type->clientdata))->name);
    if (lua_istable(L,-1))
    {
      lua_setmetatable(L,-2);
    }
    else
    {
      lua_pop(L,1);
    }
  }
}

/* pushes a new object into the lua stack */
SWIGRUNTIME void SWIG_Lua_NewPointerObj(lua_State* L,void* ptr,swig_type_info *type, int own)
{
  swig_lua_userdata* usr;
  if (!ptr){
    lua_pushnil(L);
    return;
  }
  usr=(swig_lua_userdata*)lua_newuserdata(L,sizeof(swig_lua_userdata));  /* get data */
  usr->ptr=ptr;  /* set the ptr */
  usr->type=type;
  usr->own=own;
#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
#endif
}

/* takes a object from the lua stack & converts it into an object of the correct type
 (if possible) */
SWIGRUNTIME int  SWIG_Lua_ConvertPtr(lua_State* L,int index,void** ptr,swig_type_info *type,int flags)
{
  swig_lua_userdata* usr;
  swig_cast_info *cast;
  if (lua_isnil(L,index)){*ptr=0; return SWIG_OK;}    /* special case: lua nil => NULL pointer */
  usr=(swig_lua_userdata*)lua_touserdata(L,index);  /* get data */
  if (usr)
  {
    if (flags & SWIG_POINTER_DISOWN) /* must disown the object */
    {
        usr->own=0;
    }
    if (!type)            /* special cast void*, no casting fn */
    {
      *ptr=usr->ptr;
      return SWIG_OK; /* ok */
    }
    cast=SWIG_TypeCheckStruct(usr->type,type); /* performs normal type checking */
    if (cast)
    {
      int newmemory = 0;
      *ptr=SWIG_TypeCast(cast,usr->ptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
      return SWIG_OK;  /* ok */
    }
  }
  return SWIG_ERROR;  /* error */
}

SWIGRUNTIME void* SWIG_Lua_MustGetPtr(lua_State* L,int index,swig_type_info *type,int flags,
       int argnum,const char* func_name){
  void* result;
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,index,&result,type,flags))){
    lua_pushfstring(L,"Error in %s, expected a %s at argument number %d\n",
      func_name,(type && type->str)?type->str:"void*",argnum);
    lua_error(L);
  }
  return result;
}

/* pushes a packed userdata. user for member fn pointers only */
SWIGRUNTIME void SWIG_Lua_NewPackedObj(lua_State* L,void* ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata* raw;
  assert(ptr); /* not acceptable to pass in a NULL value */
  raw=(swig_lua_rawdata*)lua_newuserdata(L,sizeof(swig_lua_rawdata)-1+size);  /* alloc data */
  raw->type=type;
  raw->own=0;
  memcpy(raw->data,ptr,size); /* copy the data */
  _SWIG_Lua_AddMetatable(L,type); /* add metatable */
}
    
/* converts a packed userdata. user for member fn pointers only */
SWIGRUNTIME int  SWIG_Lua_ConvertPacked(lua_State* L,int index,void* ptr,size_t size,swig_type_info *type)
{
  swig_lua_rawdata* raw;
  raw=(swig_lua_rawdata*)lua_touserdata(L,index);  /* get data */
  if (!raw) return SWIG_ERROR;  /* error */
  if (type==0 || type==raw->type) /* void* or identical type */
  {
    memcpy(ptr,raw->data,size); /* copy it */
    return SWIG_OK; /* ok */
  }
  return SWIG_ERROR;  /* error */
}

/* a function to get the typestring of a piece of data */
SWIGRUNTIME const char *SWIG_Lua_typename(lua_State *L, int tp)
{
  swig_lua_userdata* usr;
  if (lua_isuserdata(L,tp))
  {
    usr=(swig_lua_userdata*)lua_touserdata(L,tp);  /* get data */
    if (usr && usr->type && usr->type->str)
      return usr->type->str;
    return "userdata (unknown type)";
  }
  return lua_typename(L,lua_type(L,tp));
}

/* lua callable function to get the userdata's type */
SWIGRUNTIME int SWIG_Lua_type(lua_State* L)
{
  lua_pushstring(L,SWIG_Lua_typename(L,1));
  return 1;
}

/* lua callable function to compare userdata's value
the issue is that two userdata may point to the same thing
but to lua, they are different objects */
SWIGRUNTIME int SWIG_Lua_equal(lua_State* L)
{
  int result;
  swig_lua_userdata *usr1,*usr2;
  if (!lua_isuserdata(L,1) || !lua_isuserdata(L,2))  /* just in case */
    return 0;  /* nil reply */
  usr1=(swig_lua_userdata*)lua_touserdata(L,1);  /* get data */
  usr2=(swig_lua_userdata*)lua_touserdata(L,2);  /* get data */
  /*result=(usr1->ptr==usr2->ptr && usr1->type==usr2->type); only works if type is the same*/
  result=(usr1->ptr==usr2->ptr);
   lua_pushboolean(L,result);
  return 1;
}

/* -----------------------------------------------------------------------------
 * global variable support code: class/struct typemap functions
 * ----------------------------------------------------------------------------- */

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC))
/* Install Constants */
SWIGINTERN void
SWIG_Lua_InstallConstants(lua_State* L, swig_lua_const_info constants[]) {
  int i;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_LUA_INT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_FLOAT:
      lua_pushstring(L,constants[i].name);
      lua_pushnumber(L,(lua_Number)constants[i].dvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_CHAR:
      lua_pushstring(L,constants[i].name);
      lua_pushfstring(L,"%c",(char)constants[i].lvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_STRING:
      lua_pushstring(L,constants[i].name);
      lua_pushstring(L,(char *) constants[i].pvalue);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_POINTER:
      lua_pushstring(L,constants[i].name);
      SWIG_NewPointerObj(L,constants[i].pvalue, *(constants[i]).ptype,0);
      lua_rawset(L,-3);
      break;
    case SWIG_LUA_BINARY:
      lua_pushstring(L,constants[i].name);
      SWIG_NewMemberObj(L,constants[i].pvalue,constants[i].lvalue,*(constants[i]).ptype);
      lua_rawset(L,-3);
      break;
    default:
      break;
    }
  }
}
#endif

/* -----------------------------------------------------------------------------
 * executing lua code from within the wrapper
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DOSTRING_FAIL /* Allows redefining of error function */
#define SWIG_DOSTRING_FAIL(S) fprintf(stderr,"%s\n",S)
#endif
/* Executes a C string in Lua a really simple way of calling lua from C
Unfortunately lua keeps changing its API's, so we need a conditional compile
In lua 5.0.X its lua_dostring()
In lua 5.1.X its luaL_dostring()
*/
SWIGINTERN int 
SWIG_Lua_dostring(lua_State *L, const char* str) {
  int ok,top;
  if (str==0 || str[0]==0) return 0; /* nothing to do */
  top=lua_gettop(L); /* save stack */
#if (defined(LUA_VERSION_NUM) && (LUA_VERSION_NUM>=501))
  ok=luaL_dostring(L,str);	/* looks like this is lua 5.1.X or later, good */
#else
  ok=lua_dostring(L,str);	/* might be lua 5.0.x, using lua_dostring */
#endif
  if (ok!=0) {
    SWIG_DOSTRING_FAIL(lua_tostring(L,-1));
  }
  lua_settop(L,top); /* restore the stack */
  return ok;
}    

#ifdef __cplusplus
}
#endif

/* ------------------------------ end luarun.swg  ------------------------------ */


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_ASM_state swig_types[0]
#define SWIGTYPE_p_ASM_state_u swig_types[1]
#define SWIGTYPE_p_ASM_state_u_context swig_types[2]
#define SWIGTYPE_p_ASM_state_u_insert swig_types[3]
#define SWIGTYPE_p_ASM_state_u_kern swig_types[4]
#define SWIGTYPE_p_BDFChar_dependents swig_types[5]
#define SWIGTYPE_p_BDFProperties_u swig_types[6]
#define SWIGTYPE_p_Base swig_types[7]
#define SWIGTYPE_p_FILE swig_types[8]
#define SWIGTYPE_p_FPST_rules swig_types[9]
#define SWIGTYPE_p_FPST_rules_lookups swig_types[10]
#define SWIGTYPE_p_FPST_rules_u swig_types[11]
#define SWIGTYPE_p_FPST_rules_u_class swig_types[12]
#define SWIGTYPE_p_FPST_rules_u_coverage swig_types[13]
#define SWIGTYPE_p_FPST_rules_u_glyph swig_types[14]
#define SWIGTYPE_p_FPST_rules_u_rcoverage swig_types[15]
#define SWIGTYPE_p_ItalicInfo_lc swig_types[16]
#define SWIGTYPE_p_ItalicInfo_neither swig_types[17]
#define SWIGTYPE_p_ItalicInfo_uc swig_types[18]
#define SWIGTYPE_p_MATH swig_types[19]
#define SWIGTYPE_p_MMSet_axismaps swig_types[20]
#define SWIGTYPE_p_MMSet_named_instances swig_types[21]
#define SWIGTYPE_p_MacFeat_settings swig_types[22]
#define SWIGTYPE_p_NameList_renames swig_types[23]
#define SWIGTYPE_p_OTLookup_subtables swig_types[24]
#define SWIGTYPE_p_PST_u swig_types[25]
#define SWIGTYPE_p_PST_u_alt swig_types[26]
#define SWIGTYPE_p_PST_u_lcaret swig_types[27]
#define SWIGTYPE_p_PST_u_lig swig_types[28]
#define SWIGTYPE_p_PST_u_mult swig_types[29]
#define SWIGTYPE_p_PST_u_pair swig_types[30]
#define SWIGTYPE_p_PST_u_subs swig_types[31]
#define SWIGTYPE_p_RefChar_layers swig_types[32]
#define SWIGTYPE_p_SplineChar_altuni swig_types[33]
#define SWIGTYPE_p_SplineChar_dependents swig_types[34]
#define SWIGTYPE_p_SplineFont_gasp swig_types[35]
#define SWIGTYPE_p_SplineFont_pfminfo swig_types[36]
#define SWIGTYPE_p_SplineFont_ttf_tab_saved swig_types[37]
#define SWIGTYPE_p_SplineFont_ttf_tables swig_types[38]
#define SWIGTYPE_p_StemInfo_u swig_types[39]
#define SWIGTYPE_p_Undoes_u swig_types[40]
#define SWIGTYPE_p_Undoes_u_composit swig_types[41]
#define SWIGTYPE_p_Undoes_u_multiple swig_types[42]
#define SWIGTYPE_p_Undoes_u_possub swig_types[43]
#define SWIGTYPE_p_Undoes_u_state swig_types[44]
#define SWIGTYPE_p_Val_u swig_types[45]
#define SWIGTYPE_p_a_2__a_16__float swig_types[46]
#define SWIGTYPE_p_a_2__float swig_types[47]
#define SWIGTYPE_p_a_96_8__unsigned_char swig_types[48]
#define SWIGTYPE_p_alltabs swig_types[49]
#define SWIGTYPE_p_altuni swig_types[50]
#define SWIGTYPE_p_anchorclass swig_types[51]
#define SWIGTYPE_p_anchorpoint swig_types[52]
#define SWIGTYPE_p_anchorpos swig_types[53]
#define SWIGTYPE_p_archivers swig_types[54]
#define SWIGTYPE_p_array swig_types[55]
#define SWIGTYPE_p_baselangextent swig_types[56]
#define SWIGTYPE_p_basepoint swig_types[57]
#define SWIGTYPE_p_basescript swig_types[58]
#define SWIGTYPE_p_bdfchar swig_types[59]
#define SWIGTYPE_p_bdfcharlist swig_types[60]
#define SWIGTYPE_p_bdffloat swig_types[61]
#define SWIGTYPE_p_bdffont swig_types[62]
#define SWIGTYPE_p_bdfprops swig_types[63]
#define SWIGTYPE_p_bitmapview swig_types[64]
#define SWIGTYPE_p_bluedata swig_types[65]
#define SWIGTYPE_p_bluezone swig_types[66]
#define SWIGTYPE_p_brush swig_types[67]
#define SWIGTYPE_p_char swig_types[68]
#define SWIGTYPE_p_charinfo swig_types[69]
#define SWIGTYPE_p_charprocs swig_types[70]
#define SWIGTYPE_p_charviewbase swig_types[71]
#define SWIGTYPE_p_cidbytes swig_types[72]
#define SWIGTYPE_p_cidmap swig_types[73]
#define SWIGTYPE_p_clut swig_types[74]
#define SWIGTYPE_p_compressors swig_types[75]
#define SWIGTYPE_p_dbasepoint swig_types[76]
#define SWIGTYPE_p_dbounds swig_types[77]
#define SWIGTYPE_p_double swig_types[78]
#define SWIGTYPE_p_dsteminfo swig_types[79]
#define SWIGTYPE_p_enc swig_types[80]
#define SWIGTYPE_p_encmap swig_types[81]
#define SWIGTYPE_p_f_int__int swig_types[82]
#define SWIGTYPE_p_f_int_p_void__void swig_types[83]
#define SWIGTYPE_p_f_p_void_int_unsigned_int_unsigned_int__void swig_types[84]
#define SWIGTYPE_p_f_p_void_p_struct_spline_float__double swig_types[85]
#define SWIGTYPE_p_f_void__void swig_types[86]
#define SWIGTYPE_p_fd2data swig_types[87]
#define SWIGTYPE_p_featurescriptlanglist swig_types[88]
#define SWIGTYPE_p_findsel swig_types[89]
#define SWIGTYPE_p_float swig_types[90]
#define SWIGTYPE_p_fontdict swig_types[91]
#define SWIGTYPE_p_fontviewbase swig_types[92]
#define SWIGTYPE_p_fpst_rule swig_types[93]
#define SWIGTYPE_p_freetype_raster swig_types[94]
#define SWIGTYPE_p_generic_asm swig_types[95]
#define SWIGTYPE_p_generic_fpst swig_types[96]
#define SWIGTYPE_p_generic_pst swig_types[97]
#define SWIGTYPE_p_gfi_data swig_types[98]
#define SWIGTYPE_p_gimage swig_types[99]
#define SWIGTYPE_p_globalinstrct swig_types[100]
#define SWIGTYPE_p_glyphdata swig_types[101]
#define SWIGTYPE_p_glyphnamehash swig_types[102]
#define SWIGTYPE_p_glyphvariants swig_types[103]
#define SWIGTYPE_p_glyphvariants_parts swig_types[104]
#define SWIGTYPE_p_gradient swig_types[105]
#define SWIGTYPE_p_gradient_grad_stops swig_types[106]
#define SWIGTYPE_p_growbuf swig_types[107]
#define SWIGTYPE_p_hintinstance swig_types[108]
#define SWIGTYPE_p_ibounds swig_types[109]
#define SWIGTYPE_p_iconv_t swig_types[110]
#define SWIGTYPE_p_imagelist swig_types[111]
#define SWIGTYPE_p_instrdata swig_types[112]
#define SWIGTYPE_p_int swig_types[113]
#define SWIGTYPE_p_intptr_t swig_types[114]
#define SWIGTYPE_p_ipoint swig_types[115]
#define SWIGTYPE_p_italicinfo swig_types[116]
#define SWIGTYPE_p_jstf_lang swig_types[117]
#define SWIGTYPE_p_jstf_prio swig_types[118]
#define SWIGTYPE_p_jstf_script swig_types[119]
#define SWIGTYPE_p_kernclass swig_types[120]
#define SWIGTYPE_p_kernclassdlg swig_types[121]
#define SWIGTYPE_p_kernclasslistdlg swig_types[122]
#define SWIGTYPE_p_kernpair swig_types[123]
#define SWIGTYPE_p_lang_frequencies swig_types[124]
#define SWIGTYPE_p_layer swig_types[125]
#define SWIGTYPE_p_layerinfo swig_types[126]
#define SWIGTYPE_p_library_version_configuration swig_types[127]
#define SWIGTYPE_p_liglist swig_types[128]
#define SWIGTYPE_p_linearapprox swig_types[129]
#define SWIGTYPE_p_linelist swig_types[130]
#define SWIGTYPE_p_lookup_subtable swig_types[131]
#define SWIGTYPE_p_macfeat swig_types[132]
#define SWIGTYPE_p_macname swig_types[133]
#define SWIGTYPE_p_macsetting swig_types[134]
#define SWIGTYPE_p_math_constants_descriptor swig_types[135]
#define SWIGTYPE_p_mathkern swig_types[136]
#define SWIGTYPE_p_mathkernvertex swig_types[137]
#define SWIGTYPE_p_mathkernvertex_mkd swig_types[138]
#define SWIGTYPE_p_metricsview swig_types[139]
#define SWIGTYPE_p_minimumdistance swig_types[140]
#define SWIGTYPE_p_mmset swig_types[141]
#define SWIGTYPE_p_namelist swig_types[142]
#define SWIGTYPE_p_opentype_feature_friendlynames swig_types[143]
#define SWIGTYPE_p_opentype_str swig_types[144]
#define SWIGTYPE_p_otffeatname swig_types[145]
#define SWIGTYPE_p_otfname swig_types[146]
#define SWIGTYPE_p_otlookup swig_types[147]
#define SWIGTYPE_p_p_anchorpoint swig_types[148]
#define SWIGTYPE_p_p_basepoint swig_types[149]
#define SWIGTYPE_p_p_bdfchar swig_types[150]
#define SWIGTYPE_p_p_bdffont swig_types[151]
#define SWIGTYPE_p_p_char swig_types[152]
#define SWIGTYPE_p_p_dsteminfo swig_types[153]
#define SWIGTYPE_p_p_macfeat swig_types[154]
#define SWIGTYPE_p_p_macsetting swig_types[155]
#define SWIGTYPE_p_p_otlookup swig_types[156]
#define SWIGTYPE_p_p_p_lang_frequencies swig_types[157]
#define SWIGTYPE_p_p_p_p_char swig_types[158]
#define SWIGTYPE_p_p_p_splinechar swig_types[159]
#define SWIGTYPE_p_p_p_unicode_nameannot swig_types[160]
#define SWIGTYPE_p_p_pschars swig_types[161]
#define SWIGTYPE_p_p_spline swig_types[162]
#define SWIGTYPE_p_p_splinechar swig_types[163]
#define SWIGTYPE_p_p_splinefont swig_types[164]
#define SWIGTYPE_p_p_splinepoint swig_types[165]
#define SWIGTYPE_p_p_splinepointlist swig_types[166]
#define SWIGTYPE_p_p_unsigned_char swig_types[167]
#define SWIGTYPE_p_pattern swig_types[168]
#define SWIGTYPE_p_pen swig_types[169]
#define SWIGTYPE_p_pfminfo swig_types[170]
#define SWIGTYPE_p_pschars swig_types[171]
#define SWIGTYPE_p_pscontext swig_types[172]
#define SWIGTYPE_p_psdict swig_types[173]
#define SWIGTYPE_p_refbdfc swig_types[174]
#define SWIGTYPE_p_refchar swig_types[175]
#define SWIGTYPE_p_remap swig_types[176]
#define SWIGTYPE_p_scriptlanglist swig_types[177]
#define SWIGTYPE_p_sflist swig_types[178]
#define SWIGTYPE_p_sfmergecontext swig_types[179]
#define SWIGTYPE_p_sfmergecontext_acs swig_types[180]
#define SWIGTYPE_p_sfmergecontext_lks swig_types[181]
#define SWIGTYPE_p_sfmergecontext_subs swig_types[182]
#define SWIGTYPE_p_short swig_types[183]
#define SWIGTYPE_p_shortview swig_types[184]
#define SWIGTYPE_p_signed_char swig_types[185]
#define SWIGTYPE_p_simplifyinfo swig_types[186]
#define SWIGTYPE_p_sllk swig_types[187]
#define SWIGTYPE_p_spiro_cp swig_types[188]
#define SWIGTYPE_p_spline swig_types[189]
#define SWIGTYPE_p_spline1d swig_types[190]
#define SWIGTYPE_p_splinechar swig_types[191]
#define SWIGTYPE_p_splinecharlist swig_types[192]
#define SWIGTYPE_p_splinefont swig_types[193]
#define SWIGTYPE_p_splinepoint swig_types[194]
#define SWIGTYPE_p_splinepointlist swig_types[195]
#define SWIGTYPE_p_std_bdf_props swig_types[196]
#define SWIGTYPE_p_stdstem swig_types[197]
#define SWIGTYPE_p_steminfo swig_types[198]
#define SWIGTYPE_p_strokeinfo swig_types[199]
#define SWIGTYPE_p_tex_data swig_types[200]
#define SWIGTYPE_p_tpoint swig_types[201]
#define SWIGTYPE_p_ttf_table swig_types[202]
#define SWIGTYPE_p_ttfinfo swig_types[203]
#define SWIGTYPE_p_ttflangname swig_types[204]
#define SWIGTYPE_p_undoes swig_types[205]
#define SWIGTYPE_p_unicode_nameannot swig_types[206]
#define SWIGTYPE_p_unsigned_char swig_types[207]
#define SWIGTYPE_p_unsigned_int swig_types[208]
#define SWIGTYPE_p_unsigned_short swig_types[209]
#define SWIGTYPE_p_val swig_types[210]
#define SWIGTYPE_p_val_data swig_types[211]
#define SWIGTYPE_p_void swig_types[212]
#define SWIGTYPE_p_vr swig_types[213]
#define SWIGTYPE_p_xlfd_components swig_types[214]
static swig_type_info *swig_types[216];
static swig_module_info swig_module = {swig_types, 215, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_name      "fflua"
#define SWIG_init      luaopen_fflua
#define SWIG_init_user luaopen_fflua_user

#define SWIG_LUACODE   luaopen_fflua_luacode

#include "fontforge/fontforge.h"
extern int running_script ;


typedef union {
  int ival;
  float fval;
  char *sval;
  struct val *lval;
  struct array *aval;
  uint32 *u32ptval;
  uint16 *u16ptval;
  uint8  *u8ptval;
} Val_u;



SWIGINTERN int SWIG_lua_isnilstring(lua_State *L, int idx) {
  int ret = lua_isstring(L, idx);
  if (!ret)
   ret = lua_isnil(L, idx);
  return ret;
}

typedef struct {
  float offset;
  uint32 col;
  float opacity;
} gradient_grad_stops;


typedef struct {
  double lsb_percent, stem_percent, counter_percent, rsb_percent; 
} ItalicInfo_lc;


typedef struct {
  double lsb_percent, stem_percent, counter_percent, rsb_percent; 
} ItalicInfo_uc;


typedef struct {
  double lsb_percent, stem_percent, counter_percent, rsb_percent; 
} ItalicInfo_neither;


typedef struct {
  char *subtable_name;
  char *suffix;			                                                         
  int16 separation, minkern;	                                                         
  struct otlookup *lookup;
  unsigned int unused: 1;
  unsigned int per_glyph_pst_or_kern: 1;
  unsigned int anchor_classes: 1;
  unsigned int vertical_kerning: 1;
  unsigned int ticked: 1;
  unsigned int kerning_by_touch: 1;	                                                                
  unsigned int onlyCloser: 1;		                         
  unsigned int dontautokern: 1;		                         
  struct kernclass *kc;
  struct generic_fpst *fpst;
  struct generic_asm  *sm;
  
  
  
  
  
  
  
  struct lookup_subtable *next;
  int32 subtable_offset;
  int32 *extra_subtables;
  
  
  
  
} OTLookup_subtables;


typedef union {
  struct vr pos;
  struct {
    char *paired; struct vr *vr; 
  } pair;
  struct {
    char *variant; 
  } subs;
  struct {
    char *components; 
  } mult, alt;
  struct {
    char *components; struct splinechar *lig; 
  } lig;
  struct {
    int16 *carets; int cnt; 
  } lcaret;	                              
} PST_u;


typedef struct {
  char *paired; struct vr *vr; 
} PST_u_pair;


typedef struct {
  char *variant; 
} PST_u_subs;


typedef struct {
  char *components; 
} PST_u_mult;


typedef struct {
  char *components; 
} PST_u_alt;


typedef struct {
  char *components; struct splinechar *lig; 
} PST_u_lig;


typedef struct {
  int16 *carets; int cnt; 
} PST_u_lcaret;


typedef struct {
  union {
    struct     {
      char *names, *back, *fore; 
    } glyph;
    struct     {
      int ncnt, bcnt, fcnt; uint16 *nclasses, *bclasses, *fclasses, *allclasses; 
    } class;
    struct     {
      int ncnt, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; 
    } coverage;
    struct     {
      int always1, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; char *replacements; 
    } rcoverage;
  } u;
  int lookup_cnt;
  struct           {
    int seq;
    struct otlookup *lookup;
  } *lookups;
} FPST_rules;


typedef union {
  struct     {
    char *names, *back, *fore; 
  } glyph;
  struct     {
    int ncnt, bcnt, fcnt; uint16 *nclasses, *bclasses, *fclasses, *allclasses; 
  } class;
  struct     {
    int ncnt, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; 
  } coverage;
  struct     {
    int always1, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; char *replacements; 
  } rcoverage;
} FPST_rules_u;


typedef struct {
  int seq;
  struct otlookup *lookup;
} FPST_rules_lookups;


typedef struct {
  char *names, *back, *fore; 
} FPST_rules_u_glyph;


typedef struct {
  int ncnt, bcnt, fcnt; uint16 *nclasses, *bclasses, *fclasses, *allclasses; 
} FPST_rules_u_class;


typedef struct {
  int ncnt, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; 
} FPST_rules_u_coverage;


typedef struct {
  int always1, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; char *replacements; 
} FPST_rules_u_rcoverage;


typedef struct {
  uint16 next_state;
  uint16 flags;
  union {
    struct {
      struct otlookup *mark_lookup;	                                                        
      struct otlookup *cur_lookup;	                               
    } context;
    struct {
      char *mark_ins;
      char *cur_ins;
    } insert;
    struct {
      int16 *kerns;
      int kcnt;
    } kern;
  } u;
} ASM_state;


typedef union {
  struct {
    struct otlookup *mark_lookup;	                                                        
    struct otlookup *cur_lookup;	                               
  } context;
  struct {
    char *mark_ins;
    char *cur_ins;
  } insert;
  struct {
    int16 *kerns;
    int kcnt;
  } kern;
} ASM_state_u;


typedef struct {
  struct otlookup *mark_lookup;	                                                        
  struct otlookup *cur_lookup;	                               
} ASM_state_u_context;


typedef struct {
  char *mark_ins;
  char *cur_ins;
} ASM_state_u_insert;


typedef struct {
  int16 *kerns;
  int kcnt;
} ASM_state_u_kern;


typedef struct {
  struct macsetting *next;
  uint16 setting;
  uint16 strid;
  struct macname *setname;
  unsigned int initially_enabled: 1;
} MacFeat_settings;


typedef struct {
  struct bdfchar *bc;
  struct bdfcharlist *next;
} BDFChar_dependents;


typedef union {
  struct {
    int16 width, vwidth;
    int16 lbearingchange;
    int unicodeenc;			                           
    char *charname;			                           
    char *comment;			             
    PST *possub;			                           
    struct splinepointlist *splines;
    struct refchar *refs;
    
    struct imagelist *images;
    void *hints;			                                
    uint8 *instrs;
    int instrs_len;
    AnchorPoint *anchor;
    
    
    
    
    
    
    
  } state;
  int width;	                                         
  int lbearing;	                         
  int rbearing;	                         
  BDFChar bmpstate;
  struct {
    struct undoes *state;
    struct undoes *bitmaps;
  } composit;
  struct {
    struct undoes *mult;                                                                              
    
  } multiple;
  struct {
    enum possub_type pst;
    char **data;		                                                
    struct undoes *more_pst;
    short cnt,max;		                    
  } possub;
  uint8 *bitmap;
} Undoes_u;


typedef struct {
  int16 width, vwidth;
  int16 lbearingchange;
  int unicodeenc;			                           
  char *charname;			                           
  char *comment;			             
  PST *possub;			                           
  struct splinepointlist *splines;
  struct refchar *refs;
  
  struct imagelist *images;
  void *hints;			                                
  uint8 *instrs;
  int instrs_len;
  AnchorPoint *anchor;
  
  
  
  
  
  
  
} Undoes_u_state;


typedef struct {
  struct undoes *state;
  struct undoes *bitmaps;
} Undoes_u_composit;


typedef struct {
  struct undoes *mult;                                                                              
  
} Undoes_u_multiple;


typedef struct {
  enum possub_type pst;
  char **data;		                                                
  struct undoes *more_pst;
  short cnt,max;		                    
} Undoes_u_possub;


typedef struct {
  char *from; char *to; 
} NameList_renames;


typedef union {
  char *str;
  char *atom;
  int val;
} BDFProperties_u;


typedef struct {
  unsigned int background: 1;
  unsigned int order2: 1;
  unsigned int anyflexes: 1;
  
  
  
  
  
  
  
  SplinePointList *splines;
  ImageList *images;			                                          
} RefChar_layers;


typedef union {
  int mask;		                                               
  
  _MMArray *unblended               ;	                                         
} StemInfo_u;


typedef struct {
  char *component;
  unsigned int is_extender: 1;	                                               
  uint16 startConnectorLength;
  uint16 endConnectorLength;
  uint16 fullAdvance;
} glyphvariants_parts;


typedef struct {
  int16 height,kern;
  
  
  
  
} mathkernvertex_mkd;


typedef struct {
  struct splinechar *sc; struct splinecharlist *next;
} SplineChar_dependents;


typedef struct {
  struct altuni *next; int unienc, vs, fid; 
} SplineChar_altuni;


typedef struct {
  unsigned int pfmset: 1;
  unsigned int winascent_add: 1;
  unsigned int windescent_add: 1;
  unsigned int hheadascent_add: 1;
  unsigned int hheaddescent_add: 1;
  unsigned int typoascent_add: 1;
  unsigned int typodescent_add: 1;
  unsigned int subsuper_set: 1;
  unsigned int panose_set: 1;
  unsigned int hheadset: 1;
  unsigned int vheadset: 1;
  unsigned int hascodepages: 1;
  unsigned int hasunicoderanges: 1;
  unsigned char pfmfamily;
  int16 weight;
  int16 width;
  char panose[10];
  int16 fstype;
  int16 linegap;		               
  int16 vlinegap;		               
  int16 hhead_ascent, hhead_descent;
  int16 os2_typoascent, os2_typodescent, os2_typolinegap;
  int16 os2_winascent, os2_windescent;
  int16 os2_subxsize, os2_subysize, os2_subxoff, os2_subyoff;
  int16 os2_supxsize, os2_supysize, os2_supxoff, os2_supyoff;
  int16 os2_strikeysize, os2_strikeypos;
  char os2_vendor[4];
  int16 os2_family_class;
  uint32 codepages[2];
  uint32 unicoderanges[4];
} SplineFont_pfminfo;


typedef struct {
  uint32 tag;
  int32 len, maxlen;
  uint8 *data;
  struct ttf_table *next;
  FILE *temp;	                                              
} SplineFont_ttf_tables;


typedef struct {
  uint32 tag;
  int32 len, maxlen;
  uint8 *data;
  struct ttf_table *next;
  FILE *temp;	                                              
} SplineFont_ttf_tab_saved;


typedef struct {
  uint16 ppem;
  uint16 flags;
} SplineFont_gasp;


typedef struct {
  int points;	                                 
  float *blends;	                                                         
  float *designs;	                                                                          
  float min, def, max;		             
  struct macname *axisnames;	             
} MMSet_axismaps;


typedef struct {
  float *coords;	                                          
  struct macname *names;
} MMSet_named_instances;


typedef struct {
  OTLookup *from, *to; int old;
} sfmergecontext_lks;


typedef struct {
  struct lookup_subtable *from, *to; int old;
} sfmergecontext_subs;


typedef struct {
  AnchorClass *from, *to; int old;
} sfmergecontext_acs;



static SplineChar * *new_SplineCharArray(int nelements) { 
  return (SplineChar * *) calloc(nelements,sizeof(SplineChar *)); 
}

static void delete_SplineCharArray(SplineChar * *ary) { 
  free(ary); 
}

static SplineChar * SplineCharArray_getitem(SplineChar * *ary, int index) {
    return ary[index];
}
static void SplineCharArray_setitem(SplineChar * *ary, int index, SplineChar * value) {
    ary[index] = value;
}


static Layer *new_LayerArray(int nelements) { 
  return (Layer *) calloc(nelements,sizeof(Layer)); 
}

static void delete_LayerArray(Layer *ary) { 
  free(ary); 
}

static Layer LayerArray_getitem(Layer *ary, int index) {
    return ary[index];
}
static void LayerArray_setitem(Layer *ary, int index, Layer value) {
    ary[index] = value;
}


static LayerInfo *new_LayerInfoArray(int nelements) { 
  return (LayerInfo *) calloc(nelements,sizeof(LayerInfo)); 
}

static void delete_LayerInfoArray(LayerInfo *ary) { 
  free(ary); 
}

static LayerInfo LayerInfoArray_getitem(LayerInfo *ary, int index) {
    return ary[index];
}
static void LayerInfoArray_setitem(LayerInfo *ary, int index, LayerInfo value) {
    ary[index] = value;
}


static SplinePointList *new_SplinePointListArray(int nelements) { 
  return (SplinePointList *) calloc(nelements,sizeof(SplinePointList)); 
}

static void delete_SplinePointListArray(SplinePointList *ary) { 
  free(ary); 
}

static SplinePointList SplinePointListArray_getitem(SplinePointList *ary, int index) {
    return ary[index];
}
static void SplinePointListArray_setitem(SplinePointList *ary, int index, SplinePointList value) {
    ary[index] = value;
}


static Spline *new_SplineArray(int nelements) { 
  return (Spline *) calloc(nelements,sizeof(Spline)); 
}

static void delete_SplineArray(Spline *ary) { 
  free(ary); 
}

static Spline SplineArray_getitem(Spline *ary, int index) {
    return ary[index];
}
static void SplineArray_setitem(Spline *ary, int index, Spline value) {
    ary[index] = value;
}

#ifdef __cplusplus
extern "C" {
#endif
static int _wrap_galloc(lua_State* L) {
  int SWIG_arg = 0;
  long arg1 ;
  void *result = 0 ;
  
  SWIG_check_num_args("galloc",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("galloc",1,"long");
  arg1 = (long)lua_tonumber(L, 1);
  result = (void *)galloc(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gcalloc(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  long arg2 ;
  void *result = 0 ;
  
  SWIG_check_num_args("gcalloc",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("gcalloc",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gcalloc",2,"long");
  arg1 = (int)lua_tonumber(L, 1);
  arg2 = (long)lua_tonumber(L, 2);
  result = (void *)gcalloc(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_grealloc(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  long arg2 ;
  void *result = 0 ;
  
  SWIG_check_num_args("grealloc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("grealloc",1,"void *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("grealloc",2,"long");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"grealloc");
  arg2 = (long)lua_tonumber(L, 2);
  result = (void *)grealloc(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gfree(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  
  SWIG_check_num_args("gfree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gfree",1,"void *");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"gfree");
  gfree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_galloc_set_trap(lua_State* L) {
  int SWIG_arg = 0;
  void (*arg1)(void) = (void (*)(void)) 0 ;
  
  SWIG_check_num_args("galloc_set_trap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("galloc_set_trap",1,"void (*)(void)");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_f_void__void,0))){
    SWIG_fail_ptr("galloc_set_trap",1,SWIGTYPE_p_f_void__void);
  }
  
  galloc_set_trap(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IPoint_x_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ipoint *arg1 = (struct ipoint *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ipoint::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ipoint::x",1,"struct ipoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ipoint::x",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ipoint,0))){
    SWIG_fail_ptr("IPoint_x_set",1,SWIGTYPE_p_ipoint);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IPoint_x_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ipoint *arg1 = (struct ipoint *) 0 ;
  int result;
  
  SWIG_check_num_args("ipoint::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ipoint::x",1,"struct ipoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ipoint,0))){
    SWIG_fail_ptr("IPoint_x_get",1,SWIGTYPE_p_ipoint);
  }
  
  result = (int) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IPoint_y_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ipoint *arg1 = (struct ipoint *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ipoint::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ipoint::y",1,"struct ipoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ipoint::y",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ipoint,0))){
    SWIG_fail_ptr("IPoint_y_set",1,SWIGTYPE_p_ipoint);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IPoint_y_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ipoint *arg1 = (struct ipoint *) 0 ;
  int result;
  
  SWIG_check_num_args("ipoint::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ipoint::y",1,"struct ipoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ipoint,0))){
    SWIG_fail_ptr("IPoint_y_get",1,SWIGTYPE_p_ipoint);
  }
  
  result = (int) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IPoint(lua_State* L) {
  int SWIG_arg = 0;
  struct ipoint *result = 0 ;
  
  SWIG_check_num_args("ipoint::ipoint",0,0)
  result = (struct ipoint *)calloc(1, sizeof(struct ipoint));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ipoint,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IPoint(void *obj) {
struct ipoint *arg1 = (struct ipoint *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ipoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ipoint_attributes[] = {
    { "x", _wrap_IPoint_x_get, _wrap_IPoint_x_set},
    { "y", _wrap_IPoint_y_get, _wrap_IPoint_y_set},
    {0,0,0}
};
static swig_lua_class *swig_ipoint_bases[] = {0};
static const char *swig_ipoint_base_names[] = {0};
static swig_lua_class _wrap_class_ipoint = { "IPoint", &SWIGTYPE_p_ipoint,_wrap_new_IPoint, swig_delete_IPoint, swig_ipoint_methods, swig_ipoint_attributes, swig_ipoint_bases, swig_ipoint_base_names };

static int _wrap_BasePoint_x_set(lua_State* L) {
  int SWIG_arg = 0;
  struct basepoint *arg1 = (struct basepoint *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("basepoint::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basepoint::x",1,"struct basepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("basepoint::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BasePoint_x_set",1,SWIGTYPE_p_basepoint);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BasePoint_x_get(lua_State* L) {
  int SWIG_arg = 0;
  struct basepoint *arg1 = (struct basepoint *) 0 ;
  float result;
  
  SWIG_check_num_args("basepoint::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basepoint::x",1,"struct basepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BasePoint_x_get",1,SWIGTYPE_p_basepoint);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BasePoint_y_set(lua_State* L) {
  int SWIG_arg = 0;
  struct basepoint *arg1 = (struct basepoint *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("basepoint::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basepoint::y",1,"struct basepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("basepoint::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BasePoint_y_set",1,SWIGTYPE_p_basepoint);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BasePoint_y_get(lua_State* L) {
  int SWIG_arg = 0;
  struct basepoint *arg1 = (struct basepoint *) 0 ;
  float result;
  
  SWIG_check_num_args("basepoint::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basepoint::y",1,"struct basepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BasePoint_y_get",1,SWIGTYPE_p_basepoint);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BasePoint(lua_State* L) {
  int SWIG_arg = 0;
  struct basepoint *result = 0 ;
  
  SWIG_check_num_args("basepoint::basepoint",0,0)
  result = (struct basepoint *)calloc(1, sizeof(struct basepoint));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BasePoint(void *obj) {
struct basepoint *arg1 = (struct basepoint *) obj;
free((char *) arg1);
}
static swig_lua_method swig_basepoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_basepoint_attributes[] = {
    { "x", _wrap_BasePoint_x_get, _wrap_BasePoint_x_set},
    { "y", _wrap_BasePoint_y_get, _wrap_BasePoint_y_set},
    {0,0,0}
};
static swig_lua_class *swig_basepoint_bases[] = {0};
static const char *swig_basepoint_base_names[] = {0};
static swig_lua_class _wrap_class_basepoint = { "BasePoint", &SWIGTYPE_p_basepoint,_wrap_new_BasePoint, swig_delete_BasePoint, swig_basepoint_methods, swig_basepoint_attributes, swig_basepoint_bases, swig_basepoint_base_names };

static int _wrap_DBasePoint_x_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dbasepoint *arg1 = (struct dbasepoint *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("dbasepoint::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbasepoint::x",1,"struct dbasepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dbasepoint::x",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbasepoint,0))){
    SWIG_fail_ptr("DBasePoint_x_set",1,SWIGTYPE_p_dbasepoint);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBasePoint_x_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dbasepoint *arg1 = (struct dbasepoint *) 0 ;
  double result;
  
  SWIG_check_num_args("dbasepoint::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbasepoint::x",1,"struct dbasepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbasepoint,0))){
    SWIG_fail_ptr("DBasePoint_x_get",1,SWIGTYPE_p_dbasepoint);
  }
  
  result = (double) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBasePoint_y_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dbasepoint *arg1 = (struct dbasepoint *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("dbasepoint::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbasepoint::y",1,"struct dbasepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dbasepoint::y",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbasepoint,0))){
    SWIG_fail_ptr("DBasePoint_y_set",1,SWIGTYPE_p_dbasepoint);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBasePoint_y_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dbasepoint *arg1 = (struct dbasepoint *) 0 ;
  double result;
  
  SWIG_check_num_args("dbasepoint::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbasepoint::y",1,"struct dbasepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbasepoint,0))){
    SWIG_fail_ptr("DBasePoint_y_get",1,SWIGTYPE_p_dbasepoint);
  }
  
  result = (double) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_DBasePoint(lua_State* L) {
  int SWIG_arg = 0;
  struct dbasepoint *result = 0 ;
  
  SWIG_check_num_args("dbasepoint::dbasepoint",0,0)
  result = (struct dbasepoint *)calloc(1, sizeof(struct dbasepoint));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dbasepoint,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_DBasePoint(void *obj) {
struct dbasepoint *arg1 = (struct dbasepoint *) obj;
free((char *) arg1);
}
static swig_lua_method swig_dbasepoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_dbasepoint_attributes[] = {
    { "x", _wrap_DBasePoint_x_get, _wrap_DBasePoint_x_set},
    { "y", _wrap_DBasePoint_y_get, _wrap_DBasePoint_y_set},
    {0,0,0}
};
static swig_lua_class *swig_dbasepoint_bases[] = {0};
static const char *swig_dbasepoint_base_names[] = {0};
static swig_lua_class _wrap_class_dbasepoint = { "DBasePoint", &SWIGTYPE_p_dbasepoint,_wrap_new_DBasePoint, swig_delete_DBasePoint, swig_dbasepoint_methods, swig_dbasepoint_attributes, swig_dbasepoint_bases, swig_dbasepoint_base_names };

static int _wrap_TPoint_x_set(lua_State* L) {
  int SWIG_arg = 0;
  struct tpoint *arg1 = (struct tpoint *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("tpoint::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tpoint::x",1,"struct tpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tpoint::x",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("TPoint_x_set",1,SWIGTYPE_p_tpoint);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TPoint_x_get(lua_State* L) {
  int SWIG_arg = 0;
  struct tpoint *arg1 = (struct tpoint *) 0 ;
  float result;
  
  SWIG_check_num_args("tpoint::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tpoint::x",1,"struct tpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("TPoint_x_get",1,SWIGTYPE_p_tpoint);
  }
  
  result = (float) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TPoint_y_set(lua_State* L) {
  int SWIG_arg = 0;
  struct tpoint *arg1 = (struct tpoint *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("tpoint::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tpoint::y",1,"struct tpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tpoint::y",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("TPoint_y_set",1,SWIGTYPE_p_tpoint);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TPoint_y_get(lua_State* L) {
  int SWIG_arg = 0;
  struct tpoint *arg1 = (struct tpoint *) 0 ;
  float result;
  
  SWIG_check_num_args("tpoint::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tpoint::y",1,"struct tpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("TPoint_y_get",1,SWIGTYPE_p_tpoint);
  }
  
  result = (float) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TPoint_t_set(lua_State* L) {
  int SWIG_arg = 0;
  struct tpoint *arg1 = (struct tpoint *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("tpoint::t",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tpoint::t",1,"struct tpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tpoint::t",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("TPoint_t_set",1,SWIGTYPE_p_tpoint);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->t = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TPoint_t_get(lua_State* L) {
  int SWIG_arg = 0;
  struct tpoint *arg1 = (struct tpoint *) 0 ;
  float result;
  
  SWIG_check_num_args("tpoint::t",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tpoint::t",1,"struct tpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("TPoint_t_get",1,SWIGTYPE_p_tpoint);
  }
  
  result = (float) ((arg1)->t);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TPoint(lua_State* L) {
  int SWIG_arg = 0;
  struct tpoint *result = 0 ;
  
  SWIG_check_num_args("tpoint::tpoint",0,0)
  result = (struct tpoint *)calloc(1, sizeof(struct tpoint));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tpoint,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TPoint(void *obj) {
struct tpoint *arg1 = (struct tpoint *) obj;
free((char *) arg1);
}
static swig_lua_method swig_tpoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_tpoint_attributes[] = {
    { "x", _wrap_TPoint_x_get, _wrap_TPoint_x_set},
    { "y", _wrap_TPoint_y_get, _wrap_TPoint_y_set},
    { "t", _wrap_TPoint_t_get, _wrap_TPoint_t_set},
    {0,0,0}
};
static swig_lua_class *swig_tpoint_bases[] = {0};
static const char *swig_tpoint_base_names[] = {0};
static swig_lua_class _wrap_class_tpoint = { "TPoint", &SWIGTYPE_p_tpoint,_wrap_new_TPoint, swig_delete_TPoint, swig_tpoint_methods, swig_tpoint_attributes, swig_tpoint_bases, swig_tpoint_base_names };

static int _wrap_DBounds_minx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("dbounds::minx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::minx",1,"struct dbounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dbounds::minx",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_minx_set",1,SWIGTYPE_p_dbounds);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->minx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBounds_minx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float result;
  
  SWIG_check_num_args("dbounds::minx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::minx",1,"struct dbounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_minx_get",1,SWIGTYPE_p_dbounds);
  }
  
  result = (float) ((arg1)->minx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBounds_maxx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("dbounds::maxx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::maxx",1,"struct dbounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dbounds::maxx",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_maxx_set",1,SWIGTYPE_p_dbounds);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->maxx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBounds_maxx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float result;
  
  SWIG_check_num_args("dbounds::maxx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::maxx",1,"struct dbounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_maxx_get",1,SWIGTYPE_p_dbounds);
  }
  
  result = (float) ((arg1)->maxx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBounds_miny_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("dbounds::miny",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::miny",1,"struct dbounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dbounds::miny",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_miny_set",1,SWIGTYPE_p_dbounds);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->miny = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBounds_miny_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float result;
  
  SWIG_check_num_args("dbounds::miny",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::miny",1,"struct dbounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_miny_get",1,SWIGTYPE_p_dbounds);
  }
  
  result = (float) ((arg1)->miny);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBounds_maxy_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("dbounds::maxy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::maxy",1,"struct dbounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dbounds::maxy",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_maxy_set",1,SWIGTYPE_p_dbounds);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->maxy = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DBounds_maxy_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *arg1 = (struct dbounds *) 0 ;
  float result;
  
  SWIG_check_num_args("dbounds::maxy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dbounds::maxy",1,"struct dbounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("DBounds_maxy_get",1,SWIGTYPE_p_dbounds);
  }
  
  result = (float) ((arg1)->maxy);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_DBounds(lua_State* L) {
  int SWIG_arg = 0;
  struct dbounds *result = 0 ;
  
  SWIG_check_num_args("dbounds::dbounds",0,0)
  result = (struct dbounds *)calloc(1, sizeof(struct dbounds));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dbounds,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_DBounds(void *obj) {
struct dbounds *arg1 = (struct dbounds *) obj;
free((char *) arg1);
}
static swig_lua_method swig_dbounds_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_dbounds_attributes[] = {
    { "minx", _wrap_DBounds_minx_get, _wrap_DBounds_minx_set},
    { "maxx", _wrap_DBounds_maxx_get, _wrap_DBounds_maxx_set},
    { "miny", _wrap_DBounds_miny_get, _wrap_DBounds_miny_set},
    { "maxy", _wrap_DBounds_maxy_get, _wrap_DBounds_maxy_set},
    {0,0,0}
};
static swig_lua_class *swig_dbounds_bases[] = {0};
static const char *swig_dbounds_base_names[] = {0};
static swig_lua_class _wrap_class_dbounds = { "DBounds", &SWIGTYPE_p_dbounds,_wrap_new_DBounds, swig_delete_DBounds, swig_dbounds_methods, swig_dbounds_attributes, swig_dbounds_bases, swig_dbounds_base_names };

static int _wrap_IBounds_minx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ibounds::minx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::minx",1,"struct ibounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ibounds::minx",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_minx_set",1,SWIGTYPE_p_ibounds);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->minx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IBounds_minx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int result;
  
  SWIG_check_num_args("ibounds::minx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::minx",1,"struct ibounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_minx_get",1,SWIGTYPE_p_ibounds);
  }
  
  result = (int) ((arg1)->minx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IBounds_maxx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ibounds::maxx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::maxx",1,"struct ibounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ibounds::maxx",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_maxx_set",1,SWIGTYPE_p_ibounds);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->maxx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IBounds_maxx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int result;
  
  SWIG_check_num_args("ibounds::maxx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::maxx",1,"struct ibounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_maxx_get",1,SWIGTYPE_p_ibounds);
  }
  
  result = (int) ((arg1)->maxx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IBounds_miny_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ibounds::miny",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::miny",1,"struct ibounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ibounds::miny",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_miny_set",1,SWIGTYPE_p_ibounds);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->miny = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IBounds_miny_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int result;
  
  SWIG_check_num_args("ibounds::miny",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::miny",1,"struct ibounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_miny_get",1,SWIGTYPE_p_ibounds);
  }
  
  result = (int) ((arg1)->miny);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IBounds_maxy_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ibounds::maxy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::maxy",1,"struct ibounds *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ibounds::maxy",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_maxy_set",1,SWIGTYPE_p_ibounds);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->maxy = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IBounds_maxy_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *arg1 = (struct ibounds *) 0 ;
  int result;
  
  SWIG_check_num_args("ibounds::maxy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ibounds::maxy",1,"struct ibounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("IBounds_maxy_get",1,SWIGTYPE_p_ibounds);
  }
  
  result = (int) ((arg1)->maxy);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_IBounds(lua_State* L) {
  int SWIG_arg = 0;
  struct ibounds *result = 0 ;
  
  SWIG_check_num_args("ibounds::ibounds",0,0)
  result = (struct ibounds *)calloc(1, sizeof(struct ibounds));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ibounds,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_IBounds(void *obj) {
struct ibounds *arg1 = (struct ibounds *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ibounds_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ibounds_attributes[] = {
    { "minx", _wrap_IBounds_minx_get, _wrap_IBounds_minx_set},
    { "maxx", _wrap_IBounds_maxx_get, _wrap_IBounds_maxx_set},
    { "miny", _wrap_IBounds_miny_get, _wrap_IBounds_miny_set},
    { "maxy", _wrap_IBounds_maxy_get, _wrap_IBounds_maxy_set},
    {0,0,0}
};
static swig_lua_class *swig_ibounds_bases[] = {0};
static const char *swig_ibounds_base_names[] = {0};
static swig_lua_class _wrap_class_ibounds = { "IBounds", &SWIGTYPE_p_ibounds,_wrap_new_IBounds, swig_delete_IBounds, swig_ibounds_methods, swig_ibounds_attributes, swig_ibounds_bases, swig_ibounds_base_names };

static int _wrap_Val_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct val *arg1 = (struct val *) 0 ;
  enum val_type arg2 ;
  
  SWIG_check_num_args("val::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("val::type",1,"struct val *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("val::type",2,"enum val_type");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_val,0))){
    SWIG_fail_ptr("Val_type_set",1,SWIGTYPE_p_val);
  }
  
  arg2 = (enum val_type)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct val *arg1 = (struct val *) 0 ;
  enum val_type result;
  
  SWIG_check_num_args("val::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("val::type",1,"struct val *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_val,0))){
    SWIG_fail_ptr("Val_type_get",1,SWIGTYPE_p_val);
  }
  
  result = (enum val_type) ((arg1)->type);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_get(lua_State* L) {
  int SWIG_arg = 0;
  struct val *arg1 = (struct val *) 0 ;
  Val_u *result = 0 ;
  
  SWIG_check_num_args("val::u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("val::u",1,"struct val *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_val,0))){
    SWIG_fail_ptr("Val_u_get",1,SWIGTYPE_p_val);
  }
  
  result = (Val_u *)& ((arg1)->u);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Val_u,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Val(lua_State* L) {
  int SWIG_arg = 0;
  struct val *result = 0 ;
  
  SWIG_check_num_args("val::val",0,0)
  result = (struct val *)calloc(1, sizeof(struct val));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_val,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Val(void *obj) {
struct val *arg1 = (struct val *) obj;
free((char *) arg1);
}
static swig_lua_method swig_val_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_val_attributes[] = {
    { "type", _wrap_Val_type_get, _wrap_Val_type_set},
    { "u", _wrap_Val_u_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_val_bases[] = {0};
static const char *swig_val_base_names[] = {0};
static swig_lua_class _wrap_class_val = { "Val", &SWIGTYPE_p_val,_wrap_new_Val, swig_delete_Val, swig_val_methods, swig_val_attributes, swig_val_bases, swig_val_base_names };

static int _wrap_Val_u_ival_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Val_u::ival",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::ival",1,"Val_u *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Val_u::ival",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_ival_set",1,SWIGTYPE_p_Val_u);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ival = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_ival_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  int result;
  
  SWIG_check_num_args("Val_u::ival",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::ival",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_ival_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (int) ((arg1)->ival);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_fval_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("Val_u::fval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::fval",1,"Val_u *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Val_u::fval",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_fval_set",1,SWIGTYPE_p_Val_u);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->fval = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_fval_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  float result;
  
  SWIG_check_num_args("Val_u::fval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::fval",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_fval_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (float) ((arg1)->fval);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_sval_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("Val_u::sval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::sval",1,"Val_u *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Val_u::sval",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_sval_set",1,SWIGTYPE_p_Val_u);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->sval);
    if (arg2) {
      arg1->sval = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->sval, (const char *)arg2);
    } else {
      arg1->sval = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_sval_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("Val_u::sval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::sval",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_sval_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (char *) ((arg1)->sval);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_lval_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  struct val *arg2 = (struct val *) 0 ;
  
  SWIG_check_num_args("Val_u::lval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::lval",1,"Val_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Val_u::lval",2,"struct val *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_lval_set",1,SWIGTYPE_p_Val_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_val,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Val_u_lval_set",2,SWIGTYPE_p_val);
  }
  
  if (arg1) (arg1)->lval = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_lval_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  struct val *result = 0 ;
  
  SWIG_check_num_args("Val_u::lval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::lval",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_lval_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (struct val *) ((arg1)->lval);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_val,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_aval_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  struct array *arg2 = (struct array *) 0 ;
  
  SWIG_check_num_args("Val_u::aval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::aval",1,"Val_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Val_u::aval",2,"struct array *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_aval_set",1,SWIGTYPE_p_Val_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_array,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Val_u_aval_set",2,SWIGTYPE_p_array);
  }
  
  if (arg1) (arg1)->aval = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_aval_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  struct array *result = 0 ;
  
  SWIG_check_num_args("Val_u::aval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::aval",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_aval_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (struct array *) ((arg1)->aval);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_array,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_u32ptval_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  uint32 *arg2 = (uint32 *) 0 ;
  
  SWIG_check_num_args("Val_u::u32ptval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::u32ptval",1,"Val_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Val_u::u32ptval",2,"uint32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_u32ptval_set",1,SWIGTYPE_p_Val_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Val_u_u32ptval_set",2,SWIGTYPE_p_unsigned_int);
  }
  
  if (arg1) (arg1)->u32ptval = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_u32ptval_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("Val_u::u32ptval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::u32ptval",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_u32ptval_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (uint32 *) ((arg1)->u32ptval);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_u16ptval_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  
  SWIG_check_num_args("Val_u::u16ptval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::u16ptval",1,"Val_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Val_u::u16ptval",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_u16ptval_set",1,SWIGTYPE_p_Val_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Val_u_u16ptval_set",2,SWIGTYPE_p_unsigned_short);
  }
  
  if (arg1) (arg1)->u16ptval = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_u16ptval_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  uint16 *result = 0 ;
  
  SWIG_check_num_args("Val_u::u16ptval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::u16ptval",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_u16ptval_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (uint16 *) ((arg1)->u16ptval);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_u8ptval_set(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("Val_u::u8ptval",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::u8ptval",1,"Val_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Val_u::u8ptval",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_u8ptval_set",1,SWIGTYPE_p_Val_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Val_u_u8ptval_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->u8ptval = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Val_u_u8ptval_get(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *arg1 = (Val_u *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("Val_u::u8ptval",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Val_u::u8ptval",1,"Val_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Val_u,0))){
    SWIG_fail_ptr("Val_u_u8ptval_get",1,SWIGTYPE_p_Val_u);
  }
  
  result = (uint8 *) ((arg1)->u8ptval);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Val_u(lua_State* L) {
  int SWIG_arg = 0;
  Val_u *result = 0 ;
  
  SWIG_check_num_args("Val_u::Val_u",0,0)
  result = (Val_u *)calloc(1, sizeof(Val_u));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Val_u,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Val_u(void *obj) {
Val_u *arg1 = (Val_u *) obj;
free((char *) arg1);
}
static swig_lua_method swig_Val_u_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Val_u_attributes[] = {
    { "ival", _wrap_Val_u_ival_get, _wrap_Val_u_ival_set},
    { "fval", _wrap_Val_u_fval_get, _wrap_Val_u_fval_set},
    { "sval", _wrap_Val_u_sval_get, _wrap_Val_u_sval_set},
    { "lval", _wrap_Val_u_lval_get, _wrap_Val_u_lval_set},
    { "aval", _wrap_Val_u_aval_get, _wrap_Val_u_aval_set},
    { "u32ptval", _wrap_Val_u_u32ptval_get, _wrap_Val_u_u32ptval_set},
    { "u16ptval", _wrap_Val_u_u16ptval_get, _wrap_Val_u_u16ptval_set},
    { "u8ptval", _wrap_Val_u_u8ptval_get, _wrap_Val_u_u8ptval_set},
    {0,0,0}
};
static swig_lua_class *swig_Val_u_bases[] = {0};
static const char *swig_Val_u_base_names[] = {0};
static swig_lua_class _wrap_class_Val_u = { "Val_u", &SWIGTYPE_p_Val_u,_wrap_new_Val_u, swig_delete_Val_u, swig_Val_u_methods, swig_Val_u_attributes, swig_Val_u_bases, swig_Val_u_base_names };

static int _wrap_psdict_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("psdict::cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::cnt",1,"struct psdict *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("psdict::cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_cnt_set",1,SWIGTYPE_p_psdict);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_psdict_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  int result;
  
  SWIG_check_num_args("psdict::cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::cnt",1,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_cnt_get",1,SWIGTYPE_p_psdict);
  }
  
  result = (int) ((arg1)->cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_psdict_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("psdict::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::next",1,"struct psdict *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("psdict::next",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_next_set",1,SWIGTYPE_p_psdict);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_psdict_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  int result;
  
  SWIG_check_num_args("psdict::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::next",1,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_next_get",1,SWIGTYPE_p_psdict);
  }
  
  result = (int) ((arg1)->next);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_psdict_keys_set(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("psdict::keys",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::keys",1,"struct psdict *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("psdict::keys",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_keys_set",1,SWIGTYPE_p_psdict);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("psdict_keys_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->keys = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_psdict_keys_get(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("psdict::keys",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::keys",1,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_keys_get",1,SWIGTYPE_p_psdict);
  }
  
  result = (char **) ((arg1)->keys);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_psdict_values_set(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("psdict::values",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::values",1,"struct psdict *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("psdict::values",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_values_set",1,SWIGTYPE_p_psdict);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("psdict_values_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->values = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_psdict_values_get(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("psdict::values",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("psdict::values",1,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("psdict_values_get",1,SWIGTYPE_p_psdict);
  }
  
  result = (char **) ((arg1)->values);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_psdict(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *result = 0 ;
  
  SWIG_check_num_args("psdict::psdict",0,0)
  result = (struct psdict *)calloc(1, sizeof(struct psdict));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_psdict,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_psdict(void *obj) {
struct psdict *arg1 = (struct psdict *) obj;
free((char *) arg1);
}
static swig_lua_method swig_psdict_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_psdict_attributes[] = {
    { "cnt", _wrap_psdict_cnt_get, _wrap_psdict_cnt_set},
    { "next", _wrap_psdict_next_get, _wrap_psdict_next_set},
    { "keys", _wrap_psdict_keys_get, _wrap_psdict_keys_set},
    { "values", _wrap_psdict_values_get, _wrap_psdict_values_set},
    {0,0,0}
};
static swig_lua_class *swig_psdict_bases[] = {0};
static const char *swig_psdict_base_names[] = {0};
static swig_lua_class _wrap_class_psdict = { "psdict", &SWIGTYPE_p_psdict,_wrap_new_psdict, swig_delete_psdict, swig_psdict_methods, swig_psdict_attributes, swig_psdict_bases, swig_psdict_base_names };

static int _wrap_pschars_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pschars::cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::cnt",1,"struct pschars *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pschars::cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_cnt_set",1,SWIGTYPE_p_pschars);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int result;
  
  SWIG_check_num_args("pschars::cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::cnt",1,"struct pschars *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_cnt_get",1,SWIGTYPE_p_pschars);
  }
  
  result = (int) ((arg1)->cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pschars::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::next",1,"struct pschars *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pschars::next",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_next_set",1,SWIGTYPE_p_pschars);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int result;
  
  SWIG_check_num_args("pschars::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::next",1,"struct pschars *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_next_get",1,SWIGTYPE_p_pschars);
  }
  
  result = (int) ((arg1)->next);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_keys_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("pschars::keys",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::keys",1,"struct pschars *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pschars::keys",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_keys_set",1,SWIGTYPE_p_pschars);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("pschars_keys_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->keys = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_keys_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("pschars::keys",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::keys",1,"struct pschars *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_keys_get",1,SWIGTYPE_p_pschars);
  }
  
  result = (char **) ((arg1)->keys);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_values_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  uint8 **arg2 = (uint8 **) 0 ;
  
  SWIG_check_num_args("pschars::values",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::values",1,"struct pschars *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pschars::values",2,"uint8 **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_values_set",1,SWIGTYPE_p_pschars);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_unsigned_char,0))){
    SWIG_fail_ptr("pschars_values_set",2,SWIGTYPE_p_p_unsigned_char);
  }
  
  if (arg1) (arg1)->values = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_values_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  uint8 **result = 0 ;
  
  SWIG_check_num_args("pschars::values",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::values",1,"struct pschars *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_values_get",1,SWIGTYPE_p_pschars);
  }
  
  result = (uint8 **) ((arg1)->values);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_lens_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int *arg2 = (int *) 0 ;
  
  SWIG_check_num_args("pschars::lens",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::lens",1,"struct pschars *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pschars::lens",2,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_lens_set",1,SWIGTYPE_p_pschars);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("pschars_lens_set",2,SWIGTYPE_p_int);
  }
  
  if (arg1) (arg1)->lens = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_lens_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int *result = 0 ;
  
  SWIG_check_num_args("pschars::lens",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::lens",1,"struct pschars *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_lens_get",1,SWIGTYPE_p_pschars);
  }
  
  result = (int *) ((arg1)->lens);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_bias_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pschars::bias",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::bias",1,"struct pschars *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pschars::bias",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_bias_set",1,SWIGTYPE_p_pschars);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bias = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pschars_bias_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  int result;
  
  SWIG_check_num_args("pschars::bias",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pschars::bias",1,"struct pschars *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("pschars_bias_get",1,SWIGTYPE_p_pschars);
  }
  
  result = (int) ((arg1)->bias);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_pschars(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *result = 0 ;
  
  SWIG_check_num_args("pschars::pschars",0,0)
  result = (struct pschars *)calloc(1, sizeof(struct pschars));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pschars,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_pschars(void *obj) {
struct pschars *arg1 = (struct pschars *) obj;
free((char *) arg1);
}
static swig_lua_method swig_pschars_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_pschars_attributes[] = {
    { "cnt", _wrap_pschars_cnt_get, _wrap_pschars_cnt_set},
    { "next", _wrap_pschars_next_get, _wrap_pschars_next_set},
    { "keys", _wrap_pschars_keys_get, _wrap_pschars_keys_set},
    { "values", _wrap_pschars_values_get, _wrap_pschars_values_set},
    { "lens", _wrap_pschars_lens_get, _wrap_pschars_lens_set},
    { "bias", _wrap_pschars_bias_get, _wrap_pschars_bias_set},
    {0,0,0}
};
static swig_lua_class *swig_pschars_bases[] = {0};
static const char *swig_pschars_base_names[] = {0};
static swig_lua_class _wrap_class_pschars = { "pschars", &SWIGTYPE_p_pschars,_wrap_new_pschars, swig_delete_pschars, swig_pschars_methods, swig_pschars_attributes, swig_pschars_bases, swig_pschars_base_names };

static int _wrap_gradient_start_set(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("gradient::start",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::start",1,"struct gradient *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gradient::start",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_start_set",1,SWIGTYPE_p_gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("gradient_start_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->start = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_start_get(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("gradient::start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::start",1,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_start_get",1,SWIGTYPE_p_gradient);
  }
  
  result = (BasePoint *)& ((arg1)->start);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_stop_set(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("gradient::stop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::stop",1,"struct gradient *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("gradient::stop",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_stop_set",1,SWIGTYPE_p_gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("gradient_stop_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->stop = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_stop_get(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("gradient::stop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::stop",1,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_stop_get",1,SWIGTYPE_p_gradient);
  }
  
  result = (BasePoint *)& ((arg1)->stop);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_radius_set(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gradient::radius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::radius",1,"struct gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gradient::radius",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_radius_set",1,SWIGTYPE_p_gradient);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->radius = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_radius_get(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  float result;
  
  SWIG_check_num_args("gradient::radius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::radius",1,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_radius_get",1,SWIGTYPE_p_gradient);
  }
  
  result = (float) ((arg1)->radius);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_sm_set(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  enum spreadMethod arg2 ;
  
  SWIG_check_num_args("gradient::sm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::sm",1,"struct gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gradient::sm",2,"enum spreadMethod");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_sm_set",1,SWIGTYPE_p_gradient);
  }
  
  arg2 = (enum spreadMethod)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->sm = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_sm_get(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  enum spreadMethod result;
  
  SWIG_check_num_args("gradient::sm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::sm",1,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_sm_get",1,SWIGTYPE_p_gradient);
  }
  
  result = (enum spreadMethod) ((arg1)->sm);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_stop_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("gradient::stop_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::stop_cnt",1,"struct gradient *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gradient::stop_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_stop_cnt_set",1,SWIGTYPE_p_gradient);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->stop_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_stop_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  int result;
  
  SWIG_check_num_args("gradient::stop_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::stop_cnt",1,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_stop_cnt_get",1,SWIGTYPE_p_gradient);
  }
  
  result = (int) ((arg1)->stop_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_grad_stops_get(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  gradient_grad_stops *result = 0 ;
  
  SWIG_check_num_args("gradient::grad_stops",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient::grad_stops",1,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("gradient_grad_stops_get",1,SWIGTYPE_p_gradient);
  }
  
  result = (gradient_grad_stops *) ((arg1)->grad_stops);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gradient_grad_stops,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gradient(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *result = 0 ;
  
  SWIG_check_num_args("gradient::gradient",0,0)
  result = (struct gradient *)calloc(1, sizeof(struct gradient));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gradient,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gradient(void *obj) {
struct gradient *arg1 = (struct gradient *) obj;
free((char *) arg1);
}
static swig_lua_method swig_gradient_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_gradient_attributes[] = {
    { "start", _wrap_gradient_start_get, _wrap_gradient_start_set},
    { "stop", _wrap_gradient_stop_get, _wrap_gradient_stop_set},
    { "radius", _wrap_gradient_radius_get, _wrap_gradient_radius_set},
    { "sm", _wrap_gradient_sm_get, _wrap_gradient_sm_set},
    { "stop_cnt", _wrap_gradient_stop_cnt_get, _wrap_gradient_stop_cnt_set},
    { "grad_stops", _wrap_gradient_grad_stops_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_gradient_bases[] = {0};
static const char *swig_gradient_base_names[] = {0};
static swig_lua_class _wrap_class_gradient = { "gradient", &SWIGTYPE_p_gradient,_wrap_new_gradient, swig_delete_gradient, swig_gradient_methods, swig_gradient_attributes, swig_gradient_bases, swig_gradient_base_names };

static int _wrap_gradient_grad_stops_offset_set(lua_State* L) {
  int SWIG_arg = 0;
  gradient_grad_stops *arg1 = (gradient_grad_stops *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gradient_grad_stops::offset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient_grad_stops::offset",1,"gradient_grad_stops *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gradient_grad_stops::offset",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient_grad_stops,0))){
    SWIG_fail_ptr("gradient_grad_stops_offset_set",1,SWIGTYPE_p_gradient_grad_stops);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->offset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_grad_stops_offset_get(lua_State* L) {
  int SWIG_arg = 0;
  gradient_grad_stops *arg1 = (gradient_grad_stops *) 0 ;
  float result;
  
  SWIG_check_num_args("gradient_grad_stops::offset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient_grad_stops::offset",1,"gradient_grad_stops *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient_grad_stops,0))){
    SWIG_fail_ptr("gradient_grad_stops_offset_get",1,SWIGTYPE_p_gradient_grad_stops);
  }
  
  result = (float) ((arg1)->offset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_grad_stops_col_set(lua_State* L) {
  int SWIG_arg = 0;
  gradient_grad_stops *arg1 = (gradient_grad_stops *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("gradient_grad_stops::col",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient_grad_stops::col",1,"gradient_grad_stops *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gradient_grad_stops::col",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient_grad_stops,0))){
    SWIG_fail_ptr("gradient_grad_stops_col_set",1,SWIGTYPE_p_gradient_grad_stops);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->col = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_grad_stops_col_get(lua_State* L) {
  int SWIG_arg = 0;
  gradient_grad_stops *arg1 = (gradient_grad_stops *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("gradient_grad_stops::col",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient_grad_stops::col",1,"gradient_grad_stops *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient_grad_stops,0))){
    SWIG_fail_ptr("gradient_grad_stops_col_get",1,SWIGTYPE_p_gradient_grad_stops);
  }
  
  result = (uint32) ((arg1)->col);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_grad_stops_opacity_set(lua_State* L) {
  int SWIG_arg = 0;
  gradient_grad_stops *arg1 = (gradient_grad_stops *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("gradient_grad_stops::opacity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient_grad_stops::opacity",1,"gradient_grad_stops *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("gradient_grad_stops::opacity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient_grad_stops,0))){
    SWIG_fail_ptr("gradient_grad_stops_opacity_set",1,SWIGTYPE_p_gradient_grad_stops);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->opacity = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_gradient_grad_stops_opacity_get(lua_State* L) {
  int SWIG_arg = 0;
  gradient_grad_stops *arg1 = (gradient_grad_stops *) 0 ;
  float result;
  
  SWIG_check_num_args("gradient_grad_stops::opacity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("gradient_grad_stops::opacity",1,"gradient_grad_stops *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient_grad_stops,0))){
    SWIG_fail_ptr("gradient_grad_stops_opacity_get",1,SWIGTYPE_p_gradient_grad_stops);
  }
  
  result = (float) ((arg1)->opacity);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_gradient_grad_stops(lua_State* L) {
  int SWIG_arg = 0;
  gradient_grad_stops *result = 0 ;
  
  SWIG_check_num_args("gradient_grad_stops::gradient_grad_stops",0,0)
  result = (gradient_grad_stops *)calloc(1, sizeof(gradient_grad_stops));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gradient_grad_stops,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_gradient_grad_stops(void *obj) {
gradient_grad_stops *arg1 = (gradient_grad_stops *) obj;
free((char *) arg1);
}
static swig_lua_method swig_gradient_grad_stops_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_gradient_grad_stops_attributes[] = {
    { "offset", _wrap_gradient_grad_stops_offset_get, _wrap_gradient_grad_stops_offset_set},
    { "col", _wrap_gradient_grad_stops_col_get, _wrap_gradient_grad_stops_col_set},
    { "opacity", _wrap_gradient_grad_stops_opacity_get, _wrap_gradient_grad_stops_opacity_set},
    {0,0,0}
};
static swig_lua_class *swig_gradient_grad_stops_bases[] = {0};
static const char *swig_gradient_grad_stops_base_names[] = {0};
static swig_lua_class _wrap_class_gradient_grad_stops = { "gradient_grad_stops", &SWIGTYPE_p_gradient_grad_stops,_wrap_new_gradient_grad_stops, swig_delete_gradient_grad_stops, swig_gradient_grad_stops_methods, swig_gradient_grad_stops_attributes, swig_gradient_grad_stops_bases, swig_gradient_grad_stops_base_names };

static int _wrap_pattern_pattern_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("pattern::pattern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::pattern",1,"struct pattern *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("pattern::pattern",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_pattern_set",1,SWIGTYPE_p_pattern);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->pattern);
    if (arg2) {
      arg1->pattern = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->pattern, (const char *)arg2);
    } else {
      arg1->pattern = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_pattern_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("pattern::pattern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::pattern",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_pattern_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (char *) ((arg1)->pattern);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("pattern::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::width",1,"struct pattern *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pattern::width",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_width_set",1,SWIGTYPE_p_pattern);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float result;
  
  SWIG_check_num_args("pattern::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::width",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_width_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (float) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_height_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("pattern::height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::height",1,"struct pattern *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pattern::height",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_height_set",1,SWIGTYPE_p_pattern);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_height_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float result;
  
  SWIG_check_num_args("pattern::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::height",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_height_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (float) ((arg1)->height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_transform_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("pattern::transform",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::transform",1,"struct pattern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pattern::transform",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_transform_set",1,SWIGTYPE_p_pattern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("pattern_transform_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->transform;
    for (ii = 0; ii < (size_t)6; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_transform_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("pattern::transform",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::transform",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_transform_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (float *)(float *) ((arg1)->transform);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_pat_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  struct bdfchar *arg2 = (struct bdfchar *) 0 ;
  
  SWIG_check_num_args("pattern::pat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::pat",1,"struct pattern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pattern::pat",2,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_pat_set",1,SWIGTYPE_p_pattern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("pattern_pat_set",2,SWIGTYPE_p_bdfchar);
  }
  
  if (arg1) (arg1)->pat = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_pat_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  struct bdfchar *result = 0 ;
  
  SWIG_check_num_args("pattern::pat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::pat",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_pat_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (struct bdfchar *) ((arg1)->pat);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_invtrans_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("pattern::invtrans",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::invtrans",1,"struct pattern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pattern::invtrans",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_invtrans_set",1,SWIGTYPE_p_pattern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("pattern_invtrans_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->invtrans;
    for (ii = 0; ii < (size_t)6; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_invtrans_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("pattern::invtrans",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::invtrans",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_invtrans_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (float *)(float *) ((arg1)->invtrans);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bminx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pattern::bminx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bminx",1,"struct pattern *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pattern::bminx",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bminx_set",1,SWIGTYPE_p_pattern);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bminx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bminx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int result;
  
  SWIG_check_num_args("pattern::bminx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bminx",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bminx_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (int) ((arg1)->bminx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bminy_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pattern::bminy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bminy",1,"struct pattern *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pattern::bminy",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bminy_set",1,SWIGTYPE_p_pattern);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bminy = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bminy_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int result;
  
  SWIG_check_num_args("pattern::bminy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bminy",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bminy_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (int) ((arg1)->bminy);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bwidth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pattern::bwidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bwidth",1,"struct pattern *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pattern::bwidth",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bwidth_set",1,SWIGTYPE_p_pattern);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bwidth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bwidth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int result;
  
  SWIG_check_num_args("pattern::bwidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bwidth",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bwidth_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (int) ((arg1)->bwidth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bheight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pattern::bheight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bheight",1,"struct pattern *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pattern::bheight",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bheight_set",1,SWIGTYPE_p_pattern);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bheight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pattern_bheight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  int result;
  
  SWIG_check_num_args("pattern::bheight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pattern::bheight",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("pattern_bheight_get",1,SWIGTYPE_p_pattern);
  }
  
  result = (int) ((arg1)->bheight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_pattern(void *obj) {
struct pattern *arg1 = (struct pattern *) obj;
free((char *) arg1);
}
static swig_lua_method swig_pattern_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_pattern_attributes[] = {
    { "pattern", _wrap_pattern_pattern_get, _wrap_pattern_pattern_set},
    { "width", _wrap_pattern_width_get, _wrap_pattern_width_set},
    { "height", _wrap_pattern_height_get, _wrap_pattern_height_set},
    { "transform", _wrap_pattern_transform_get, _wrap_pattern_transform_set},
    { "pat", _wrap_pattern_pat_get, _wrap_pattern_pat_set},
    { "invtrans", _wrap_pattern_invtrans_get, _wrap_pattern_invtrans_set},
    { "bminx", _wrap_pattern_bminx_get, _wrap_pattern_bminx_set},
    { "bminy", _wrap_pattern_bminy_get, _wrap_pattern_bminy_set},
    { "bwidth", _wrap_pattern_bwidth_get, _wrap_pattern_bwidth_set},
    { "bheight", _wrap_pattern_bheight_get, _wrap_pattern_bheight_set},
    {0,0,0}
};
static swig_lua_class *swig_pattern_bases[] = {0};
static const char *swig_pattern_base_names[] = {0};
static swig_lua_class _wrap_class_pattern = { "pattern", &SWIGTYPE_p_pattern,0, swig_delete_pattern, swig_pattern_methods, swig_pattern_attributes, swig_pattern_bases, swig_pattern_base_names };

static int _wrap_brush_col_set(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("brush::col",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::col",1,"struct brush *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("brush::col",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_col_set",1,SWIGTYPE_p_brush);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->col = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_brush_col_get(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("brush::col",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::col",1,"struct brush *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_col_get",1,SWIGTYPE_p_brush);
  }
  
  result = (uint32) ((arg1)->col);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_brush_opacity_set(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("brush::opacity",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::opacity",1,"struct brush *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("brush::opacity",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_opacity_set",1,SWIGTYPE_p_brush);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->opacity = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_brush_opacity_get(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  float result;
  
  SWIG_check_num_args("brush::opacity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::opacity",1,"struct brush *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_opacity_get",1,SWIGTYPE_p_brush);
  }
  
  result = (float) ((arg1)->opacity);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_brush_pattern_set(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  struct pattern *arg2 = (struct pattern *) 0 ;
  
  SWIG_check_num_args("brush::pattern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::pattern",1,"struct brush *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("brush::pattern",2,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_pattern_set",1,SWIGTYPE_p_brush);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_pattern,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("brush_pattern_set",2,SWIGTYPE_p_pattern);
  }
  
  if (arg1) (arg1)->pattern = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_brush_pattern_get(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  struct pattern *result = 0 ;
  
  SWIG_check_num_args("brush::pattern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::pattern",1,"struct brush *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_pattern_get",1,SWIGTYPE_p_brush);
  }
  
  result = (struct pattern *) ((arg1)->pattern);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pattern,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_brush_gradient_set(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  struct gradient *arg2 = (struct gradient *) 0 ;
  
  SWIG_check_num_args("brush::gradient",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::gradient",1,"struct brush *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("brush::gradient",2,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_gradient_set",1,SWIGTYPE_p_brush);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gradient,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("brush_gradient_set",2,SWIGTYPE_p_gradient);
  }
  
  if (arg1) (arg1)->gradient = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_brush_gradient_get(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  struct gradient *result = 0 ;
  
  SWIG_check_num_args("brush::gradient",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("brush::gradient",1,"struct brush *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("brush_gradient_get",1,SWIGTYPE_p_brush);
  }
  
  result = (struct gradient *) ((arg1)->gradient);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_brush(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *result = 0 ;
  
  SWIG_check_num_args("brush::brush",0,0)
  result = (struct brush *)calloc(1, sizeof(struct brush));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_brush,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_brush(void *obj) {
struct brush *arg1 = (struct brush *) obj;
free((char *) arg1);
}
static swig_lua_method swig_brush_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_brush_attributes[] = {
    { "col", _wrap_brush_col_get, _wrap_brush_col_set},
    { "opacity", _wrap_brush_opacity_get, _wrap_brush_opacity_set},
    { "pattern", _wrap_brush_pattern_get, _wrap_brush_pattern_set},
    { "gradient", _wrap_brush_gradient_get, _wrap_brush_gradient_set},
    {0,0,0}
};
static swig_lua_class *swig_brush_bases[] = {0};
static const char *swig_brush_base_names[] = {0};
static swig_lua_class _wrap_class_brush = { "brush", &SWIGTYPE_p_brush,_wrap_new_brush, swig_delete_brush, swig_brush_methods, swig_brush_attributes, swig_brush_bases, swig_brush_base_names };

static int _wrap_pen_brush_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  struct brush *arg2 = (struct brush *) 0 ;
  
  SWIG_check_num_args("pen::brush",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::brush",1,"struct pen *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pen::brush",2,"struct brush *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_brush_set",1,SWIGTYPE_p_pen);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("pen_brush_set",2,SWIGTYPE_p_brush);
  }
  
  if (arg1) (arg1)->brush = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_brush_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  struct brush *result = 0 ;
  
  SWIG_check_num_args("pen::brush",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::brush",1,"struct pen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_brush_get",1,SWIGTYPE_p_pen);
  }
  
  result = (struct brush *)& ((arg1)->brush);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_brush,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_linejoin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("pen::linejoin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::linejoin",1,"struct pen *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pen::linejoin",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_linejoin_set",1,SWIGTYPE_p_pen);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->linejoin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_linejoin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("pen::linejoin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::linejoin",1,"struct pen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_linejoin_get",1,SWIGTYPE_p_pen);
  }
  
  result = (uint8) ((arg1)->linejoin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_linecap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("pen::linecap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::linecap",1,"struct pen *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pen::linecap",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_linecap_set",1,SWIGTYPE_p_pen);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->linecap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_linecap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("pen::linecap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::linecap",1,"struct pen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_linecap_get",1,SWIGTYPE_p_pen);
  }
  
  result = (uint8) ((arg1)->linecap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("pen::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::width",1,"struct pen *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pen::width",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_width_set",1,SWIGTYPE_p_pen);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  float result;
  
  SWIG_check_num_args("pen::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::width",1,"struct pen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_width_get",1,SWIGTYPE_p_pen);
  }
  
  result = (float) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_trans_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("pen::trans",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::trans",1,"struct pen *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pen::trans",2,"float [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_trans_set",1,SWIGTYPE_p_pen);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("pen_trans_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->trans;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_trans_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("pen::trans",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::trans",1,"struct pen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_trans_get",1,SWIGTYPE_p_pen);
  }
  
  result = (float *)(float *) ((arg1)->trans);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_dashes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  DashType *arg2 ;
  
  SWIG_check_num_args("pen::dashes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::dashes",1,"struct pen *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pen::dashes",2,"DashType [8]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_dashes_set",1,SWIGTYPE_p_pen);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("pen_dashes_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  {
    size_t ii;
    DashType *b = (DashType *) arg1->dashes;
    for (ii = 0; ii < (size_t)8; ii++) b[ii] = *((DashType *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pen_dashes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  DashType *result = 0 ;
  
  SWIG_check_num_args("pen::dashes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pen::dashes",1,"struct pen *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("pen_dashes_get",1,SWIGTYPE_p_pen);
  }
  
  result = (DashType *)(DashType *) ((arg1)->dashes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_pen(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *result = 0 ;
  
  SWIG_check_num_args("pen::pen",0,0)
  result = (struct pen *)calloc(1, sizeof(struct pen));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pen,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_pen(void *obj) {
struct pen *arg1 = (struct pen *) obj;
free((char *) arg1);
}
static swig_lua_method swig_pen_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_pen_attributes[] = {
    { "brush", _wrap_pen_brush_get, _wrap_pen_brush_set},
    { "linejoin", _wrap_pen_linejoin_get, _wrap_pen_linejoin_set},
    { "linecap", _wrap_pen_linecap_get, _wrap_pen_linecap_set},
    { "width", _wrap_pen_width_get, _wrap_pen_width_set},
    { "trans", _wrap_pen_trans_get, _wrap_pen_trans_set},
    { "dashes", _wrap_pen_dashes_get, _wrap_pen_dashes_set},
    {0,0,0}
};
static swig_lua_class *swig_pen_bases[] = {0};
static const char *swig_pen_base_names[] = {0};
static swig_lua_class _wrap_class_pen = { "pen", &SWIGTYPE_p_pen,_wrap_new_pen, swig_delete_pen, swig_pen_methods, swig_pen_attributes, swig_pen_bases, swig_pen_base_names };

static int _wrap_StrokeInfo_radius_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("strokeinfo::radius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::radius",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::radius",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_radius_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->radius = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_radius_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float result;
  
  SWIG_check_num_args("strokeinfo::radius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::radius",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_radius_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (float) ((arg1)->radius);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_join_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  enum linejoin arg2 ;
  
  SWIG_check_num_args("strokeinfo::join",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::join",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::join",2,"enum linejoin");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_join_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (enum linejoin)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->join = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_join_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  enum linejoin result;
  
  SWIG_check_num_args("strokeinfo::join",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::join",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_join_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (enum linejoin) ((arg1)->join);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_cap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  enum linecap arg2 ;
  
  SWIG_check_num_args("strokeinfo::cap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::cap",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::cap",2,"enum linecap");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_cap_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (enum linecap)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_cap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  enum linecap result;
  
  SWIG_check_num_args("strokeinfo::cap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::cap",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_cap_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (enum linecap) ((arg1)->cap);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_stroke_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  enum si_type arg2 ;
  
  SWIG_check_num_args("strokeinfo::stroke_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::stroke_type",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::stroke_type",2,"enum si_type");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_stroke_type_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (enum si_type)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->stroke_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_stroke_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  enum si_type result;
  
  SWIG_check_num_args("strokeinfo::stroke_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::stroke_type",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_stroke_type_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (enum si_type) ((arg1)->stroke_type);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_removeinternal_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("strokeinfo::removeinternal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::removeinternal",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::removeinternal",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_removeinternal_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->removeinternal = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_removeinternal_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("strokeinfo::removeinternal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::removeinternal",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_removeinternal_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (unsigned int) ((arg1)->removeinternal);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_removeexternal_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("strokeinfo::removeexternal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::removeexternal",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::removeexternal",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_removeexternal_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->removeexternal = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_removeexternal_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("strokeinfo::removeexternal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::removeexternal",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_removeexternal_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (unsigned int) ((arg1)->removeexternal);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_leave_users_center_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("strokeinfo::leave_users_center",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::leave_users_center",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::leave_users_center",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_leave_users_center_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->leave_users_center = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_leave_users_center_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("strokeinfo::leave_users_center",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::leave_users_center",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_leave_users_center_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (unsigned int) ((arg1)->leave_users_center);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_penangle_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("strokeinfo::penangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::penangle",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::penangle",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_penangle_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->penangle = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_penangle_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float result;
  
  SWIG_check_num_args("strokeinfo::penangle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::penangle",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_penangle_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (float) ((arg1)->penangle);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_minorradius_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("strokeinfo::minorradius",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::minorradius",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::minorradius",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_minorradius_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->minorradius = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_minorradius_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float result;
  
  SWIG_check_num_args("strokeinfo::minorradius",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::minorradius",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_minorradius_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (float) ((arg1)->minorradius);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_poly_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  struct splinepointlist *arg2 = (struct splinepointlist *) 0 ;
  
  SWIG_check_num_args("strokeinfo::poly",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::poly",1,"struct strokeinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("strokeinfo::poly",2,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_poly_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("StrokeInfo_poly_set",2,SWIGTYPE_p_splinepointlist);
  }
  
  if (arg1) (arg1)->poly = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_poly_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  struct splinepointlist *result = 0 ;
  
  SWIG_check_num_args("strokeinfo::poly",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::poly",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_poly_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (struct splinepointlist *) ((arg1)->poly);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_resolution_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("strokeinfo::resolution",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::resolution",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::resolution",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_resolution_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->resolution = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_resolution_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float result;
  
  SWIG_check_num_args("strokeinfo::resolution",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::resolution",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_resolution_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (float) ((arg1)->resolution);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_radius2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("strokeinfo::radius2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::radius2",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::radius2",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_radius2_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->radius2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_radius2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  float result;
  
  SWIG_check_num_args("strokeinfo::radius2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::radius2",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_radius2_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (float) ((arg1)->radius2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_pressure1_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("strokeinfo::pressure1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::pressure1",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::pressure1",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_pressure1_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pressure1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_pressure1_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("strokeinfo::pressure1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::pressure1",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_pressure1_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (int) ((arg1)->pressure1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_pressure2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("strokeinfo::pressure2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::pressure2",1,"struct strokeinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("strokeinfo::pressure2",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_pressure2_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pressure2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_pressure2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("strokeinfo::pressure2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::pressure2",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_pressure2_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (int) ((arg1)->pressure2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_data_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("strokeinfo::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::data",1,"struct strokeinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("strokeinfo::data",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_data_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"StrokeInfo_data_set");
  if (arg1) (arg1)->data = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_data_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("strokeinfo::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::data",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_data_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (void *) ((arg1)->data);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_factor_set(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  double (*arg2)(void *,struct spline *,float) = (double (*)(void *,struct spline *,float)) 0 ;
  
  SWIG_check_num_args("strokeinfo::factor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::factor",1,"struct strokeinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("strokeinfo::factor",2,"double (*)(void *,struct spline *,float)");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_factor_set",1,SWIGTYPE_p_strokeinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_p_void_p_struct_spline_float__double,0))){
    SWIG_fail_ptr("StrokeInfo_factor_set",2,SWIGTYPE_p_f_p_void_p_struct_spline_float__double);
  }
  
  if (arg1) (arg1)->factor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StrokeInfo_factor_get(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *arg1 = (struct strokeinfo *) 0 ;
  double (*result)(void *,struct spline *,float) = 0 ;
  
  SWIG_check_num_args("strokeinfo::factor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("strokeinfo::factor",1,"struct strokeinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("StrokeInfo_factor_get",1,SWIGTYPE_p_strokeinfo);
  }
  
  result = (double (*)(void *,struct spline *,float)) ((arg1)->factor);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_f_p_void_p_struct_spline_float__double,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_StrokeInfo(lua_State* L) {
  int SWIG_arg = 0;
  struct strokeinfo *result = 0 ;
  
  SWIG_check_num_args("strokeinfo::strokeinfo",0,0)
  result = (struct strokeinfo *)calloc(1, sizeof(struct strokeinfo));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_strokeinfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_StrokeInfo(void *obj) {
struct strokeinfo *arg1 = (struct strokeinfo *) obj;
free((char *) arg1);
}
static swig_lua_method swig_strokeinfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_strokeinfo_attributes[] = {
    { "radius", _wrap_StrokeInfo_radius_get, _wrap_StrokeInfo_radius_set},
    { "join", _wrap_StrokeInfo_join_get, _wrap_StrokeInfo_join_set},
    { "cap", _wrap_StrokeInfo_cap_get, _wrap_StrokeInfo_cap_set},
    { "stroke_type", _wrap_StrokeInfo_stroke_type_get, _wrap_StrokeInfo_stroke_type_set},
    { "removeinternal", _wrap_StrokeInfo_removeinternal_get, _wrap_StrokeInfo_removeinternal_set},
    { "removeexternal", _wrap_StrokeInfo_removeexternal_get, _wrap_StrokeInfo_removeexternal_set},
    { "leave_users_center", _wrap_StrokeInfo_leave_users_center_get, _wrap_StrokeInfo_leave_users_center_set},
    { "penangle", _wrap_StrokeInfo_penangle_get, _wrap_StrokeInfo_penangle_set},
    { "minorradius", _wrap_StrokeInfo_minorradius_get, _wrap_StrokeInfo_minorradius_set},
    { "poly", _wrap_StrokeInfo_poly_get, _wrap_StrokeInfo_poly_set},
    { "resolution", _wrap_StrokeInfo_resolution_get, _wrap_StrokeInfo_resolution_set},
    { "radius2", _wrap_StrokeInfo_radius2_get, _wrap_StrokeInfo_radius2_set},
    { "pressure1", _wrap_StrokeInfo_pressure1_get, _wrap_StrokeInfo_pressure1_set},
    { "pressure2", _wrap_StrokeInfo_pressure2_get, _wrap_StrokeInfo_pressure2_set},
    { "data", _wrap_StrokeInfo_data_get, _wrap_StrokeInfo_data_set},
    { "factor", _wrap_StrokeInfo_factor_get, _wrap_StrokeInfo_factor_set},
    {0,0,0}
};
static swig_lua_class *swig_strokeinfo_bases[] = {0};
static const char *swig_strokeinfo_base_names[] = {0};
static swig_lua_class _wrap_class_strokeinfo = { "StrokeInfo", &SWIGTYPE_p_strokeinfo,_wrap_new_StrokeInfo, swig_delete_StrokeInfo, swig_strokeinfo_methods, swig_strokeinfo_attributes, swig_strokeinfo_bases, swig_strokeinfo_base_names };

static int _wrap_simplifyinfo_flags_set(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("simplifyinfo::flags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::flags",1,"struct simplifyinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("simplifyinfo::flags",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_flags_set",1,SWIGTYPE_p_simplifyinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->flags = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_flags_get(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("simplifyinfo::flags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::flags",1,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_flags_get",1,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (int) ((arg1)->flags);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_err_set(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("simplifyinfo::err",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::err",1,"struct simplifyinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("simplifyinfo::err",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_err_set",1,SWIGTYPE_p_simplifyinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->err = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_err_get(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("simplifyinfo::err",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::err",1,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_err_get",1,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (double) ((arg1)->err);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_tan_bounds_set(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("simplifyinfo::tan_bounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::tan_bounds",1,"struct simplifyinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("simplifyinfo::tan_bounds",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_tan_bounds_set",1,SWIGTYPE_p_simplifyinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->tan_bounds = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_tan_bounds_get(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("simplifyinfo::tan_bounds",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::tan_bounds",1,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_tan_bounds_get",1,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (double) ((arg1)->tan_bounds);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_linefixup_set(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("simplifyinfo::linefixup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::linefixup",1,"struct simplifyinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("simplifyinfo::linefixup",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_linefixup_set",1,SWIGTYPE_p_simplifyinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->linefixup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_linefixup_get(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("simplifyinfo::linefixup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::linefixup",1,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_linefixup_get",1,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (double) ((arg1)->linefixup);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_linelenmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("simplifyinfo::linelenmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::linelenmax",1,"struct simplifyinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("simplifyinfo::linelenmax",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_linelenmax_set",1,SWIGTYPE_p_simplifyinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->linelenmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_linelenmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("simplifyinfo::linelenmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::linelenmax",1,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_linelenmax_get",1,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (double) ((arg1)->linelenmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_set_as_default_set(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("simplifyinfo::set_as_default",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::set_as_default",1,"struct simplifyinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("simplifyinfo::set_as_default",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_set_as_default_set",1,SWIGTYPE_p_simplifyinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->set_as_default = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_set_as_default_get(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("simplifyinfo::set_as_default",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::set_as_default",1,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_set_as_default_get",1,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (int) ((arg1)->set_as_default);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_check_selected_contours_set(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("simplifyinfo::check_selected_contours",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::check_selected_contours",1,"struct simplifyinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("simplifyinfo::check_selected_contours",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_check_selected_contours_set",1,SWIGTYPE_p_simplifyinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->check_selected_contours = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_simplifyinfo_check_selected_contours_get(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *arg1 = (struct simplifyinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("simplifyinfo::check_selected_contours",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("simplifyinfo::check_selected_contours",1,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("simplifyinfo_check_selected_contours_get",1,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (int) ((arg1)->check_selected_contours);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_simplifyinfo(lua_State* L) {
  int SWIG_arg = 0;
  struct simplifyinfo *result = 0 ;
  
  SWIG_check_num_args("simplifyinfo::simplifyinfo",0,0)
  result = (struct simplifyinfo *)calloc(1, sizeof(struct simplifyinfo));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_simplifyinfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_simplifyinfo(void *obj) {
struct simplifyinfo *arg1 = (struct simplifyinfo *) obj;
free((char *) arg1);
}
static swig_lua_method swig_simplifyinfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_simplifyinfo_attributes[] = {
    { "flags", _wrap_simplifyinfo_flags_get, _wrap_simplifyinfo_flags_set},
    { "err", _wrap_simplifyinfo_err_get, _wrap_simplifyinfo_err_set},
    { "tan_bounds", _wrap_simplifyinfo_tan_bounds_get, _wrap_simplifyinfo_tan_bounds_set},
    { "linefixup", _wrap_simplifyinfo_linefixup_get, _wrap_simplifyinfo_linefixup_set},
    { "linelenmax", _wrap_simplifyinfo_linelenmax_get, _wrap_simplifyinfo_linelenmax_set},
    { "set_as_default", _wrap_simplifyinfo_set_as_default_get, _wrap_simplifyinfo_set_as_default_set},
    { "check_selected_contours", _wrap_simplifyinfo_check_selected_contours_get, _wrap_simplifyinfo_check_selected_contours_set},
    {0,0,0}
};
static swig_lua_class *swig_simplifyinfo_bases[] = {0};
static const char *swig_simplifyinfo_base_names[] = {0};
static swig_lua_class _wrap_class_simplifyinfo = { "simplifyinfo", &SWIGTYPE_p_simplifyinfo,_wrap_new_simplifyinfo, swig_delete_simplifyinfo, swig_simplifyinfo_methods, swig_simplifyinfo_attributes, swig_simplifyinfo_bases, swig_simplifyinfo_base_names };

static int _wrap_ItalicInfo_italic_angle_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::italic_angle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::italic_angle",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::italic_angle",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_italic_angle_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->italic_angle = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_italic_angle_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::italic_angle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::italic_angle",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_italic_angle_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->italic_angle);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_xheight_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::xheight_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::xheight_percent",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::xheight_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_xheight_percent_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->xheight_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_xheight_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::xheight_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::xheight_percent",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_xheight_percent_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->xheight_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_secondary_serif_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("italicinfo::secondary_serif",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::secondary_serif",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::secondary_serif",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_secondary_serif_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1 && sizeof(int) == sizeof((arg1)->secondary_serif)) *(int*)(void*)&((arg1)->secondary_serif) = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_secondary_serif_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("italicinfo::secondary_serif",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::secondary_serif",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_secondary_serif_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (int) ((arg1)->secondary_serif);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_bottom_serifs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::transform_bottom_serifs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_bottom_serifs",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::transform_bottom_serifs",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_bottom_serifs_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->transform_bottom_serifs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_bottom_serifs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::transform_bottom_serifs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_bottom_serifs",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_bottom_serifs_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->transform_bottom_serifs);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_top_xh_serifs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::transform_top_xh_serifs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_top_xh_serifs",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::transform_top_xh_serifs",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_top_xh_serifs_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->transform_top_xh_serifs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_top_xh_serifs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::transform_top_xh_serifs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_top_xh_serifs",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_top_xh_serifs_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->transform_top_xh_serifs);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_top_as_serifs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::transform_top_as_serifs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_top_as_serifs",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::transform_top_as_serifs",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_top_as_serifs_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->transform_top_as_serifs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_top_as_serifs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::transform_top_as_serifs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_top_as_serifs",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_top_as_serifs_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->transform_top_as_serifs);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_diagon_serifs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::transform_diagon_serifs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_diagon_serifs",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::transform_diagon_serifs",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_diagon_serifs_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->transform_diagon_serifs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_transform_diagon_serifs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::transform_diagon_serifs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::transform_diagon_serifs",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_transform_diagon_serifs_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->transform_diagon_serifs);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_a_from_d_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::a_from_d",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::a_from_d",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::a_from_d",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_a_from_d_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->a_from_d = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_a_from_d_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::a_from_d",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::a_from_d",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_a_from_d_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->a_from_d);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_long_tail_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::f_long_tail",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_long_tail",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::f_long_tail",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_long_tail_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->f_long_tail = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_long_tail_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::f_long_tail",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_long_tail",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_long_tail_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->f_long_tail);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_rotate_top_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::f_rotate_top",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_rotate_top",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::f_rotate_top",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_rotate_top_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->f_rotate_top = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_rotate_top_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::f_rotate_top",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_rotate_top",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_rotate_top_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->f_rotate_top);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_pq_deserif_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::pq_deserif",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::pq_deserif",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::pq_deserif",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_pq_deserif_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pq_deserif = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_pq_deserif_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::pq_deserif",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::pq_deserif",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_pq_deserif_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->pq_deserif);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_phi_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::cyrl_phi",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_phi",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::cyrl_phi",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_phi_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cyrl_phi = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_phi_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::cyrl_phi",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_phi",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_phi_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->cyrl_phi);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_i_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::cyrl_i",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_i",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::cyrl_i",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_i_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cyrl_i = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_i_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::cyrl_i",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_i",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_i_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->cyrl_i);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_pi_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::cyrl_pi",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_pi",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::cyrl_pi",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_pi_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cyrl_pi = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_pi_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::cyrl_pi",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_pi",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_pi_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->cyrl_pi);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_te_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::cyrl_te",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_te",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::cyrl_te",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_te_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cyrl_te = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_te_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::cyrl_te",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_te",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_te_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->cyrl_te);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_sha_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::cyrl_sha",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_sha",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::cyrl_sha",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_sha_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cyrl_sha = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_sha_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::cyrl_sha",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_sha",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_sha_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->cyrl_sha);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_dje_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::cyrl_dje",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_dje",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::cyrl_dje",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_dje_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cyrl_dje = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_dje_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::cyrl_dje",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_dje",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_dje_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->cyrl_dje);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_dzhe_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("italicinfo::cyrl_dzhe",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_dzhe",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::cyrl_dzhe",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_dzhe_set",1,SWIGTYPE_p_italicinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cyrl_dzhe = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_cyrl_dzhe_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("italicinfo::cyrl_dzhe",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::cyrl_dzhe",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_cyrl_dzhe_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (unsigned int) ((arg1)->cyrl_dzhe);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_tan_ia_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::tan_ia",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::tan_ia",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::tan_ia",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_tan_ia_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->tan_ia = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_tan_ia_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::tan_ia",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::tan_ia",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_tan_ia_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->tan_ia);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_x_height_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::x_height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::x_height",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::x_height",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_x_height_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->x_height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_x_height_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::x_height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::x_height",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_x_height_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->x_height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_pq_depth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::pq_depth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::pq_depth",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::pq_depth",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_pq_depth_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->pq_depth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_pq_depth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::pq_depth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::pq_depth",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_pq_depth_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->pq_depth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ascender_height_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::ascender_height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ascender_height",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::ascender_height",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ascender_height_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->ascender_height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ascender_height_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::ascender_height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ascender_height",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ascender_height_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->ascender_height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_emsize_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::emsize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::emsize",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::emsize",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_emsize_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->emsize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_emsize_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::emsize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::emsize",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_emsize_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->emsize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_order2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("italicinfo::order2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::order2",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::order2",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_order2_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->order2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_order2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("italicinfo::order2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::order2",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_order2_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (int) ((arg1)->order2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_sf_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinefont *arg2 = (struct splinefont *) 0 ;
  
  SWIG_check_num_args("italicinfo::sf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::sf",1,"struct italicinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("italicinfo::sf",2,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_sf_set",1,SWIGTYPE_p_italicinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ItalicInfo_sf_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->sf = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_sf_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinefont *result = 0 ;
  
  SWIG_check_num_args("italicinfo::sf",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::sf",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_sf_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (struct splinefont *) ((arg1)->sf);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_layer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("italicinfo::layer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::layer",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::layer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_layer_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->layer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_layer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  int result;
  
  SWIG_check_num_args("italicinfo::layer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::layer",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_layer_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (int) ((arg1)->layer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_serif_extent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::serif_extent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::serif_extent",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::serif_extent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_serif_extent_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->serif_extent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_serif_extent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::serif_extent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::serif_extent",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_serif_extent_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->serif_extent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_serif_height_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::serif_height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::serif_height",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::serif_height",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_serif_height_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->serif_height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_serif_height_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::serif_height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::serif_height",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_serif_height_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->serif_height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_start_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *arg2 = (struct splinepoint *) 0 ;
  
  SWIG_check_num_args("italicinfo::f_start",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_start",1,"struct italicinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("italicinfo::f_start",2,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_start_set",1,SWIGTYPE_p_italicinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ItalicInfo_f_start_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->f_start = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_start_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *result = 0 ;
  
  SWIG_check_num_args("italicinfo::f_start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_start",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_start_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (struct splinepoint *) ((arg1)->f_start);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_end_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *arg2 = (struct splinepoint *) 0 ;
  
  SWIG_check_num_args("italicinfo::f_end",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_end",1,"struct italicinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("italicinfo::f_end",2,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_end_set",1,SWIGTYPE_p_italicinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ItalicInfo_f_end_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->f_end = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_end_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *result = 0 ;
  
  SWIG_check_num_args("italicinfo::f_end",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_end",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_end_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (struct splinepoint *) ((arg1)->f_end);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_start1_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *arg2 = (struct splinepoint *) 0 ;
  
  SWIG_check_num_args("italicinfo::ff_start1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_start1",1,"struct italicinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("italicinfo::ff_start1",2,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_start1_set",1,SWIGTYPE_p_italicinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ItalicInfo_ff_start1_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->ff_start1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_start1_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *result = 0 ;
  
  SWIG_check_num_args("italicinfo::ff_start1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_start1",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_start1_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (struct splinepoint *) ((arg1)->ff_start1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_end1_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *arg2 = (struct splinepoint *) 0 ;
  
  SWIG_check_num_args("italicinfo::ff_end1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_end1",1,"struct italicinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("italicinfo::ff_end1",2,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_end1_set",1,SWIGTYPE_p_italicinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ItalicInfo_ff_end1_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->ff_end1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_end1_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *result = 0 ;
  
  SWIG_check_num_args("italicinfo::ff_end1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_end1",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_end1_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (struct splinepoint *) ((arg1)->ff_end1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_start2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *arg2 = (struct splinepoint *) 0 ;
  
  SWIG_check_num_args("italicinfo::ff_start2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_start2",1,"struct italicinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("italicinfo::ff_start2",2,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_start2_set",1,SWIGTYPE_p_italicinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ItalicInfo_ff_start2_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->ff_start2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_start2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *result = 0 ;
  
  SWIG_check_num_args("italicinfo::ff_start2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_start2",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_start2_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (struct splinepoint *) ((arg1)->ff_start2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_end2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *arg2 = (struct splinepoint *) 0 ;
  
  SWIG_check_num_args("italicinfo::ff_end2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_end2",1,"struct italicinfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("italicinfo::ff_end2",2,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_end2_set",1,SWIGTYPE_p_italicinfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ItalicInfo_ff_end2_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->ff_end2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_end2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  struct splinepoint *result = 0 ;
  
  SWIG_check_num_args("italicinfo::ff_end2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_end2",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_end2_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (struct splinepoint *) ((arg1)->ff_end2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_height_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::f_height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_height",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::f_height",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_height_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->f_height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_f_height_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::f_height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::f_height",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_f_height_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->f_height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_height_set(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("italicinfo::ff_height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_height",1,"struct italicinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("italicinfo::ff_height",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_height_set",1,SWIGTYPE_p_italicinfo);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->ff_height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_ff_height_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  double result;
  
  SWIG_check_num_args("italicinfo::ff_height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::ff_height",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_ff_height_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (double) ((arg1)->ff_height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  ItalicInfo_lc *result = 0 ;
  
  SWIG_check_num_args("italicinfo::lc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::lc",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_lc_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (ItalicInfo_lc *)& ((arg1)->lc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ItalicInfo_lc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  ItalicInfo_uc *result = 0 ;
  
  SWIG_check_num_args("italicinfo::uc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::uc",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_uc_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (ItalicInfo_uc *)& ((arg1)->uc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ItalicInfo_uc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_get(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *arg1 = (struct italicinfo *) 0 ;
  ItalicInfo_neither *result = 0 ;
  
  SWIG_check_num_args("italicinfo::neither",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("italicinfo::neither",1,"struct italicinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_italicinfo,0))){
    SWIG_fail_ptr("ItalicInfo_neither_get",1,SWIGTYPE_p_italicinfo);
  }
  
  result = (ItalicInfo_neither *)& ((arg1)->neither);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ItalicInfo_neither,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ItalicInfo(lua_State* L) {
  int SWIG_arg = 0;
  struct italicinfo *result = 0 ;
  
  SWIG_check_num_args("italicinfo::italicinfo",0,0)
  result = (struct italicinfo *)calloc(1, sizeof(struct italicinfo));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_italicinfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ItalicInfo(void *obj) {
struct italicinfo *arg1 = (struct italicinfo *) obj;
free((char *) arg1);
}
static swig_lua_method swig_italicinfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_italicinfo_attributes[] = {
    { "italic_angle", _wrap_ItalicInfo_italic_angle_get, _wrap_ItalicInfo_italic_angle_set},
    { "xheight_percent", _wrap_ItalicInfo_xheight_percent_get, _wrap_ItalicInfo_xheight_percent_set},
    { "secondary_serif", _wrap_ItalicInfo_secondary_serif_get, _wrap_ItalicInfo_secondary_serif_set},
    { "transform_bottom_serifs", _wrap_ItalicInfo_transform_bottom_serifs_get, _wrap_ItalicInfo_transform_bottom_serifs_set},
    { "transform_top_xh_serifs", _wrap_ItalicInfo_transform_top_xh_serifs_get, _wrap_ItalicInfo_transform_top_xh_serifs_set},
    { "transform_top_as_serifs", _wrap_ItalicInfo_transform_top_as_serifs_get, _wrap_ItalicInfo_transform_top_as_serifs_set},
    { "transform_diagon_serifs", _wrap_ItalicInfo_transform_diagon_serifs_get, _wrap_ItalicInfo_transform_diagon_serifs_set},
    { "a_from_d", _wrap_ItalicInfo_a_from_d_get, _wrap_ItalicInfo_a_from_d_set},
    { "f_long_tail", _wrap_ItalicInfo_f_long_tail_get, _wrap_ItalicInfo_f_long_tail_set},
    { "f_rotate_top", _wrap_ItalicInfo_f_rotate_top_get, _wrap_ItalicInfo_f_rotate_top_set},
    { "pq_deserif", _wrap_ItalicInfo_pq_deserif_get, _wrap_ItalicInfo_pq_deserif_set},
    { "cyrl_phi", _wrap_ItalicInfo_cyrl_phi_get, _wrap_ItalicInfo_cyrl_phi_set},
    { "cyrl_i", _wrap_ItalicInfo_cyrl_i_get, _wrap_ItalicInfo_cyrl_i_set},
    { "cyrl_pi", _wrap_ItalicInfo_cyrl_pi_get, _wrap_ItalicInfo_cyrl_pi_set},
    { "cyrl_te", _wrap_ItalicInfo_cyrl_te_get, _wrap_ItalicInfo_cyrl_te_set},
    { "cyrl_sha", _wrap_ItalicInfo_cyrl_sha_get, _wrap_ItalicInfo_cyrl_sha_set},
    { "cyrl_dje", _wrap_ItalicInfo_cyrl_dje_get, _wrap_ItalicInfo_cyrl_dje_set},
    { "cyrl_dzhe", _wrap_ItalicInfo_cyrl_dzhe_get, _wrap_ItalicInfo_cyrl_dzhe_set},
    { "tan_ia", _wrap_ItalicInfo_tan_ia_get, _wrap_ItalicInfo_tan_ia_set},
    { "x_height", _wrap_ItalicInfo_x_height_get, _wrap_ItalicInfo_x_height_set},
    { "pq_depth", _wrap_ItalicInfo_pq_depth_get, _wrap_ItalicInfo_pq_depth_set},
    { "ascender_height", _wrap_ItalicInfo_ascender_height_get, _wrap_ItalicInfo_ascender_height_set},
    { "emsize", _wrap_ItalicInfo_emsize_get, _wrap_ItalicInfo_emsize_set},
    { "order2", _wrap_ItalicInfo_order2_get, _wrap_ItalicInfo_order2_set},
    { "sf", _wrap_ItalicInfo_sf_get, _wrap_ItalicInfo_sf_set},
    { "layer", _wrap_ItalicInfo_layer_get, _wrap_ItalicInfo_layer_set},
    { "serif_extent", _wrap_ItalicInfo_serif_extent_get, _wrap_ItalicInfo_serif_extent_set},
    { "serif_height", _wrap_ItalicInfo_serif_height_get, _wrap_ItalicInfo_serif_height_set},
    { "f_start", _wrap_ItalicInfo_f_start_get, _wrap_ItalicInfo_f_start_set},
    { "f_end", _wrap_ItalicInfo_f_end_get, _wrap_ItalicInfo_f_end_set},
    { "ff_start1", _wrap_ItalicInfo_ff_start1_get, _wrap_ItalicInfo_ff_start1_set},
    { "ff_end1", _wrap_ItalicInfo_ff_end1_get, _wrap_ItalicInfo_ff_end1_set},
    { "ff_start2", _wrap_ItalicInfo_ff_start2_get, _wrap_ItalicInfo_ff_start2_set},
    { "ff_end2", _wrap_ItalicInfo_ff_end2_get, _wrap_ItalicInfo_ff_end2_set},
    { "f_height", _wrap_ItalicInfo_f_height_get, _wrap_ItalicInfo_f_height_set},
    { "ff_height", _wrap_ItalicInfo_ff_height_get, _wrap_ItalicInfo_ff_height_set},
    { "lc", _wrap_ItalicInfo_lc_get, SWIG_Lua_set_immutable},
    { "uc", _wrap_ItalicInfo_uc_get, SWIG_Lua_set_immutable},
    { "neither", _wrap_ItalicInfo_neither_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_italicinfo_bases[] = {0};
static const char *swig_italicinfo_base_names[] = {0};
static swig_lua_class _wrap_class_italicinfo = { "ItalicInfo", &SWIGTYPE_p_italicinfo,_wrap_new_ItalicInfo, swig_delete_ItalicInfo, swig_italicinfo_methods, swig_italicinfo_attributes, swig_italicinfo_bases, swig_italicinfo_base_names };

static int _wrap_ItalicInfo_neither_lsb_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_neither::lsb_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::lsb_percent",1,"ItalicInfo_neither *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_neither::lsb_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_lsb_percent_set",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->lsb_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_lsb_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_neither::lsb_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::lsb_percent",1,"ItalicInfo_neither *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_lsb_percent_get",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  result = (double) ((arg1)->lsb_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_stem_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_neither::stem_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::stem_percent",1,"ItalicInfo_neither *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_neither::stem_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_stem_percent_set",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->stem_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_stem_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_neither::stem_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::stem_percent",1,"ItalicInfo_neither *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_stem_percent_get",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  result = (double) ((arg1)->stem_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_counter_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_neither::counter_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::counter_percent",1,"ItalicInfo_neither *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_neither::counter_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_counter_percent_set",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->counter_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_counter_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_neither::counter_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::counter_percent",1,"ItalicInfo_neither *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_counter_percent_get",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  result = (double) ((arg1)->counter_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_rsb_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_neither::rsb_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::rsb_percent",1,"ItalicInfo_neither *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_neither::rsb_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_rsb_percent_set",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->rsb_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_neither_rsb_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *arg1 = (ItalicInfo_neither *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_neither::rsb_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_neither::rsb_percent",1,"ItalicInfo_neither *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_neither,0))){
    SWIG_fail_ptr("ItalicInfo_neither_rsb_percent_get",1,SWIGTYPE_p_ItalicInfo_neither);
  }
  
  result = (double) ((arg1)->rsb_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ItalicInfo_neither(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_neither *result = 0 ;
  
  SWIG_check_num_args("ItalicInfo_neither::ItalicInfo_neither",0,0)
  result = (ItalicInfo_neither *)calloc(1, sizeof(ItalicInfo_neither));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ItalicInfo_neither,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ItalicInfo_neither(void *obj) {
ItalicInfo_neither *arg1 = (ItalicInfo_neither *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ItalicInfo_neither_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ItalicInfo_neither_attributes[] = {
    { "lsb_percent", _wrap_ItalicInfo_neither_lsb_percent_get, _wrap_ItalicInfo_neither_lsb_percent_set},
    { "stem_percent", _wrap_ItalicInfo_neither_stem_percent_get, _wrap_ItalicInfo_neither_stem_percent_set},
    { "counter_percent", _wrap_ItalicInfo_neither_counter_percent_get, _wrap_ItalicInfo_neither_counter_percent_set},
    { "rsb_percent", _wrap_ItalicInfo_neither_rsb_percent_get, _wrap_ItalicInfo_neither_rsb_percent_set},
    {0,0,0}
};
static swig_lua_class *swig_ItalicInfo_neither_bases[] = {0};
static const char *swig_ItalicInfo_neither_base_names[] = {0};
static swig_lua_class _wrap_class_ItalicInfo_neither = { "ItalicInfo_neither", &SWIGTYPE_p_ItalicInfo_neither,_wrap_new_ItalicInfo_neither, swig_delete_ItalicInfo_neither, swig_ItalicInfo_neither_methods, swig_ItalicInfo_neither_attributes, swig_ItalicInfo_neither_bases, swig_ItalicInfo_neither_base_names };

static int _wrap_ItalicInfo_uc_lsb_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_uc::lsb_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::lsb_percent",1,"ItalicInfo_uc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_uc::lsb_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_lsb_percent_set",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->lsb_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_lsb_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_uc::lsb_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::lsb_percent",1,"ItalicInfo_uc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_lsb_percent_get",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  result = (double) ((arg1)->lsb_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_stem_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_uc::stem_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::stem_percent",1,"ItalicInfo_uc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_uc::stem_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_stem_percent_set",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->stem_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_stem_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_uc::stem_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::stem_percent",1,"ItalicInfo_uc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_stem_percent_get",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  result = (double) ((arg1)->stem_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_counter_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_uc::counter_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::counter_percent",1,"ItalicInfo_uc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_uc::counter_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_counter_percent_set",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->counter_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_counter_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_uc::counter_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::counter_percent",1,"ItalicInfo_uc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_counter_percent_get",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  result = (double) ((arg1)->counter_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_rsb_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_uc::rsb_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::rsb_percent",1,"ItalicInfo_uc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_uc::rsb_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_rsb_percent_set",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->rsb_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_uc_rsb_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *arg1 = (ItalicInfo_uc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_uc::rsb_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_uc::rsb_percent",1,"ItalicInfo_uc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_uc,0))){
    SWIG_fail_ptr("ItalicInfo_uc_rsb_percent_get",1,SWIGTYPE_p_ItalicInfo_uc);
  }
  
  result = (double) ((arg1)->rsb_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ItalicInfo_uc(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_uc *result = 0 ;
  
  SWIG_check_num_args("ItalicInfo_uc::ItalicInfo_uc",0,0)
  result = (ItalicInfo_uc *)calloc(1, sizeof(ItalicInfo_uc));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ItalicInfo_uc,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ItalicInfo_uc(void *obj) {
ItalicInfo_uc *arg1 = (ItalicInfo_uc *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ItalicInfo_uc_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ItalicInfo_uc_attributes[] = {
    { "lsb_percent", _wrap_ItalicInfo_uc_lsb_percent_get, _wrap_ItalicInfo_uc_lsb_percent_set},
    { "stem_percent", _wrap_ItalicInfo_uc_stem_percent_get, _wrap_ItalicInfo_uc_stem_percent_set},
    { "counter_percent", _wrap_ItalicInfo_uc_counter_percent_get, _wrap_ItalicInfo_uc_counter_percent_set},
    { "rsb_percent", _wrap_ItalicInfo_uc_rsb_percent_get, _wrap_ItalicInfo_uc_rsb_percent_set},
    {0,0,0}
};
static swig_lua_class *swig_ItalicInfo_uc_bases[] = {0};
static const char *swig_ItalicInfo_uc_base_names[] = {0};
static swig_lua_class _wrap_class_ItalicInfo_uc = { "ItalicInfo_uc", &SWIGTYPE_p_ItalicInfo_uc,_wrap_new_ItalicInfo_uc, swig_delete_ItalicInfo_uc, swig_ItalicInfo_uc_methods, swig_ItalicInfo_uc_attributes, swig_ItalicInfo_uc_bases, swig_ItalicInfo_uc_base_names };

static int _wrap_ItalicInfo_lc_lsb_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_lc::lsb_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::lsb_percent",1,"ItalicInfo_lc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_lc::lsb_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_lsb_percent_set",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->lsb_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_lsb_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_lc::lsb_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::lsb_percent",1,"ItalicInfo_lc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_lsb_percent_get",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  result = (double) ((arg1)->lsb_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_stem_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_lc::stem_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::stem_percent",1,"ItalicInfo_lc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_lc::stem_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_stem_percent_set",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->stem_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_stem_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_lc::stem_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::stem_percent",1,"ItalicInfo_lc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_stem_percent_get",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  result = (double) ((arg1)->stem_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_counter_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_lc::counter_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::counter_percent",1,"ItalicInfo_lc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_lc::counter_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_counter_percent_set",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->counter_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_counter_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_lc::counter_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::counter_percent",1,"ItalicInfo_lc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_counter_percent_get",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  result = (double) ((arg1)->counter_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_rsb_percent_set(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("ItalicInfo_lc::rsb_percent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::rsb_percent",1,"ItalicInfo_lc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ItalicInfo_lc::rsb_percent",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_rsb_percent_set",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->rsb_percent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ItalicInfo_lc_rsb_percent_get(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *arg1 = (ItalicInfo_lc *) 0 ;
  double result;
  
  SWIG_check_num_args("ItalicInfo_lc::rsb_percent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ItalicInfo_lc::rsb_percent",1,"ItalicInfo_lc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ItalicInfo_lc,0))){
    SWIG_fail_ptr("ItalicInfo_lc_rsb_percent_get",1,SWIGTYPE_p_ItalicInfo_lc);
  }
  
  result = (double) ((arg1)->rsb_percent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ItalicInfo_lc(lua_State* L) {
  int SWIG_arg = 0;
  ItalicInfo_lc *result = 0 ;
  
  SWIG_check_num_args("ItalicInfo_lc::ItalicInfo_lc",0,0)
  result = (ItalicInfo_lc *)calloc(1, sizeof(ItalicInfo_lc));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ItalicInfo_lc,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ItalicInfo_lc(void *obj) {
ItalicInfo_lc *arg1 = (ItalicInfo_lc *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ItalicInfo_lc_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ItalicInfo_lc_attributes[] = {
    { "lsb_percent", _wrap_ItalicInfo_lc_lsb_percent_get, _wrap_ItalicInfo_lc_lsb_percent_set},
    { "stem_percent", _wrap_ItalicInfo_lc_stem_percent_get, _wrap_ItalicInfo_lc_stem_percent_set},
    { "counter_percent", _wrap_ItalicInfo_lc_counter_percent_get, _wrap_ItalicInfo_lc_counter_percent_set},
    { "rsb_percent", _wrap_ItalicInfo_lc_rsb_percent_get, _wrap_ItalicInfo_lc_rsb_percent_set},
    {0,0,0}
};
static swig_lua_class *swig_ItalicInfo_lc_bases[] = {0};
static const char *swig_ItalicInfo_lc_base_names[] = {0};
static swig_lua_class _wrap_class_ItalicInfo_lc = { "ItalicInfo_lc", &SWIGTYPE_p_ItalicInfo_lc,_wrap_new_ItalicInfo_lc, swig_delete_ItalicInfo_lc, swig_ItalicInfo_lc_methods, swig_ItalicInfo_lc_attributes, swig_ItalicInfo_lc_bases, swig_ItalicInfo_lc_base_names };

static int _wrap_BlueData_xheight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::xheight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::xheight",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::xheight",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_xheight_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xheight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_xheight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::xheight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::xheight",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_xheight_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->xheight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_xheighttop_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::xheighttop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::xheighttop",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::xheighttop",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_xheighttop_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xheighttop = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_xheighttop_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::xheighttop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::xheighttop",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_xheighttop_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->xheighttop);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_caph_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::caph",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::caph",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::caph",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_caph_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->caph = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_caph_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::caph",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::caph",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_caph_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->caph);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_caphtop_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::caphtop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::caphtop",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::caphtop",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_caphtop_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->caphtop = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_caphtop_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::caphtop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::caphtop",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_caphtop_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->caphtop);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::base",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::base",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_base_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::base",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_base_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->base);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_basebelow_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::basebelow",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::basebelow",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::basebelow",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_basebelow_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->basebelow = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_basebelow_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::basebelow",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::basebelow",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_basebelow_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->basebelow);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_ascent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::ascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::ascent",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::ascent",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_ascent_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->ascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_ascent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::ascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::ascent",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_ascent_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->ascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_descent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::descent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::descent",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::descent",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_descent_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->descent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_descent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::descent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::descent",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_descent_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->descent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_numh_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::numh",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::numh",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::numh",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_numh_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->numh = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_numh_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::numh",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::numh",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_numh_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->numh);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_numhtop_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluedata::numhtop",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::numhtop",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::numhtop",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_numhtop_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->numhtop = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_numhtop_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float result;
  
  SWIG_check_num_args("bluedata::numhtop",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::numhtop",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_numhtop_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float) ((arg1)->numhtop);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_bluecnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bluedata::bluecnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::bluecnt",1,"struct bluedata *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluedata::bluecnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_bluecnt_set",1,SWIGTYPE_p_bluedata);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bluecnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_bluecnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  int result;
  
  SWIG_check_num_args("bluedata::bluecnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::bluecnt",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_bluecnt_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (int) ((arg1)->bluecnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_blues_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float (*arg2)[2] ;
  
  SWIG_check_num_args("bluedata::blues",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::blues",1,"struct bluedata *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bluedata::blues",2,"float [12][2]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_blues_set",1,SWIGTYPE_p_bluedata);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_a_2__float,0))){
    SWIG_fail_ptr("BlueData_blues_set",2,SWIGTYPE_p_a_2__float);
  }
  
  {
    float (*inp)[2] = (float (*)[2])(arg2);
    float (*dest)[2] = (float (*)[2])(arg1->blues);
    size_t ii = 0;
    for (; ii < 12; ++ii) {
      float *ip = inp[ii];
      float *dp = dest[ii];
      size_t jj = 0;
      for (; jj < 2; ++jj) dp[jj] = ip[jj];
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueData_blues_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *arg1 = (struct bluedata *) 0 ;
  float (*result)[2] = 0 ;
  
  SWIG_check_num_args("bluedata::blues",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluedata::blues",1,"struct bluedata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("BlueData_blues_get",1,SWIGTYPE_p_bluedata);
  }
  
  result = (float (*)[2])(float (*)[2]) ((arg1)->blues);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_a_2__float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BlueData(lua_State* L) {
  int SWIG_arg = 0;
  struct bluedata *result = 0 ;
  
  SWIG_check_num_args("bluedata::bluedata",0,0)
  result = (struct bluedata *)calloc(1, sizeof(struct bluedata));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bluedata,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BlueData(void *obj) {
struct bluedata *arg1 = (struct bluedata *) obj;
free((char *) arg1);
}
static swig_lua_method swig_bluedata_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_bluedata_attributes[] = {
    { "xheight", _wrap_BlueData_xheight_get, _wrap_BlueData_xheight_set},
    { "xheighttop", _wrap_BlueData_xheighttop_get, _wrap_BlueData_xheighttop_set},
    { "caph", _wrap_BlueData_caph_get, _wrap_BlueData_caph_set},
    { "caphtop", _wrap_BlueData_caphtop_get, _wrap_BlueData_caphtop_set},
    { "base", _wrap_BlueData_base_get, _wrap_BlueData_base_set},
    { "basebelow", _wrap_BlueData_basebelow_get, _wrap_BlueData_basebelow_set},
    { "ascent", _wrap_BlueData_ascent_get, _wrap_BlueData_ascent_set},
    { "descent", _wrap_BlueData_descent_get, _wrap_BlueData_descent_set},
    { "numh", _wrap_BlueData_numh_get, _wrap_BlueData_numh_set},
    { "numhtop", _wrap_BlueData_numhtop_get, _wrap_BlueData_numhtop_set},
    { "bluecnt", _wrap_BlueData_bluecnt_get, _wrap_BlueData_bluecnt_set},
    { "blues", _wrap_BlueData_blues_get, _wrap_BlueData_blues_set},
    {0,0,0}
};
static swig_lua_class *swig_bluedata_bases[] = {0};
static const char *swig_bluedata_base_names[] = {0};
static swig_lua_class _wrap_class_bluedata = { "BlueData", &SWIGTYPE_p_bluedata,_wrap_new_BlueData, swig_delete_BlueData, swig_bluedata_methods, swig_bluedata_attributes, swig_bluedata_bases, swig_bluedata_base_names };

static int _wrap_BDFFloat_xmin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffloat::xmin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::xmin",1,"struct bdffloat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffloat::xmin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_xmin_set",1,SWIGTYPE_p_bdffloat);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->xmin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_xmin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffloat::xmin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::xmin",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_xmin_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (int16) ((arg1)->xmin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_xmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffloat::xmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::xmax",1,"struct bdffloat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffloat::xmax",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_xmax_set",1,SWIGTYPE_p_bdffloat);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->xmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_xmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffloat::xmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::xmax",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_xmax_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (int16) ((arg1)->xmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_ymin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffloat::ymin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::ymin",1,"struct bdffloat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffloat::ymin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_ymin_set",1,SWIGTYPE_p_bdffloat);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ymin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_ymin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffloat::ymin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::ymin",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_ymin_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (int16) ((arg1)->ymin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_ymax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffloat::ymax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::ymax",1,"struct bdffloat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffloat::ymax",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_ymax_set",1,SWIGTYPE_p_bdffloat);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ymax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_ymax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffloat::ymax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::ymax",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_ymax_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (int16) ((arg1)->ymax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_bytes_per_line_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffloat::bytes_per_line",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::bytes_per_line",1,"struct bdffloat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffloat::bytes_per_line",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_bytes_per_line_set",1,SWIGTYPE_p_bdffloat);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->bytes_per_line = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_bytes_per_line_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffloat::bytes_per_line",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::bytes_per_line",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_bytes_per_line_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (int16) ((arg1)->bytes_per_line);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_byte_data_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdffloat::byte_data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::byte_data",1,"struct bdffloat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffloat::byte_data",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_byte_data_set",1,SWIGTYPE_p_bdffloat);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->byte_data = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_byte_data_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdffloat::byte_data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::byte_data",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_byte_data_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (unsigned int) ((arg1)->byte_data);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_depth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("bdffloat::depth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::depth",1,"struct bdffloat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffloat::depth",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_depth_set",1,SWIGTYPE_p_bdffloat);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->depth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_depth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("bdffloat::depth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::depth",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_depth_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (uint8) ((arg1)->depth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_bitmap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("bdffloat::bitmap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::bitmap",1,"struct bdffloat *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdffloat::bitmap",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_bitmap_set",1,SWIGTYPE_p_bdffloat);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFFloat_bitmap_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->bitmap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFloat_bitmap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *arg1 = (struct bdffloat *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("bdffloat::bitmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffloat::bitmap",1,"struct bdffloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffloat,0))){
    SWIG_fail_ptr("BDFFloat_bitmap_get",1,SWIGTYPE_p_bdffloat);
  }
  
  result = (uint8 *) ((arg1)->bitmap);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BDFFloat(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffloat *result = 0 ;
  
  SWIG_check_num_args("bdffloat::bdffloat",0,0)
  result = (struct bdffloat *)calloc(1, sizeof(struct bdffloat));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffloat,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BDFFloat(void *obj) {
struct bdffloat *arg1 = (struct bdffloat *) obj;
free((char *) arg1);
}
static swig_lua_method swig_bdffloat_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_bdffloat_attributes[] = {
    { "xmin", _wrap_BDFFloat_xmin_get, _wrap_BDFFloat_xmin_set},
    { "xmax", _wrap_BDFFloat_xmax_get, _wrap_BDFFloat_xmax_set},
    { "ymin", _wrap_BDFFloat_ymin_get, _wrap_BDFFloat_ymin_set},
    { "ymax", _wrap_BDFFloat_ymax_get, _wrap_BDFFloat_ymax_set},
    { "bytes_per_line", _wrap_BDFFloat_bytes_per_line_get, _wrap_BDFFloat_bytes_per_line_set},
    { "byte_data", _wrap_BDFFloat_byte_data_get, _wrap_BDFFloat_byte_data_set},
    { "depth", _wrap_BDFFloat_depth_get, _wrap_BDFFloat_depth_set},
    { "bitmap", _wrap_BDFFloat_bitmap_get, _wrap_BDFFloat_bitmap_set},
    {0,0,0}
};
static swig_lua_class *swig_bdffloat_bases[] = {0};
static const char *swig_bdffloat_base_names[] = {0};
static swig_lua_class _wrap_class_bdffloat = { "BDFFloat", &SWIGTYPE_p_bdffloat,_wrap_new_BDFFloat, swig_delete_BDFFloat, swig_bdffloat_methods, swig_bdffloat_attributes, swig_bdffloat_bases, swig_bdffloat_base_names };

static int _wrap_scriptlanglist_script_set(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("scriptlanglist::script",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::script",1,"struct scriptlanglist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("scriptlanglist::script",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_script_set",1,SWIGTYPE_p_scriptlanglist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->script = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_script_get(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("scriptlanglist::script",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::script",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_script_get",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (uint32) ((arg1)->script);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_langs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  uint32 *arg2 ;
  
  SWIG_check_num_args("scriptlanglist::langs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::langs",1,"struct scriptlanglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("scriptlanglist::langs",2,"uint32 [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_langs_set",1,SWIGTYPE_p_scriptlanglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("scriptlanglist_langs_set",2,SWIGTYPE_p_unsigned_int);
  }
  
  {
    size_t ii;
    uint32 *b = (uint32 *) arg1->langs;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((uint32 *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_langs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("scriptlanglist::langs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::langs",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_langs_get",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (uint32 *)(uint32 *) ((arg1)->langs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_morelangs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  uint32 *arg2 = (uint32 *) 0 ;
  
  SWIG_check_num_args("scriptlanglist::morelangs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::morelangs",1,"struct scriptlanglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("scriptlanglist::morelangs",2,"uint32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_morelangs_set",1,SWIGTYPE_p_scriptlanglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("scriptlanglist_morelangs_set",2,SWIGTYPE_p_unsigned_int);
  }
  
  if (arg1) (arg1)->morelangs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_morelangs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("scriptlanglist::morelangs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::morelangs",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_morelangs_get",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (uint32 *) ((arg1)->morelangs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_lang_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("scriptlanglist::lang_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::lang_cnt",1,"struct scriptlanglist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("scriptlanglist::lang_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_lang_cnt_set",1,SWIGTYPE_p_scriptlanglist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lang_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_lang_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  int result;
  
  SWIG_check_num_args("scriptlanglist::lang_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::lang_cnt",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_lang_cnt_get",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (int) ((arg1)->lang_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  struct scriptlanglist *arg2 = (struct scriptlanglist *) 0 ;
  
  SWIG_check_num_args("scriptlanglist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::next",1,"struct scriptlanglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("scriptlanglist::next",2,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_next_set",1,SWIGTYPE_p_scriptlanglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_scriptlanglist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("scriptlanglist_next_set",2,SWIGTYPE_p_scriptlanglist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_scriptlanglist_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  struct scriptlanglist *result = 0 ;
  
  SWIG_check_num_args("scriptlanglist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("scriptlanglist::next",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("scriptlanglist_next_get",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (struct scriptlanglist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_scriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_scriptlanglist(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *result = 0 ;
  
  SWIG_check_num_args("scriptlanglist::scriptlanglist",0,0)
  result = (struct scriptlanglist *)calloc(1, sizeof(struct scriptlanglist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_scriptlanglist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_scriptlanglist(void *obj) {
struct scriptlanglist *arg1 = (struct scriptlanglist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_scriptlanglist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_scriptlanglist_attributes[] = {
    { "script", _wrap_scriptlanglist_script_get, _wrap_scriptlanglist_script_set},
    { "langs", _wrap_scriptlanglist_langs_get, _wrap_scriptlanglist_langs_set},
    { "morelangs", _wrap_scriptlanglist_morelangs_get, _wrap_scriptlanglist_morelangs_set},
    { "lang_cnt", _wrap_scriptlanglist_lang_cnt_get, _wrap_scriptlanglist_lang_cnt_set},
    { "next", _wrap_scriptlanglist_next_get, _wrap_scriptlanglist_next_set},
    {0,0,0}
};
static swig_lua_class *swig_scriptlanglist_bases[] = {0};
static const char *swig_scriptlanglist_base_names[] = {0};
static swig_lua_class _wrap_class_scriptlanglist = { "scriptlanglist", &SWIGTYPE_p_scriptlanglist,_wrap_new_scriptlanglist, swig_delete_scriptlanglist, swig_scriptlanglist_methods, swig_scriptlanglist_attributes, swig_scriptlanglist_bases, swig_scriptlanglist_base_names };

static int _wrap_opentype_feature_friendlynames_tag_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("opentype_feature_friendlynames::tag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::tag",1,"struct opentype_feature_friendlynames *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_feature_friendlynames::tag",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_tag_set",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->tag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_feature_friendlynames_tag_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("opentype_feature_friendlynames::tag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::tag",1,"struct opentype_feature_friendlynames *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_tag_get",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  result = (uint32) ((arg1)->tag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_feature_friendlynames_tagstr_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("opentype_feature_friendlynames::tagstr",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::tagstr",1,"struct opentype_feature_friendlynames *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("opentype_feature_friendlynames::tagstr",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_tagstr_set",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->tagstr);
    if (arg2) {
      arg1->tagstr = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->tagstr, (const char *)arg2);
    } else {
      arg1->tagstr = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_feature_friendlynames_tagstr_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("opentype_feature_friendlynames::tagstr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::tagstr",1,"struct opentype_feature_friendlynames *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_tagstr_get",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  result = (char *) ((arg1)->tagstr);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_feature_friendlynames_friendlyname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("opentype_feature_friendlynames::friendlyname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::friendlyname",1,"struct opentype_feature_friendlynames *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("opentype_feature_friendlynames::friendlyname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_friendlyname_set",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->friendlyname);
    if (arg2) {
      arg1->friendlyname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->friendlyname, (const char *)arg2);
    } else {
      arg1->friendlyname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_feature_friendlynames_friendlyname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("opentype_feature_friendlynames::friendlyname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::friendlyname",1,"struct opentype_feature_friendlynames *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_friendlyname_get",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  result = (char *) ((arg1)->friendlyname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_feature_friendlynames_masks_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("opentype_feature_friendlynames::masks",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::masks",1,"struct opentype_feature_friendlynames *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_feature_friendlynames::masks",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_masks_set",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->masks = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_feature_friendlynames_masks_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) 0 ;
  int result;
  
  SWIG_check_num_args("opentype_feature_friendlynames::masks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_feature_friendlynames::masks",1,"struct opentype_feature_friendlynames *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_feature_friendlynames,0))){
    SWIG_fail_ptr("opentype_feature_friendlynames_masks_get",1,SWIGTYPE_p_opentype_feature_friendlynames);
  }
  
  result = (int) ((arg1)->masks);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_opentype_feature_friendlynames(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *result = 0 ;
  
  SWIG_check_num_args("opentype_feature_friendlynames::opentype_feature_friendlynames",0,0)
  result = (struct opentype_feature_friendlynames *)calloc(1, sizeof(struct opentype_feature_friendlynames));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_opentype_feature_friendlynames,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_opentype_feature_friendlynames(void *obj) {
struct opentype_feature_friendlynames *arg1 = (struct opentype_feature_friendlynames *) obj;
free((char *) arg1);
}
static swig_lua_method swig_opentype_feature_friendlynames_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_opentype_feature_friendlynames_attributes[] = {
    { "tag", _wrap_opentype_feature_friendlynames_tag_get, _wrap_opentype_feature_friendlynames_tag_set},
    { "tagstr", _wrap_opentype_feature_friendlynames_tagstr_get, _wrap_opentype_feature_friendlynames_tagstr_set},
    { "friendlyname", _wrap_opentype_feature_friendlynames_friendlyname_get, _wrap_opentype_feature_friendlynames_friendlyname_set},
    { "masks", _wrap_opentype_feature_friendlynames_masks_get, _wrap_opentype_feature_friendlynames_masks_set},
    {0,0,0}
};
static swig_lua_class *swig_opentype_feature_friendlynames_bases[] = {0};
static const char *swig_opentype_feature_friendlynames_base_names[] = {0};
static swig_lua_class _wrap_class_opentype_feature_friendlynames = { "opentype_feature_friendlynames", &SWIGTYPE_p_opentype_feature_friendlynames,_wrap_new_opentype_feature_friendlynames, swig_delete_opentype_feature_friendlynames, swig_opentype_feature_friendlynames_methods, swig_opentype_feature_friendlynames_attributes, swig_opentype_feature_friendlynames_bases, swig_opentype_feature_friendlynames_base_names };

static int _wrap_friendlies_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_feature_friendlynames *result = 0 ;
  
  SWIG_check_num_args("friendlies",0,0)
  result = (struct opentype_feature_friendlynames *)(struct opentype_feature_friendlynames *)friendlies;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_opentype_feature_friendlynames,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_featuretag_set(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("featurescriptlanglist::featuretag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::featuretag",1,"struct featurescriptlanglist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("featurescriptlanglist::featuretag",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_featuretag_set",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->featuretag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_featuretag_get(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("featurescriptlanglist::featuretag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::featuretag",1,"struct featurescriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_featuretag_get",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (uint32) ((arg1)->featuretag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_scripts_set(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  struct scriptlanglist *arg2 = (struct scriptlanglist *) 0 ;
  
  SWIG_check_num_args("featurescriptlanglist::scripts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::scripts",1,"struct featurescriptlanglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("featurescriptlanglist::scripts",2,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_scripts_set",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_scriptlanglist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FeatureScriptLangList_scripts_set",2,SWIGTYPE_p_scriptlanglist);
  }
  
  if (arg1) (arg1)->scripts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_scripts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  struct scriptlanglist *result = 0 ;
  
  SWIG_check_num_args("featurescriptlanglist::scripts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::scripts",1,"struct featurescriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_scripts_get",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (struct scriptlanglist *) ((arg1)->scripts);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_scriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  struct featurescriptlanglist *arg2 = (struct featurescriptlanglist *) 0 ;
  
  SWIG_check_num_args("featurescriptlanglist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::next",1,"struct featurescriptlanglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("featurescriptlanglist::next",2,"struct featurescriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_next_set",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_featurescriptlanglist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FeatureScriptLangList_next_set",2,SWIGTYPE_p_featurescriptlanglist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  struct featurescriptlanglist *result = 0 ;
  
  SWIG_check_num_args("featurescriptlanglist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::next",1,"struct featurescriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_next_get",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (struct featurescriptlanglist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_featurescriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_ismac_set(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("featurescriptlanglist::ismac",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::ismac",1,"struct featurescriptlanglist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("featurescriptlanglist::ismac",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_ismac_set",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ismac = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangList_ismac_get(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("featurescriptlanglist::ismac",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("featurescriptlanglist::ismac",1,"struct featurescriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangList_ismac_get",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (unsigned int) ((arg1)->ismac);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FeatureScriptLangList(lua_State* L) {
  int SWIG_arg = 0;
  struct featurescriptlanglist *result = 0 ;
  
  SWIG_check_num_args("featurescriptlanglist::featurescriptlanglist",0,0)
  result = (struct featurescriptlanglist *)calloc(1, sizeof(struct featurescriptlanglist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_featurescriptlanglist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FeatureScriptLangList(void *obj) {
struct featurescriptlanglist *arg1 = (struct featurescriptlanglist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_featurescriptlanglist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_featurescriptlanglist_attributes[] = {
    { "featuretag", _wrap_FeatureScriptLangList_featuretag_get, _wrap_FeatureScriptLangList_featuretag_set},
    { "scripts", _wrap_FeatureScriptLangList_scripts_get, _wrap_FeatureScriptLangList_scripts_set},
    { "next", _wrap_FeatureScriptLangList_next_get, _wrap_FeatureScriptLangList_next_set},
    { "ismac", _wrap_FeatureScriptLangList_ismac_get, _wrap_FeatureScriptLangList_ismac_set},
    {0,0,0}
};
static swig_lua_class *swig_featurescriptlanglist_bases[] = {0};
static const char *swig_featurescriptlanglist_base_names[] = {0};
static swig_lua_class _wrap_class_featurescriptlanglist = { "FeatureScriptLangList", &SWIGTYPE_p_featurescriptlanglist,_wrap_new_FeatureScriptLangList, swig_delete_FeatureScriptLangList, swig_featurescriptlanglist_methods, swig_featurescriptlanglist_attributes, swig_featurescriptlanglist_bases, swig_featurescriptlanglist_base_names };

static int _wrap_OTLookup_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  struct otlookup *arg2 = (struct otlookup *) 0 ;
  
  SWIG_check_num_args("otlookup::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::next",1,"struct otlookup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("otlookup::next",2,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_next_set",1,SWIGTYPE_p_otlookup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_next_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  struct otlookup *result = 0 ;
  
  SWIG_check_num_args("otlookup::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::next",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_next_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (struct otlookup *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  enum otlookup_type arg2 ;
  
  SWIG_check_num_args("otlookup::lookup_type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_type",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::lookup_type",2,"enum otlookup_type");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_type_set",1,SWIGTYPE_p_otlookup);
  }
  
  arg2 = (enum otlookup_type)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lookup_type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  enum otlookup_type result;
  
  SWIG_check_num_args("otlookup::lookup_type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_type",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_type_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (enum otlookup_type) ((arg1)->lookup_type);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_flags_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("otlookup::lookup_flags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_flags",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::lookup_flags",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_flags_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->lookup_flags = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_flags_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("otlookup::lookup_flags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_flags",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_flags_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (uint32) ((arg1)->lookup_flags);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("otlookup::lookup_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_name",1,"struct otlookup *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("otlookup::lookup_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_name_set",1,SWIGTYPE_p_otlookup);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->lookup_name);
    if (arg2) {
      arg1->lookup_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->lookup_name, (const char *)arg2);
    } else {
      arg1->lookup_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("otlookup::lookup_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_name",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_name_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (char *) ((arg1)->lookup_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_features_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  FeatureScriptLangList *arg2 = (FeatureScriptLangList *) 0 ;
  
  SWIG_check_num_args("otlookup::features",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::features",1,"struct otlookup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("otlookup::features",2,"FeatureScriptLangList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_features_set",1,SWIGTYPE_p_otlookup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_featurescriptlanglist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_features_set",2,SWIGTYPE_p_featurescriptlanglist);
  }
  
  if (arg1) (arg1)->features = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_features_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  FeatureScriptLangList *result = 0 ;
  
  SWIG_check_num_args("otlookup::features",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::features",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_features_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (FeatureScriptLangList *) ((arg1)->features);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_featurescriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_unused_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::unused",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::unused",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::unused",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_unused_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unused = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_unused_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::unused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::unused",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_unused_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->unused);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_empty_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::empty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::empty",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::empty",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_empty_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->empty = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_empty_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::empty",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::empty",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_empty_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->empty);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_store_in_afm_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::store_in_afm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::store_in_afm",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::store_in_afm",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_store_in_afm_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->store_in_afm = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_store_in_afm_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::store_in_afm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::store_in_afm",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_store_in_afm_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->store_in_afm);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_needs_extension_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::needs_extension",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::needs_extension",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::needs_extension",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_needs_extension_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->needs_extension = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_needs_extension_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::needs_extension",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::needs_extension",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_needs_extension_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->needs_extension);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_temporary_kern_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::temporary_kern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::temporary_kern",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::temporary_kern",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_temporary_kern_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->temporary_kern = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_temporary_kern_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::temporary_kern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::temporary_kern",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_temporary_kern_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->temporary_kern);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_def_lang_checked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::def_lang_checked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::def_lang_checked",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::def_lang_checked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_def_lang_checked_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->def_lang_checked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_def_lang_checked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::def_lang_checked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::def_lang_checked",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_def_lang_checked_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->def_lang_checked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_def_lang_found_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::def_lang_found",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::def_lang_found",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::def_lang_found",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_def_lang_found_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->def_lang_found = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_def_lang_found_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::def_lang_found",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::def_lang_found",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_def_lang_found_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->def_lang_found);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::ticked",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_ticked_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::ticked",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_ticked_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_in_gpos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::in_gpos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::in_gpos",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::in_gpos",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_in_gpos_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->in_gpos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_in_gpos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::in_gpos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::in_gpos",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_in_gpos_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->in_gpos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_in_jstf_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::in_jstf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::in_jstf",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::in_jstf",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_in_jstf_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->in_jstf = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_in_jstf_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::in_jstf",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::in_jstf",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_in_jstf_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->in_jstf);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_only_jstf_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("otlookup::only_jstf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::only_jstf",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::only_jstf",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_only_jstf_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->only_jstf = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_only_jstf_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("otlookup::only_jstf",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::only_jstf",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_only_jstf_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (unsigned int) ((arg1)->only_jstf);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("otlookup::subcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::subcnt",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::subcnt",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_subcnt_set",1,SWIGTYPE_p_otlookup);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->subcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  int16 result;
  
  SWIG_check_num_args("otlookup::subcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::subcnt",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_subcnt_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (int16) ((arg1)->subcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_index_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("otlookup::lookup_index",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_index",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::lookup_index",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_index_set",1,SWIGTYPE_p_otlookup);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lookup_index = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_index_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  int result;
  
  SWIG_check_num_args("otlookup::lookup_index",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_index",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_index_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (int) ((arg1)->lookup_index);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_offset_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("otlookup::lookup_offset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_offset",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::lookup_offset",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_offset_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->lookup_offset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_offset_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("otlookup::lookup_offset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_offset",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_offset_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (uint32) ((arg1)->lookup_offset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_length_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("otlookup::lookup_length",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_length",1,"struct otlookup *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otlookup::lookup_length",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_length_set",1,SWIGTYPE_p_otlookup);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->lookup_length = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_lookup_length_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("otlookup::lookup_length",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::lookup_length",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_lookup_length_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (uint32) ((arg1)->lookup_length);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_tempname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("otlookup::tempname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::tempname",1,"struct otlookup *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("otlookup::tempname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_tempname_set",1,SWIGTYPE_p_otlookup);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->tempname);
    if (arg2) {
      arg1->tempname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->tempname, (const char *)arg2);
    } else {
      arg1->tempname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_tempname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("otlookup::tempname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::tempname",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_tempname_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (char *) ((arg1)->tempname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *arg1 = (struct otlookup *) 0 ;
  OTLookup_subtables *result = 0 ;
  
  SWIG_check_num_args("otlookup::subtables",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otlookup::subtables",1,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookup_subtables_get",1,SWIGTYPE_p_otlookup);
  }
  
  result = (OTLookup_subtables *) ((arg1)->subtables);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_OTLookup_subtables,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_OTLookup(lua_State* L) {
  int SWIG_arg = 0;
  struct otlookup *result = 0 ;
  
  SWIG_check_num_args("otlookup::otlookup",0,0)
  result = (struct otlookup *)calloc(1, sizeof(struct otlookup));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_OTLookup(void *obj) {
struct otlookup *arg1 = (struct otlookup *) obj;
free((char *) arg1);
}
static swig_lua_method swig_otlookup_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_otlookup_attributes[] = {
    { "next", _wrap_OTLookup_next_get, _wrap_OTLookup_next_set},
    { "lookup_type", _wrap_OTLookup_lookup_type_get, _wrap_OTLookup_lookup_type_set},
    { "lookup_flags", _wrap_OTLookup_lookup_flags_get, _wrap_OTLookup_lookup_flags_set},
    { "lookup_name", _wrap_OTLookup_lookup_name_get, _wrap_OTLookup_lookup_name_set},
    { "features", _wrap_OTLookup_features_get, _wrap_OTLookup_features_set},
    { "unused", _wrap_OTLookup_unused_get, _wrap_OTLookup_unused_set},
    { "empty", _wrap_OTLookup_empty_get, _wrap_OTLookup_empty_set},
    { "store_in_afm", _wrap_OTLookup_store_in_afm_get, _wrap_OTLookup_store_in_afm_set},
    { "needs_extension", _wrap_OTLookup_needs_extension_get, _wrap_OTLookup_needs_extension_set},
    { "temporary_kern", _wrap_OTLookup_temporary_kern_get, _wrap_OTLookup_temporary_kern_set},
    { "def_lang_checked", _wrap_OTLookup_def_lang_checked_get, _wrap_OTLookup_def_lang_checked_set},
    { "def_lang_found", _wrap_OTLookup_def_lang_found_get, _wrap_OTLookup_def_lang_found_set},
    { "ticked", _wrap_OTLookup_ticked_get, _wrap_OTLookup_ticked_set},
    { "in_gpos", _wrap_OTLookup_in_gpos_get, _wrap_OTLookup_in_gpos_set},
    { "in_jstf", _wrap_OTLookup_in_jstf_get, _wrap_OTLookup_in_jstf_set},
    { "only_jstf", _wrap_OTLookup_only_jstf_get, _wrap_OTLookup_only_jstf_set},
    { "subcnt", _wrap_OTLookup_subcnt_get, _wrap_OTLookup_subcnt_set},
    { "lookup_index", _wrap_OTLookup_lookup_index_get, _wrap_OTLookup_lookup_index_set},
    { "lookup_offset", _wrap_OTLookup_lookup_offset_get, _wrap_OTLookup_lookup_offset_set},
    { "lookup_length", _wrap_OTLookup_lookup_length_get, _wrap_OTLookup_lookup_length_set},
    { "tempname", _wrap_OTLookup_tempname_get, _wrap_OTLookup_tempname_set},
    { "subtables", _wrap_OTLookup_subtables_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_otlookup_bases[] = {0};
static const char *swig_otlookup_base_names[] = {0};
static swig_lua_class _wrap_class_otlookup = { "OTLookup", &SWIGTYPE_p_otlookup,_wrap_new_OTLookup, swig_delete_OTLookup, swig_otlookup_methods, swig_otlookup_attributes, swig_otlookup_bases, swig_otlookup_base_names };

static int _wrap_OTLookup_subtables_subtable_name_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::subtable_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::subtable_name",1,"OTLookup_subtables *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("OTLookup_subtables::subtable_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_subtable_name_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->subtable_name);
    if (arg2) {
      arg1->subtable_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->subtable_name, (const char *)arg2);
    } else {
      arg1->subtable_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_subtable_name_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::subtable_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::subtable_name",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_subtable_name_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (char *) ((arg1)->subtable_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_suffix_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::suffix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::suffix",1,"OTLookup_subtables *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("OTLookup_subtables::suffix",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_suffix_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->suffix);
    if (arg2) {
      arg1->suffix = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->suffix, (const char *)arg2);
    } else {
      arg1->suffix = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_suffix_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::suffix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::suffix",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_suffix_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (char *) ((arg1)->suffix);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_separation_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::separation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::separation",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::separation",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_separation_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->separation = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_separation_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int16 result;
  
  SWIG_check_num_args("OTLookup_subtables::separation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::separation",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_separation_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (int16) ((arg1)->separation);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_minkern_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::minkern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::minkern",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::minkern",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_minkern_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->minkern = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_minkern_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int16 result;
  
  SWIG_check_num_args("OTLookup_subtables::minkern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::minkern",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_minkern_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (int16) ((arg1)->minkern);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_lookup_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct otlookup *arg2 = (struct otlookup *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::lookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::lookup",1,"OTLookup_subtables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookup_subtables::lookup",2,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_lookup_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_subtables_lookup_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->lookup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_lookup_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct otlookup *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::lookup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::lookup",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_lookup_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (struct otlookup *) ((arg1)->lookup);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_unused_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::unused",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::unused",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::unused",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_unused_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unused = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_unused_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::unused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::unused",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_unused_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->unused);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_per_glyph_pst_or_kern_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::per_glyph_pst_or_kern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::per_glyph_pst_or_kern",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::per_glyph_pst_or_kern",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_per_glyph_pst_or_kern_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->per_glyph_pst_or_kern = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_per_glyph_pst_or_kern_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::per_glyph_pst_or_kern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::per_glyph_pst_or_kern",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_per_glyph_pst_or_kern_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->per_glyph_pst_or_kern);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_anchor_classes_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::anchor_classes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::anchor_classes",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::anchor_classes",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_anchor_classes_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->anchor_classes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_anchor_classes_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::anchor_classes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::anchor_classes",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_anchor_classes_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->anchor_classes);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_vertical_kerning_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::vertical_kerning",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::vertical_kerning",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::vertical_kerning",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_vertical_kerning_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->vertical_kerning = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_vertical_kerning_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::vertical_kerning",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::vertical_kerning",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_vertical_kerning_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->vertical_kerning);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::ticked",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_ticked_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::ticked",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_ticked_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_kerning_by_touch_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::kerning_by_touch",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::kerning_by_touch",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::kerning_by_touch",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_kerning_by_touch_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->kerning_by_touch = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_kerning_by_touch_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::kerning_by_touch",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::kerning_by_touch",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_kerning_by_touch_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->kerning_by_touch);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_onlyCloser_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::onlyCloser",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::onlyCloser",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::onlyCloser",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_onlyCloser_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->onlyCloser = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_onlyCloser_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::onlyCloser",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::onlyCloser",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_onlyCloser_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->onlyCloser);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_dontautokern_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::dontautokern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::dontautokern",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::dontautokern",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_dontautokern_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->dontautokern = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_dontautokern_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("OTLookup_subtables::dontautokern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::dontautokern",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_dontautokern_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (unsigned int) ((arg1)->dontautokern);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_kc_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct kernclass *arg2 = (struct kernclass *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::kc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::kc",1,"OTLookup_subtables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookup_subtables::kc",2,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_kc_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_subtables_kc_set",2,SWIGTYPE_p_kernclass);
  }
  
  if (arg1) (arg1)->kc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_kc_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct kernclass *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::kc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::kc",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_kc_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (struct kernclass *) ((arg1)->kc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_fpst_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct generic_fpst *arg2 = (struct generic_fpst *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::fpst",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::fpst",1,"OTLookup_subtables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookup_subtables::fpst",2,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_fpst_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_fpst,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_subtables_fpst_set",2,SWIGTYPE_p_generic_fpst);
  }
  
  if (arg1) (arg1)->fpst = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_fpst_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct generic_fpst *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::fpst",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::fpst",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_fpst_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (struct generic_fpst *) ((arg1)->fpst);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_fpst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_sm_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct generic_asm *arg2 = (struct generic_asm *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::sm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::sm",1,"OTLookup_subtables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookup_subtables::sm",2,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_sm_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_asm,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_subtables_sm_set",2,SWIGTYPE_p_generic_asm);
  }
  
  if (arg1) (arg1)->sm = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_sm_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct generic_asm *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::sm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::sm",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_sm_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (struct generic_asm *) ((arg1)->sm);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_asm,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_next_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::next",1,"OTLookup_subtables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookup_subtables::next",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_next_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_subtables_next_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_next_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::next",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_next_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (struct lookup_subtable *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_subtable_offset_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int32 arg2 ;
  
  SWIG_check_num_args("OTLookup_subtables::subtable_offset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::subtable_offset",1,"OTLookup_subtables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("OTLookup_subtables::subtable_offset",2,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_subtable_offset_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  if (arg1) (arg1)->subtable_offset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_subtable_offset_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int32 result;
  
  SWIG_check_num_args("OTLookup_subtables::subtable_offset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::subtable_offset",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_subtable_offset_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (int32) ((arg1)->subtable_offset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_extra_subtables_set(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int32 *arg2 = (int32 *) 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::extra_subtables",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::extra_subtables",1,"OTLookup_subtables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookup_subtables::extra_subtables",2,"int32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_extra_subtables_set",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("OTLookup_subtables_extra_subtables_set",2,SWIGTYPE_p_int);
  }
  
  if (arg1) (arg1)->extra_subtables = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookup_subtables_extra_subtables_get(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *arg1 = (OTLookup_subtables *) 0 ;
  int32 *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::extra_subtables",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookup_subtables::extra_subtables",1,"OTLookup_subtables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_OTLookup_subtables,0))){
    SWIG_fail_ptr("OTLookup_subtables_extra_subtables_get",1,SWIGTYPE_p_OTLookup_subtables);
  }
  
  result = (int32 *) ((arg1)->extra_subtables);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_OTLookup_subtables(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup_subtables *result = 0 ;
  
  SWIG_check_num_args("OTLookup_subtables::OTLookup_subtables",0,0)
  result = (OTLookup_subtables *)calloc(1, sizeof(OTLookup_subtables));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_OTLookup_subtables,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_OTLookup_subtables(void *obj) {
OTLookup_subtables *arg1 = (OTLookup_subtables *) obj;
free((char *) arg1);
}
static swig_lua_method swig_OTLookup_subtables_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_OTLookup_subtables_attributes[] = {
    { "subtable_name", _wrap_OTLookup_subtables_subtable_name_get, _wrap_OTLookup_subtables_subtable_name_set},
    { "suffix", _wrap_OTLookup_subtables_suffix_get, _wrap_OTLookup_subtables_suffix_set},
    { "separation", _wrap_OTLookup_subtables_separation_get, _wrap_OTLookup_subtables_separation_set},
    { "minkern", _wrap_OTLookup_subtables_minkern_get, _wrap_OTLookup_subtables_minkern_set},
    { "lookup", _wrap_OTLookup_subtables_lookup_get, _wrap_OTLookup_subtables_lookup_set},
    { "unused", _wrap_OTLookup_subtables_unused_get, _wrap_OTLookup_subtables_unused_set},
    { "per_glyph_pst_or_kern", _wrap_OTLookup_subtables_per_glyph_pst_or_kern_get, _wrap_OTLookup_subtables_per_glyph_pst_or_kern_set},
    { "anchor_classes", _wrap_OTLookup_subtables_anchor_classes_get, _wrap_OTLookup_subtables_anchor_classes_set},
    { "vertical_kerning", _wrap_OTLookup_subtables_vertical_kerning_get, _wrap_OTLookup_subtables_vertical_kerning_set},
    { "ticked", _wrap_OTLookup_subtables_ticked_get, _wrap_OTLookup_subtables_ticked_set},
    { "kerning_by_touch", _wrap_OTLookup_subtables_kerning_by_touch_get, _wrap_OTLookup_subtables_kerning_by_touch_set},
    { "onlyCloser", _wrap_OTLookup_subtables_onlyCloser_get, _wrap_OTLookup_subtables_onlyCloser_set},
    { "dontautokern", _wrap_OTLookup_subtables_dontautokern_get, _wrap_OTLookup_subtables_dontautokern_set},
    { "kc", _wrap_OTLookup_subtables_kc_get, _wrap_OTLookup_subtables_kc_set},
    { "fpst", _wrap_OTLookup_subtables_fpst_get, _wrap_OTLookup_subtables_fpst_set},
    { "sm", _wrap_OTLookup_subtables_sm_get, _wrap_OTLookup_subtables_sm_set},
    { "next", _wrap_OTLookup_subtables_next_get, _wrap_OTLookup_subtables_next_set},
    { "subtable_offset", _wrap_OTLookup_subtables_subtable_offset_get, _wrap_OTLookup_subtables_subtable_offset_set},
    { "extra_subtables", _wrap_OTLookup_subtables_extra_subtables_get, _wrap_OTLookup_subtables_extra_subtables_set},
    {0,0,0}
};
static swig_lua_class *swig_OTLookup_subtables_bases[] = {0};
static const char *swig_OTLookup_subtables_base_names[] = {0};
static swig_lua_class _wrap_class_OTLookup_subtables = { "OTLookup_subtables", &SWIGTYPE_p_OTLookup_subtables,_wrap_new_OTLookup_subtables, swig_delete_OTLookup_subtables, swig_OTLookup_subtables_methods, swig_OTLookup_subtables_attributes, swig_OTLookup_subtables_bases, swig_OTLookup_subtables_base_names };

static int _wrap_AnchorClass_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("anchorclass::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::name",1,"struct anchorclass *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("anchorclass::name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_name_set",1,SWIGTYPE_p_anchorclass);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->name);
    if (arg2) {
      arg1->name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("anchorclass::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::name",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_name_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_subtable_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("anchorclass::subtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::subtable",1,"struct anchorclass *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorclass::subtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_subtable_set",1,SWIGTYPE_p_anchorclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("AnchorClass_subtable_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->subtable = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_subtable_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("anchorclass::subtable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::subtable",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_subtable_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (struct lookup_subtable *) ((arg1)->subtable);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("anchorclass::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::type",1,"struct anchorclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorclass::type",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_type_set",1,SWIGTYPE_p_anchorclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("anchorclass::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::type",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_type_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (uint8) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_has_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("anchorclass::has_base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::has_base",1,"struct anchorclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorclass::has_base",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_has_base_set",1,SWIGTYPE_p_anchorclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->has_base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_has_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("anchorclass::has_base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::has_base",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_has_base_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (uint8) ((arg1)->has_base);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_processed_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("anchorclass::processed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::processed",1,"struct anchorclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorclass::processed",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_processed_set",1,SWIGTYPE_p_anchorclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->processed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_processed_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("anchorclass::processed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::processed",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_processed_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (uint8) ((arg1)->processed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_has_mark_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("anchorclass::has_mark",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::has_mark",1,"struct anchorclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorclass::has_mark",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_has_mark_set",1,SWIGTYPE_p_anchorclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->has_mark = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_has_mark_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("anchorclass::has_mark",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::has_mark",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_has_mark_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (uint8) ((arg1)->has_mark);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_matches_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("anchorclass::matches",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::matches",1,"struct anchorclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorclass::matches",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_matches_set",1,SWIGTYPE_p_anchorclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->matches = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_matches_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("anchorclass::matches",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::matches",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_matches_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (uint8) ((arg1)->matches);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_ac_num_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("anchorclass::ac_num",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::ac_num",1,"struct anchorclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorclass::ac_num",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_ac_num_set",1,SWIGTYPE_p_anchorclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->ac_num = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_ac_num_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("anchorclass::ac_num",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::ac_num",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_ac_num_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (uint8) ((arg1)->ac_num);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("anchorclass::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::ticked",1,"struct anchorclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorclass::ticked",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_ticked_set",1,SWIGTYPE_p_anchorclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("anchorclass::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::ticked",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_ticked_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (uint8) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  struct anchorclass *arg2 = (struct anchorclass *) 0 ;
  
  SWIG_check_num_args("anchorclass::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::next",1,"struct anchorclass *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorclass::next",2,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_next_set",1,SWIGTYPE_p_anchorclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("AnchorClass_next_set",2,SWIGTYPE_p_anchorclass);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClass_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *arg1 = (struct anchorclass *) 0 ;
  struct anchorclass *result = 0 ;
  
  SWIG_check_num_args("anchorclass::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorclass::next",1,"struct anchorclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClass_next_get",1,SWIGTYPE_p_anchorclass);
  }
  
  result = (struct anchorclass *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnchorClass(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorclass *result = 0 ;
  
  SWIG_check_num_args("anchorclass::anchorclass",0,0)
  result = (struct anchorclass *)calloc(1, sizeof(struct anchorclass));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnchorClass(void *obj) {
struct anchorclass *arg1 = (struct anchorclass *) obj;
free((char *) arg1);
}
static swig_lua_method swig_anchorclass_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_anchorclass_attributes[] = {
    { "name", _wrap_AnchorClass_name_get, _wrap_AnchorClass_name_set},
    { "subtable", _wrap_AnchorClass_subtable_get, _wrap_AnchorClass_subtable_set},
    { "type", _wrap_AnchorClass_type_get, _wrap_AnchorClass_type_set},
    { "has_base", _wrap_AnchorClass_has_base_get, _wrap_AnchorClass_has_base_set},
    { "processed", _wrap_AnchorClass_processed_get, _wrap_AnchorClass_processed_set},
    { "has_mark", _wrap_AnchorClass_has_mark_get, _wrap_AnchorClass_has_mark_set},
    { "matches", _wrap_AnchorClass_matches_get, _wrap_AnchorClass_matches_set},
    { "ac_num", _wrap_AnchorClass_ac_num_get, _wrap_AnchorClass_ac_num_set},
    { "ticked", _wrap_AnchorClass_ticked_get, _wrap_AnchorClass_ticked_set},
    { "next", _wrap_AnchorClass_next_get, _wrap_AnchorClass_next_set},
    {0,0,0}
};
static swig_lua_class *swig_anchorclass_bases[] = {0};
static const char *swig_anchorclass_base_names[] = {0};
static swig_lua_class _wrap_class_anchorclass = { "AnchorClass", &SWIGTYPE_p_anchorclass,_wrap_new_AnchorClass, swig_delete_AnchorClass, swig_anchorclass_methods, swig_anchorclass_attributes, swig_anchorclass_bases, swig_anchorclass_base_names };

static int _wrap_AnchorPoint_anchor_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  
  SWIG_check_num_args("anchorpoint::anchor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::anchor",1,"struct anchorpoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorpoint::anchor",2,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_anchor_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("AnchorPoint_anchor_set",2,SWIGTYPE_p_anchorclass);
  }
  
  if (arg1) (arg1)->anchor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_anchor_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("anchorpoint::anchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::anchor",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_anchor_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (AnchorClass *) ((arg1)->anchor);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_me_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("anchorpoint::me",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::me",1,"struct anchorpoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorpoint::me",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_me_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("AnchorPoint_me_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->me = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_me_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("anchorpoint::me",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::me",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_me_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (BasePoint *)& ((arg1)->me);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("anchorpoint::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::type",1,"struct anchorpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpoint::type",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_type_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("anchorpoint::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::type",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_type_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (unsigned int) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_selected_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("anchorpoint::selected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::selected",1,"struct anchorpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpoint::selected",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_selected_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->selected = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_selected_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("anchorpoint::selected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::selected",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_selected_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (unsigned int) ((arg1)->selected);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("anchorpoint::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::ticked",1,"struct anchorpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpoint::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_ticked_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("anchorpoint::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::ticked",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_ticked_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_has_ttf_pt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("anchorpoint::has_ttf_pt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::has_ttf_pt",1,"struct anchorpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpoint::has_ttf_pt",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_has_ttf_pt_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->has_ttf_pt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_has_ttf_pt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("anchorpoint::has_ttf_pt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::has_ttf_pt",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_has_ttf_pt_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (unsigned int) ((arg1)->has_ttf_pt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_ttf_pt_index_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("anchorpoint::ttf_pt_index",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::ttf_pt_index",1,"struct anchorpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpoint::ttf_pt_index",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_ttf_pt_index_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ttf_pt_index = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_ttf_pt_index_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("anchorpoint::ttf_pt_index",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::ttf_pt_index",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_ttf_pt_index_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (uint16) ((arg1)->ttf_pt_index);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_lig_index_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("anchorpoint::lig_index",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::lig_index",1,"struct anchorpoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpoint::lig_index",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_lig_index_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->lig_index = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_lig_index_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  int16 result;
  
  SWIG_check_num_args("anchorpoint::lig_index",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::lig_index",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_lig_index_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (int16) ((arg1)->lig_index);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  struct anchorpoint *arg2 = (struct anchorpoint *) 0 ;
  
  SWIG_check_num_args("anchorpoint::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::next",1,"struct anchorpoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorpoint::next",2,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_next_set",1,SWIGTYPE_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorpoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("AnchorPoint_next_set",2,SWIGTYPE_p_anchorpoint);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPoint_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *arg1 = (struct anchorpoint *) 0 ;
  struct anchorpoint *result = 0 ;
  
  SWIG_check_num_args("anchorpoint::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpoint::next",1,"struct anchorpoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPoint_next_get",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (struct anchorpoint *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnchorPoint(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpoint *result = 0 ;
  
  SWIG_check_num_args("anchorpoint::anchorpoint",0,0)
  result = (struct anchorpoint *)calloc(1, sizeof(struct anchorpoint));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnchorPoint(void *obj) {
struct anchorpoint *arg1 = (struct anchorpoint *) obj;
free((char *) arg1);
}
static swig_lua_method swig_anchorpoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_anchorpoint_attributes[] = {
    { "anchor", _wrap_AnchorPoint_anchor_get, _wrap_AnchorPoint_anchor_set},
    { "me", _wrap_AnchorPoint_me_get, _wrap_AnchorPoint_me_set},
    { "type", _wrap_AnchorPoint_type_get, _wrap_AnchorPoint_type_set},
    { "selected", _wrap_AnchorPoint_selected_get, _wrap_AnchorPoint_selected_set},
    { "ticked", _wrap_AnchorPoint_ticked_get, _wrap_AnchorPoint_ticked_set},
    { "has_ttf_pt", _wrap_AnchorPoint_has_ttf_pt_get, _wrap_AnchorPoint_has_ttf_pt_set},
    { "ttf_pt_index", _wrap_AnchorPoint_ttf_pt_index_get, _wrap_AnchorPoint_ttf_pt_index_set},
    { "lig_index", _wrap_AnchorPoint_lig_index_get, _wrap_AnchorPoint_lig_index_set},
    { "next", _wrap_AnchorPoint_next_get, _wrap_AnchorPoint_next_set},
    {0,0,0}
};
static swig_lua_class *swig_anchorpoint_bases[] = {0};
static const char *swig_anchorpoint_base_names[] = {0};
static swig_lua_class _wrap_class_anchorpoint = { "AnchorPoint", &SWIGTYPE_p_anchorpoint,_wrap_new_AnchorPoint, swig_delete_AnchorPoint, swig_anchorpoint_methods, swig_anchorpoint_attributes, swig_anchorpoint_bases, swig_anchorpoint_base_names };

static int _wrap_KernPair_subtable_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("kernpair::subtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::subtable",1,"struct kernpair *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernpair::subtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_subtable_set",1,SWIGTYPE_p_kernpair);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("KernPair_subtable_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->subtable = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_subtable_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("kernpair::subtable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::subtable",1,"struct kernpair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_subtable_get",1,SWIGTYPE_p_kernpair);
  }
  
  result = (struct lookup_subtable *) ((arg1)->subtable);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_sc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  struct splinechar *arg2 = (struct splinechar *) 0 ;
  
  SWIG_check_num_args("kernpair::sc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::sc",1,"struct kernpair *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernpair::sc",2,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_sc_set",1,SWIGTYPE_p_kernpair);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("KernPair_sc_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->sc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_sc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("kernpair::sc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::sc",1,"struct kernpair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_sc_get",1,SWIGTYPE_p_kernpair);
  }
  
  result = (struct splinechar *) ((arg1)->sc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_off_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("kernpair::off",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::off",1,"struct kernpair *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("kernpair::off",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_off_set",1,SWIGTYPE_p_kernpair);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->off = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_off_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  int16 result;
  
  SWIG_check_num_args("kernpair::off",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::off",1,"struct kernpair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_off_get",1,SWIGTYPE_p_kernpair);
  }
  
  result = (int16) ((arg1)->off);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_kcid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("kernpair::kcid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::kcid",1,"struct kernpair *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("kernpair::kcid",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_kcid_set",1,SWIGTYPE_p_kernpair);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->kcid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_kcid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("kernpair::kcid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::kcid",1,"struct kernpair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_kcid_get",1,SWIGTYPE_p_kernpair);
  }
  
  result = (uint16) ((arg1)->kcid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  struct kernpair *arg2 = (struct kernpair *) 0 ;
  
  SWIG_check_num_args("kernpair::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::next",1,"struct kernpair *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernpair::next",2,"struct kernpair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_next_set",1,SWIGTYPE_p_kernpair);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernpair,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("KernPair_next_set",2,SWIGTYPE_p_kernpair);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPair_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *arg1 = (struct kernpair *) 0 ;
  struct kernpair *result = 0 ;
  
  SWIG_check_num_args("kernpair::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernpair::next",1,"struct kernpair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPair_next_get",1,SWIGTYPE_p_kernpair);
  }
  
  result = (struct kernpair *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernpair,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_KernPair(lua_State* L) {
  int SWIG_arg = 0;
  struct kernpair *result = 0 ;
  
  SWIG_check_num_args("kernpair::kernpair",0,0)
  result = (struct kernpair *)calloc(1, sizeof(struct kernpair));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernpair,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_KernPair(void *obj) {
struct kernpair *arg1 = (struct kernpair *) obj;
free((char *) arg1);
}
static swig_lua_method swig_kernpair_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_kernpair_attributes[] = {
    { "subtable", _wrap_KernPair_subtable_get, _wrap_KernPair_subtable_set},
    { "sc", _wrap_KernPair_sc_get, _wrap_KernPair_sc_set},
    { "off", _wrap_KernPair_off_get, _wrap_KernPair_off_set},
    { "kcid", _wrap_KernPair_kcid_get, _wrap_KernPair_kcid_set},
    { "next", _wrap_KernPair_next_get, _wrap_KernPair_next_set},
    {0,0,0}
};
static swig_lua_class *swig_kernpair_bases[] = {0};
static const char *swig_kernpair_base_names[] = {0};
static swig_lua_class _wrap_class_kernpair = { "KernPair", &SWIGTYPE_p_kernpair,_wrap_new_KernPair, swig_delete_KernPair, swig_kernpair_methods, swig_kernpair_attributes, swig_kernpair_bases, swig_kernpair_base_names };

static int _wrap_KernClass_first_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("kernclass::first_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::first_cnt",1,"struct kernclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("kernclass::first_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_first_cnt_set",1,SWIGTYPE_p_kernclass);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->first_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_first_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  int result;
  
  SWIG_check_num_args("kernclass::first_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::first_cnt",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_first_cnt_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (int) ((arg1)->first_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_second_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("kernclass::second_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::second_cnt",1,"struct kernclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("kernclass::second_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_second_cnt_set",1,SWIGTYPE_p_kernclass);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->second_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_second_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  int result;
  
  SWIG_check_num_args("kernclass::second_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::second_cnt",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_second_cnt_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (int) ((arg1)->second_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_firsts_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("kernclass::firsts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::firsts",1,"struct kernclass *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernclass::firsts",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_firsts_set",1,SWIGTYPE_p_kernclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("KernClass_firsts_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->firsts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_firsts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("kernclass::firsts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::firsts",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_firsts_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (char **) ((arg1)->firsts);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_seconds_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("kernclass::seconds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::seconds",1,"struct kernclass *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernclass::seconds",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_seconds_set",1,SWIGTYPE_p_kernclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("KernClass_seconds_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->seconds = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_seconds_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("kernclass::seconds",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::seconds",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_seconds_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (char **) ((arg1)->seconds);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_subtable_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("kernclass::subtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::subtable",1,"struct kernclass *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernclass::subtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_subtable_set",1,SWIGTYPE_p_kernclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("KernClass_subtable_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->subtable = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_subtable_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("kernclass::subtable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::subtable",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_subtable_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (struct lookup_subtable *) ((arg1)->subtable);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_kcid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("kernclass::kcid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::kcid",1,"struct kernclass *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("kernclass::kcid",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_kcid_set",1,SWIGTYPE_p_kernclass);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->kcid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_kcid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("kernclass::kcid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::kcid",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_kcid_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (uint16) ((arg1)->kcid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_offsets_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  int16 *arg2 = (int16 *) 0 ;
  
  SWIG_check_num_args("kernclass::offsets",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::offsets",1,"struct kernclass *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernclass::offsets",2,"int16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_offsets_set",1,SWIGTYPE_p_kernclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("KernClass_offsets_set",2,SWIGTYPE_p_short);
  }
  
  if (arg1) (arg1)->offsets = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_offsets_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  int16 *result = 0 ;
  
  SWIG_check_num_args("kernclass::offsets",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::offsets",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_offsets_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (int16 *) ((arg1)->offsets);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  struct kernclass *arg2 = (struct kernclass *) 0 ;
  
  SWIG_check_num_args("kernclass::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::next",1,"struct kernclass *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("kernclass::next",2,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_next_set",1,SWIGTYPE_p_kernclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("KernClass_next_set",2,SWIGTYPE_p_kernclass);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClass_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *arg1 = (struct kernclass *) 0 ;
  struct kernclass *result = 0 ;
  
  SWIG_check_num_args("kernclass::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("kernclass::next",1,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClass_next_get",1,SWIGTYPE_p_kernclass);
  }
  
  result = (struct kernclass *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_KernClass(lua_State* L) {
  int SWIG_arg = 0;
  struct kernclass *result = 0 ;
  
  SWIG_check_num_args("kernclass::kernclass",0,0)
  result = (struct kernclass *)calloc(1, sizeof(struct kernclass));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclass,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_KernClass(void *obj) {
struct kernclass *arg1 = (struct kernclass *) obj;
free((char *) arg1);
}
static swig_lua_method swig_kernclass_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_kernclass_attributes[] = {
    { "first_cnt", _wrap_KernClass_first_cnt_get, _wrap_KernClass_first_cnt_set},
    { "second_cnt", _wrap_KernClass_second_cnt_get, _wrap_KernClass_second_cnt_set},
    { "firsts", _wrap_KernClass_firsts_get, _wrap_KernClass_firsts_set},
    { "seconds", _wrap_KernClass_seconds_get, _wrap_KernClass_seconds_set},
    { "subtable", _wrap_KernClass_subtable_get, _wrap_KernClass_subtable_set},
    { "kcid", _wrap_KernClass_kcid_get, _wrap_KernClass_kcid_set},
    { "offsets", _wrap_KernClass_offsets_get, _wrap_KernClass_offsets_set},
    { "next", _wrap_KernClass_next_get, _wrap_KernClass_next_set},
    {0,0,0}
};
static swig_lua_class *swig_kernclass_bases[] = {0};
static const char *swig_kernclass_base_names[] = {0};
static swig_lua_class _wrap_class_kernclass = { "KernClass", &SWIGTYPE_p_kernclass,_wrap_new_KernClass, swig_delete_KernClass, swig_kernclass_methods, swig_kernclass_attributes, swig_kernclass_bases, swig_kernclass_base_names };

static int _wrap_vr_xoff_set(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("vr::xoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::xoff",1,"struct vr *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("vr::xoff",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_xoff_set",1,SWIGTYPE_p_vr);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->xoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vr_xoff_get(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 result;
  
  SWIG_check_num_args("vr::xoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::xoff",1,"struct vr *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_xoff_get",1,SWIGTYPE_p_vr);
  }
  
  result = (int16) ((arg1)->xoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vr_yoff_set(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("vr::yoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::yoff",1,"struct vr *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("vr::yoff",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_yoff_set",1,SWIGTYPE_p_vr);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->yoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vr_yoff_get(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 result;
  
  SWIG_check_num_args("vr::yoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::yoff",1,"struct vr *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_yoff_get",1,SWIGTYPE_p_vr);
  }
  
  result = (int16) ((arg1)->yoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vr_h_adv_off_set(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("vr::h_adv_off",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::h_adv_off",1,"struct vr *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("vr::h_adv_off",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_h_adv_off_set",1,SWIGTYPE_p_vr);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->h_adv_off = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vr_h_adv_off_get(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 result;
  
  SWIG_check_num_args("vr::h_adv_off",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::h_adv_off",1,"struct vr *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_h_adv_off_get",1,SWIGTYPE_p_vr);
  }
  
  result = (int16) ((arg1)->h_adv_off);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vr_v_adv_off_set(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("vr::v_adv_off",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::v_adv_off",1,"struct vr *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("vr::v_adv_off",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_v_adv_off_set",1,SWIGTYPE_p_vr);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->v_adv_off = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_vr_v_adv_off_get(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *arg1 = (struct vr *) 0 ;
  int16 result;
  
  SWIG_check_num_args("vr::v_adv_off",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("vr::v_adv_off",1,"struct vr *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("vr_v_adv_off_get",1,SWIGTYPE_p_vr);
  }
  
  result = (int16) ((arg1)->v_adv_off);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_vr(lua_State* L) {
  int SWIG_arg = 0;
  struct vr *result = 0 ;
  
  SWIG_check_num_args("vr::vr",0,0)
  result = (struct vr *)calloc(1, sizeof(struct vr));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_vr,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_vr(void *obj) {
struct vr *arg1 = (struct vr *) obj;
free((char *) arg1);
}
static swig_lua_method swig_vr_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_vr_attributes[] = {
    { "xoff", _wrap_vr_xoff_get, _wrap_vr_xoff_set},
    { "yoff", _wrap_vr_yoff_get, _wrap_vr_yoff_set},
    { "h_adv_off", _wrap_vr_h_adv_off_get, _wrap_vr_h_adv_off_set},
    { "v_adv_off", _wrap_vr_v_adv_off_get, _wrap_vr_v_adv_off_set},
    {0,0,0}
};
static swig_lua_class *swig_vr_bases[] = {0};
static const char *swig_vr_base_names[] = {0};
static swig_lua_class _wrap_class_vr = { "vr", &SWIGTYPE_p_vr,_wrap_new_vr, swig_delete_vr, swig_vr_methods, swig_vr_attributes, swig_vr_bases, swig_vr_base_names };

static int _wrap_PST_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("generic_pst::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::ticked",1,"struct generic_pst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_pst::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_ticked_set",1,SWIGTYPE_p_generic_pst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("generic_pst::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::ticked",1,"struct generic_pst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_ticked_get",1,SWIGTYPE_p_generic_pst);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_temporary_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("generic_pst::temporary",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::temporary",1,"struct generic_pst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_pst::temporary",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_temporary_set",1,SWIGTYPE_p_generic_pst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->temporary = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_temporary_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("generic_pst::temporary",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::temporary",1,"struct generic_pst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_temporary_get",1,SWIGTYPE_p_generic_pst);
  }
  
  result = (unsigned int) ((arg1)->temporary);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("generic_pst::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::type",1,"struct generic_pst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_pst::type",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_type_set",1,SWIGTYPE_p_generic_pst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("generic_pst::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::type",1,"struct generic_pst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_type_get",1,SWIGTYPE_p_generic_pst);
  }
  
  result = (uint8) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_subtable_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("generic_pst::subtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::subtable",1,"struct generic_pst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_pst::subtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_subtable_set",1,SWIGTYPE_p_generic_pst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("PST_subtable_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->subtable = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_subtable_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("generic_pst::subtable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::subtable",1,"struct generic_pst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_subtable_get",1,SWIGTYPE_p_generic_pst);
  }
  
  result = (struct lookup_subtable *) ((arg1)->subtable);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  struct generic_pst *arg2 = (struct generic_pst *) 0 ;
  
  SWIG_check_num_args("generic_pst::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::next",1,"struct generic_pst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_pst::next",2,"struct generic_pst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_next_set",1,SWIGTYPE_p_generic_pst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_pst,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("PST_next_set",2,SWIGTYPE_p_generic_pst);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  struct generic_pst *result = 0 ;
  
  SWIG_check_num_args("generic_pst::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::next",1,"struct generic_pst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_next_get",1,SWIGTYPE_p_generic_pst);
  }
  
  result = (struct generic_pst *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_pst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *arg1 = (struct generic_pst *) 0 ;
  PST_u *result = 0 ;
  
  SWIG_check_num_args("generic_pst::u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_pst::u",1,"struct generic_pst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PST_u_get",1,SWIGTYPE_p_generic_pst);
  }
  
  result = (PST_u *)& ((arg1)->u);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_pst *result = 0 ;
  
  SWIG_check_num_args("generic_pst::generic_pst",0,0)
  result = (struct generic_pst *)calloc(1, sizeof(struct generic_pst));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_pst,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST(void *obj) {
struct generic_pst *arg1 = (struct generic_pst *) obj;
free((char *) arg1);
}
static swig_lua_method swig_generic_pst_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_generic_pst_attributes[] = {
    { "ticked", _wrap_PST_ticked_get, _wrap_PST_ticked_set},
    { "temporary", _wrap_PST_temporary_get, _wrap_PST_temporary_set},
    { "type", _wrap_PST_type_get, _wrap_PST_type_set},
    { "subtable", _wrap_PST_subtable_get, _wrap_PST_subtable_set},
    { "next", _wrap_PST_next_get, _wrap_PST_next_set},
    { "u", _wrap_PST_u_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_generic_pst_bases[] = {0};
static const char *swig_generic_pst_base_names[] = {0};
static swig_lua_class _wrap_class_generic_pst = { "PST", &SWIGTYPE_p_generic_pst,_wrap_new_PST, swig_delete_PST, swig_generic_pst_methods, swig_generic_pst_attributes, swig_generic_pst_bases, swig_generic_pst_base_names };

static int _wrap_PST_u_pos_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  struct vr *arg2 = (struct vr *) 0 ;
  
  SWIG_check_num_args("PST_u::pos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::pos",1,"PST_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PST_u::pos",2,"struct vr *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_pos_set",1,SWIGTYPE_p_PST_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("PST_u_pos_set",2,SWIGTYPE_p_vr);
  }
  
  if (arg1) (arg1)->pos = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_pos_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  struct vr *result = 0 ;
  
  SWIG_check_num_args("PST_u::pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::pos",1,"PST_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_pos_get",1,SWIGTYPE_p_PST_u);
  }
  
  result = (struct vr *)& ((arg1)->pos);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_vr,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_pair_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  PST_u_pair *result = 0 ;
  
  SWIG_check_num_args("PST_u::pair",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::pair",1,"PST_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_pair_get",1,SWIGTYPE_p_PST_u);
  }
  
  result = (PST_u_pair *)& ((arg1)->pair);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_pair,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_subs_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  PST_u_subs *result = 0 ;
  
  SWIG_check_num_args("PST_u::subs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::subs",1,"PST_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_subs_get",1,SWIGTYPE_p_PST_u);
  }
  
  result = (PST_u_subs *)& ((arg1)->subs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_subs,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_mult_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  PST_u_mult *result = 0 ;
  
  SWIG_check_num_args("PST_u::mult",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::mult",1,"PST_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_mult_get",1,SWIGTYPE_p_PST_u);
  }
  
  result = (PST_u_mult *)& ((arg1)->mult);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_mult,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_alt_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  PST_u_alt *result = 0 ;
  
  SWIG_check_num_args("PST_u::alt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::alt",1,"PST_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_alt_get",1,SWIGTYPE_p_PST_u);
  }
  
  result = (PST_u_alt *)& ((arg1)->alt);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_alt,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lig_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  PST_u_lig *result = 0 ;
  
  SWIG_check_num_args("PST_u::lig",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::lig",1,"PST_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_lig_get",1,SWIGTYPE_p_PST_u);
  }
  
  result = (PST_u_lig *)& ((arg1)->lig);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_lig,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lcaret_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *arg1 = (PST_u *) 0 ;
  PST_u_lcaret *result = 0 ;
  
  SWIG_check_num_args("PST_u::lcaret",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u::lcaret",1,"PST_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u,0))){
    SWIG_fail_ptr("PST_u_lcaret_get",1,SWIGTYPE_p_PST_u);
  }
  
  result = (PST_u_lcaret *)& ((arg1)->lcaret);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_lcaret,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST_u(lua_State* L) {
  int SWIG_arg = 0;
  PST_u *result = 0 ;
  
  SWIG_check_num_args("PST_u::PST_u",0,0)
  result = (PST_u *)calloc(1, sizeof(PST_u));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST_u(void *obj) {
PST_u *arg1 = (PST_u *) obj;
free((char *) arg1);
}
static swig_lua_method swig_PST_u_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_PST_u_attributes[] = {
    { "pos", _wrap_PST_u_pos_get, _wrap_PST_u_pos_set},
    { "pair", _wrap_PST_u_pair_get, SWIG_Lua_set_immutable},
    { "subs", _wrap_PST_u_subs_get, SWIG_Lua_set_immutable},
    { "mult", _wrap_PST_u_mult_get, SWIG_Lua_set_immutable},
    { "alt", _wrap_PST_u_alt_get, SWIG_Lua_set_immutable},
    { "lig", _wrap_PST_u_lig_get, SWIG_Lua_set_immutable},
    { "lcaret", _wrap_PST_u_lcaret_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_PST_u_bases[] = {0};
static const char *swig_PST_u_base_names[] = {0};
static swig_lua_class _wrap_class_PST_u = { "PST_u", &SWIGTYPE_p_PST_u,_wrap_new_PST_u, swig_delete_PST_u, swig_PST_u_methods, swig_PST_u_attributes, swig_PST_u_bases, swig_PST_u_base_names };

static int _wrap_PST_u_lcaret_carets_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lcaret *arg1 = (PST_u_lcaret *) 0 ;
  int16 *arg2 = (int16 *) 0 ;
  
  SWIG_check_num_args("PST_u_lcaret::carets",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lcaret::carets",1,"PST_u_lcaret *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PST_u_lcaret::carets",2,"int16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lcaret,0))){
    SWIG_fail_ptr("PST_u_lcaret_carets_set",1,SWIGTYPE_p_PST_u_lcaret);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("PST_u_lcaret_carets_set",2,SWIGTYPE_p_short);
  }
  
  if (arg1) (arg1)->carets = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lcaret_carets_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lcaret *arg1 = (PST_u_lcaret *) 0 ;
  int16 *result = 0 ;
  
  SWIG_check_num_args("PST_u_lcaret::carets",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lcaret::carets",1,"PST_u_lcaret *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lcaret,0))){
    SWIG_fail_ptr("PST_u_lcaret_carets_get",1,SWIGTYPE_p_PST_u_lcaret);
  }
  
  result = (int16 *) ((arg1)->carets);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lcaret_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lcaret *arg1 = (PST_u_lcaret *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("PST_u_lcaret::cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lcaret::cnt",1,"PST_u_lcaret *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PST_u_lcaret::cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lcaret,0))){
    SWIG_fail_ptr("PST_u_lcaret_cnt_set",1,SWIGTYPE_p_PST_u_lcaret);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lcaret_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lcaret *arg1 = (PST_u_lcaret *) 0 ;
  int result;
  
  SWIG_check_num_args("PST_u_lcaret::cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lcaret::cnt",1,"PST_u_lcaret *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lcaret,0))){
    SWIG_fail_ptr("PST_u_lcaret_cnt_get",1,SWIGTYPE_p_PST_u_lcaret);
  }
  
  result = (int) ((arg1)->cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST_u_lcaret(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lcaret *result = 0 ;
  
  SWIG_check_num_args("PST_u_lcaret::PST_u_lcaret",0,0)
  result = (PST_u_lcaret *)calloc(1, sizeof(PST_u_lcaret));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_lcaret,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST_u_lcaret(void *obj) {
PST_u_lcaret *arg1 = (PST_u_lcaret *) obj;
free((char *) arg1);
}
static swig_lua_method swig_PST_u_lcaret_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_PST_u_lcaret_attributes[] = {
    { "carets", _wrap_PST_u_lcaret_carets_get, _wrap_PST_u_lcaret_carets_set},
    { "cnt", _wrap_PST_u_lcaret_cnt_get, _wrap_PST_u_lcaret_cnt_set},
    {0,0,0}
};
static swig_lua_class *swig_PST_u_lcaret_bases[] = {0};
static const char *swig_PST_u_lcaret_base_names[] = {0};
static swig_lua_class _wrap_class_PST_u_lcaret = { "PST_u_lcaret", &SWIGTYPE_p_PST_u_lcaret,_wrap_new_PST_u_lcaret, swig_delete_PST_u_lcaret, swig_PST_u_lcaret_methods, swig_PST_u_lcaret_attributes, swig_PST_u_lcaret_bases, swig_PST_u_lcaret_base_names };

static int _wrap_PST_u_lig_components_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lig *arg1 = (PST_u_lig *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("PST_u_lig::components",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lig::components",1,"PST_u_lig *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PST_u_lig::components",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lig,0))){
    SWIG_fail_ptr("PST_u_lig_components_set",1,SWIGTYPE_p_PST_u_lig);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->components);
    if (arg2) {
      arg1->components = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->components, (const char *)arg2);
    } else {
      arg1->components = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lig_components_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lig *arg1 = (PST_u_lig *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("PST_u_lig::components",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lig::components",1,"PST_u_lig *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lig,0))){
    SWIG_fail_ptr("PST_u_lig_components_get",1,SWIGTYPE_p_PST_u_lig);
  }
  
  result = (char *) ((arg1)->components);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lig_lig_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lig *arg1 = (PST_u_lig *) 0 ;
  struct splinechar *arg2 = (struct splinechar *) 0 ;
  
  SWIG_check_num_args("PST_u_lig::lig",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lig::lig",1,"PST_u_lig *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PST_u_lig::lig",2,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lig,0))){
    SWIG_fail_ptr("PST_u_lig_lig_set",1,SWIGTYPE_p_PST_u_lig);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("PST_u_lig_lig_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->lig = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_lig_lig_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lig *arg1 = (PST_u_lig *) 0 ;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("PST_u_lig::lig",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_lig::lig",1,"PST_u_lig *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_lig,0))){
    SWIG_fail_ptr("PST_u_lig_lig_get",1,SWIGTYPE_p_PST_u_lig);
  }
  
  result = (struct splinechar *) ((arg1)->lig);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST_u_lig(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_lig *result = 0 ;
  
  SWIG_check_num_args("PST_u_lig::PST_u_lig",0,0)
  result = (PST_u_lig *)calloc(1, sizeof(PST_u_lig));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_lig,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST_u_lig(void *obj) {
PST_u_lig *arg1 = (PST_u_lig *) obj;
free((char *) arg1);
}
static swig_lua_method swig_PST_u_lig_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_PST_u_lig_attributes[] = {
    { "components", _wrap_PST_u_lig_components_get, _wrap_PST_u_lig_components_set},
    { "lig", _wrap_PST_u_lig_lig_get, _wrap_PST_u_lig_lig_set},
    {0,0,0}
};
static swig_lua_class *swig_PST_u_lig_bases[] = {0};
static const char *swig_PST_u_lig_base_names[] = {0};
static swig_lua_class _wrap_class_PST_u_lig = { "PST_u_lig", &SWIGTYPE_p_PST_u_lig,_wrap_new_PST_u_lig, swig_delete_PST_u_lig, swig_PST_u_lig_methods, swig_PST_u_lig_attributes, swig_PST_u_lig_bases, swig_PST_u_lig_base_names };

static int _wrap_PST_u_alt_components_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_alt *arg1 = (PST_u_alt *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("PST_u_alt::components",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_alt::components",1,"PST_u_alt *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PST_u_alt::components",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_alt,0))){
    SWIG_fail_ptr("PST_u_alt_components_set",1,SWIGTYPE_p_PST_u_alt);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->components);
    if (arg2) {
      arg1->components = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->components, (const char *)arg2);
    } else {
      arg1->components = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_alt_components_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_alt *arg1 = (PST_u_alt *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("PST_u_alt::components",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_alt::components",1,"PST_u_alt *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_alt,0))){
    SWIG_fail_ptr("PST_u_alt_components_get",1,SWIGTYPE_p_PST_u_alt);
  }
  
  result = (char *) ((arg1)->components);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST_u_alt(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_alt *result = 0 ;
  
  SWIG_check_num_args("PST_u_alt::PST_u_alt",0,0)
  result = (PST_u_alt *)calloc(1, sizeof(PST_u_alt));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_alt,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST_u_alt(void *obj) {
PST_u_alt *arg1 = (PST_u_alt *) obj;
free((char *) arg1);
}
static swig_lua_method swig_PST_u_alt_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_PST_u_alt_attributes[] = {
    { "components", _wrap_PST_u_alt_components_get, _wrap_PST_u_alt_components_set},
    {0,0,0}
};
static swig_lua_class *swig_PST_u_alt_bases[] = {0};
static const char *swig_PST_u_alt_base_names[] = {0};
static swig_lua_class _wrap_class_PST_u_alt = { "PST_u_alt", &SWIGTYPE_p_PST_u_alt,_wrap_new_PST_u_alt, swig_delete_PST_u_alt, swig_PST_u_alt_methods, swig_PST_u_alt_attributes, swig_PST_u_alt_bases, swig_PST_u_alt_base_names };

static int _wrap_PST_u_mult_components_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_mult *arg1 = (PST_u_mult *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("PST_u_mult::components",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_mult::components",1,"PST_u_mult *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PST_u_mult::components",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_mult,0))){
    SWIG_fail_ptr("PST_u_mult_components_set",1,SWIGTYPE_p_PST_u_mult);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->components);
    if (arg2) {
      arg1->components = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->components, (const char *)arg2);
    } else {
      arg1->components = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_mult_components_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_mult *arg1 = (PST_u_mult *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("PST_u_mult::components",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_mult::components",1,"PST_u_mult *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_mult,0))){
    SWIG_fail_ptr("PST_u_mult_components_get",1,SWIGTYPE_p_PST_u_mult);
  }
  
  result = (char *) ((arg1)->components);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST_u_mult(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_mult *result = 0 ;
  
  SWIG_check_num_args("PST_u_mult::PST_u_mult",0,0)
  result = (PST_u_mult *)calloc(1, sizeof(PST_u_mult));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_mult,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST_u_mult(void *obj) {
PST_u_mult *arg1 = (PST_u_mult *) obj;
free((char *) arg1);
}
static swig_lua_method swig_PST_u_mult_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_PST_u_mult_attributes[] = {
    { "components", _wrap_PST_u_mult_components_get, _wrap_PST_u_mult_components_set},
    {0,0,0}
};
static swig_lua_class *swig_PST_u_mult_bases[] = {0};
static const char *swig_PST_u_mult_base_names[] = {0};
static swig_lua_class _wrap_class_PST_u_mult = { "PST_u_mult", &SWIGTYPE_p_PST_u_mult,_wrap_new_PST_u_mult, swig_delete_PST_u_mult, swig_PST_u_mult_methods, swig_PST_u_mult_attributes, swig_PST_u_mult_bases, swig_PST_u_mult_base_names };

static int _wrap_PST_u_subs_variant_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_subs *arg1 = (PST_u_subs *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("PST_u_subs::variant",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_subs::variant",1,"PST_u_subs *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PST_u_subs::variant",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_subs,0))){
    SWIG_fail_ptr("PST_u_subs_variant_set",1,SWIGTYPE_p_PST_u_subs);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->variant);
    if (arg2) {
      arg1->variant = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->variant, (const char *)arg2);
    } else {
      arg1->variant = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_subs_variant_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_subs *arg1 = (PST_u_subs *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("PST_u_subs::variant",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_subs::variant",1,"PST_u_subs *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_subs,0))){
    SWIG_fail_ptr("PST_u_subs_variant_get",1,SWIGTYPE_p_PST_u_subs);
  }
  
  result = (char *) ((arg1)->variant);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST_u_subs(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_subs *result = 0 ;
  
  SWIG_check_num_args("PST_u_subs::PST_u_subs",0,0)
  result = (PST_u_subs *)calloc(1, sizeof(PST_u_subs));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_subs,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST_u_subs(void *obj) {
PST_u_subs *arg1 = (PST_u_subs *) obj;
free((char *) arg1);
}
static swig_lua_method swig_PST_u_subs_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_PST_u_subs_attributes[] = {
    { "variant", _wrap_PST_u_subs_variant_get, _wrap_PST_u_subs_variant_set},
    {0,0,0}
};
static swig_lua_class *swig_PST_u_subs_bases[] = {0};
static const char *swig_PST_u_subs_base_names[] = {0};
static swig_lua_class _wrap_class_PST_u_subs = { "PST_u_subs", &SWIGTYPE_p_PST_u_subs,_wrap_new_PST_u_subs, swig_delete_PST_u_subs, swig_PST_u_subs_methods, swig_PST_u_subs_attributes, swig_PST_u_subs_bases, swig_PST_u_subs_base_names };

static int _wrap_PST_u_pair_paired_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_pair *arg1 = (PST_u_pair *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("PST_u_pair::paired",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_pair::paired",1,"PST_u_pair *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PST_u_pair::paired",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_pair,0))){
    SWIG_fail_ptr("PST_u_pair_paired_set",1,SWIGTYPE_p_PST_u_pair);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->paired);
    if (arg2) {
      arg1->paired = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->paired, (const char *)arg2);
    } else {
      arg1->paired = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_pair_paired_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_pair *arg1 = (PST_u_pair *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("PST_u_pair::paired",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_pair::paired",1,"PST_u_pair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_pair,0))){
    SWIG_fail_ptr("PST_u_pair_paired_get",1,SWIGTYPE_p_PST_u_pair);
  }
  
  result = (char *) ((arg1)->paired);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_pair_vr_set(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_pair *arg1 = (PST_u_pair *) 0 ;
  struct vr *arg2 = (struct vr *) 0 ;
  
  SWIG_check_num_args("PST_u_pair::vr",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_pair::vr",1,"PST_u_pair *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PST_u_pair::vr",2,"struct vr *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_pair,0))){
    SWIG_fail_ptr("PST_u_pair_vr_set",1,SWIGTYPE_p_PST_u_pair);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_vr,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("PST_u_pair_vr_set",2,SWIGTYPE_p_vr);
  }
  
  if (arg1) (arg1)->vr = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PST_u_pair_vr_get(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_pair *arg1 = (PST_u_pair *) 0 ;
  struct vr *result = 0 ;
  
  SWIG_check_num_args("PST_u_pair::vr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PST_u_pair::vr",1,"PST_u_pair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_PST_u_pair,0))){
    SWIG_fail_ptr("PST_u_pair_vr_get",1,SWIGTYPE_p_PST_u_pair);
  }
  
  result = (struct vr *) ((arg1)->vr);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_vr,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_PST_u_pair(lua_State* L) {
  int SWIG_arg = 0;
  PST_u_pair *result = 0 ;
  
  SWIG_check_num_args("PST_u_pair::PST_u_pair",0,0)
  result = (PST_u_pair *)calloc(1, sizeof(PST_u_pair));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_PST_u_pair,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_PST_u_pair(void *obj) {
PST_u_pair *arg1 = (PST_u_pair *) obj;
free((char *) arg1);
}
static swig_lua_method swig_PST_u_pair_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_PST_u_pair_attributes[] = {
    { "paired", _wrap_PST_u_pair_paired_get, _wrap_PST_u_pair_paired_set},
    { "vr", _wrap_PST_u_pair_vr_get, _wrap_PST_u_pair_vr_set},
    {0,0,0}
};
static swig_lua_class *swig_PST_u_pair_bases[] = {0};
static const char *swig_PST_u_pair_base_names[] = {0};
static swig_lua_class _wrap_class_PST_u_pair = { "PST_u_pair", &SWIGTYPE_p_PST_u_pair,_wrap_new_PST_u_pair, swig_delete_PST_u_pair, swig_PST_u_pair_methods, swig_PST_u_pair_attributes, swig_PST_u_pair_bases, swig_PST_u_pair_base_names };

static int _wrap_LigList_lig_set(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  PST *arg2 = (PST *) 0 ;
  
  SWIG_check_num_args("liglist::lig",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::lig",1,"struct liglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("liglist::lig",2,"PST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_lig_set",1,SWIGTYPE_p_liglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_pst,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("LigList_lig_set",2,SWIGTYPE_p_generic_pst);
  }
  
  if (arg1) (arg1)->lig = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_lig_get(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  PST *result = 0 ;
  
  SWIG_check_num_args("liglist::lig",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::lig",1,"struct liglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_lig_get",1,SWIGTYPE_p_liglist);
  }
  
  result = (PST *) ((arg1)->lig);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_pst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_first_set(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  struct splinechar *arg2 = (struct splinechar *) 0 ;
  
  SWIG_check_num_args("liglist::first",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::first",1,"struct liglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("liglist::first",2,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_first_set",1,SWIGTYPE_p_liglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("LigList_first_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->first = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_first_get(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("liglist::first",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::first",1,"struct liglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_first_get",1,SWIGTYPE_p_liglist);
  }
  
  result = (struct splinechar *) ((arg1)->first);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_components_set(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  struct splinecharlist *arg2 = (struct splinecharlist *) 0 ;
  
  SWIG_check_num_args("liglist::components",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::components",1,"struct liglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("liglist::components",2,"struct splinecharlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_components_set",1,SWIGTYPE_p_liglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinecharlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("LigList_components_set",2,SWIGTYPE_p_splinecharlist);
  }
  
  if (arg1) (arg1)->components = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_components_get(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  struct splinecharlist *result = 0 ;
  
  SWIG_check_num_args("liglist::components",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::components",1,"struct liglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_components_get",1,SWIGTYPE_p_liglist);
  }
  
  result = (struct splinecharlist *) ((arg1)->components);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinecharlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  struct liglist *arg2 = (struct liglist *) 0 ;
  
  SWIG_check_num_args("liglist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::next",1,"struct liglist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("liglist::next",2,"struct liglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_next_set",1,SWIGTYPE_p_liglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_liglist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("LigList_next_set",2,SWIGTYPE_p_liglist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  struct liglist *result = 0 ;
  
  SWIG_check_num_args("liglist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::next",1,"struct liglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_next_get",1,SWIGTYPE_p_liglist);
  }
  
  result = (struct liglist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_liglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_ccnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("liglist::ccnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::ccnt",1,"struct liglist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("liglist::ccnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_ccnt_set",1,SWIGTYPE_p_liglist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ccnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LigList_ccnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *arg1 = (struct liglist *) 0 ;
  int result;
  
  SWIG_check_num_args("liglist::ccnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("liglist::ccnt",1,"struct liglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_liglist,0))){
    SWIG_fail_ptr("LigList_ccnt_get",1,SWIGTYPE_p_liglist);
  }
  
  result = (int) ((arg1)->ccnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LigList(lua_State* L) {
  int SWIG_arg = 0;
  struct liglist *result = 0 ;
  
  SWIG_check_num_args("liglist::liglist",0,0)
  result = (struct liglist *)calloc(1, sizeof(struct liglist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_liglist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LigList(void *obj) {
struct liglist *arg1 = (struct liglist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_liglist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_liglist_attributes[] = {
    { "lig", _wrap_LigList_lig_get, _wrap_LigList_lig_set},
    { "first", _wrap_LigList_first_get, _wrap_LigList_first_set},
    { "components", _wrap_LigList_components_get, _wrap_LigList_components_set},
    { "next", _wrap_LigList_next_get, _wrap_LigList_next_set},
    { "ccnt", _wrap_LigList_ccnt_get, _wrap_LigList_ccnt_set},
    {0,0,0}
};
static swig_lua_class *swig_liglist_bases[] = {0};
static const char *swig_liglist_base_names[] = {0};
static swig_lua_class _wrap_class_liglist = { "LigList", &SWIGTYPE_p_liglist,_wrap_new_LigList, swig_delete_LigList, swig_liglist_methods, swig_liglist_attributes, swig_liglist_bases, swig_liglist_base_names };

static int _wrap_FPST_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_fpst::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::type",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::type",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_type_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_fpst::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::type",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_type_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint16) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_format_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_fpst::format",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::format",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::format",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_format_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->format = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_format_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_fpst::format",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::format",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_format_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint16) ((arg1)->format);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_subtable_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("generic_fpst::subtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::subtable",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::subtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_subtable_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FPST_subtable_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->subtable = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_subtable_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("generic_fpst::subtable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::subtable",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_subtable_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (struct lookup_subtable *) ((arg1)->subtable);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  struct generic_fpst *arg2 = (struct generic_fpst *) 0 ;
  
  SWIG_check_num_args("generic_fpst::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::next",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::next",2,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_next_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_fpst,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FPST_next_set",2,SWIGTYPE_p_generic_fpst);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  struct generic_fpst *result = 0 ;
  
  SWIG_check_num_args("generic_fpst::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::next",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_next_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (struct generic_fpst *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_fpst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_nccnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_fpst::nccnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::nccnt",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::nccnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_nccnt_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->nccnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_nccnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_fpst::nccnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::nccnt",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_nccnt_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint16) ((arg1)->nccnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_bccnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_fpst::bccnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::bccnt",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::bccnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_bccnt_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->bccnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_bccnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_fpst::bccnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::bccnt",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_bccnt_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint16) ((arg1)->bccnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_fccnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_fpst::fccnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::fccnt",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::fccnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_fccnt_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->fccnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_fccnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_fpst::fccnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::fccnt",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_fccnt_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint16) ((arg1)->fccnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rule_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_fpst::rule_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::rule_cnt",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::rule_cnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_rule_cnt_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->rule_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rule_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_fpst::rule_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::rule_cnt",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_rule_cnt_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint16) ((arg1)->rule_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_nclass_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("generic_fpst::nclass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::nclass",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::nclass",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_nclass_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_nclass_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->nclass = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_nclass_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("generic_fpst::nclass",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::nclass",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_nclass_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (char **) ((arg1)->nclass);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_bclass_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("generic_fpst::bclass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::bclass",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::bclass",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_bclass_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_bclass_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->bclass = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_bclass_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("generic_fpst::bclass",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::bclass",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_bclass_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (char **) ((arg1)->bclass);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_fclass_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("generic_fpst::fclass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::fclass",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::fclass",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_fclass_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_fclass_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->fclass = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_fclass_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("generic_fpst::fclass",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::fclass",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_fclass_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (char **) ((arg1)->fclass);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("generic_fpst::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::ticked",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::ticked",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_ticked_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("generic_fpst::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::ticked",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_ticked_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint8) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_effectively_by_glyphs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("generic_fpst::effectively_by_glyphs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::effectively_by_glyphs",1,"struct generic_fpst *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_fpst::effectively_by_glyphs",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_effectively_by_glyphs_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->effectively_by_glyphs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_effectively_by_glyphs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("generic_fpst::effectively_by_glyphs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::effectively_by_glyphs",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_effectively_by_glyphs_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (uint8) ((arg1)->effectively_by_glyphs);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_nclassnames_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("generic_fpst::nclassnames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::nclassnames",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::nclassnames",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_nclassnames_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_nclassnames_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->nclassnames = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_nclassnames_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("generic_fpst::nclassnames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::nclassnames",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_nclassnames_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (char **) ((arg1)->nclassnames);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_bclassnames_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("generic_fpst::bclassnames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::bclassnames",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::bclassnames",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_bclassnames_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_bclassnames_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->bclassnames = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_bclassnames_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("generic_fpst::bclassnames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::bclassnames",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_bclassnames_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (char **) ((arg1)->bclassnames);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_fclassnames_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("generic_fpst::fclassnames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::fclassnames",1,"struct generic_fpst *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_fpst::fclassnames",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_fclassnames_set",1,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_fclassnames_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->fclassnames = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_fclassnames_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("generic_fpst::fclassnames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::fclassnames",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_fclassnames_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (char **) ((arg1)->fclassnames);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *arg1 = (struct generic_fpst *) 0 ;
  FPST_rules *result = 0 ;
  
  SWIG_check_num_args("generic_fpst::rules",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_fpst::rules",1,"struct generic_fpst *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPST_rules_get",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (FPST_rules *) ((arg1)->rules);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_fpst *result = 0 ;
  
  SWIG_check_num_args("generic_fpst::generic_fpst",0,0)
  result = (struct generic_fpst *)calloc(1, sizeof(struct generic_fpst));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_fpst,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST(void *obj) {
struct generic_fpst *arg1 = (struct generic_fpst *) obj;
free((char *) arg1);
}
static swig_lua_method swig_generic_fpst_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_generic_fpst_attributes[] = {
    { "type", _wrap_FPST_type_get, _wrap_FPST_type_set},
    { "format", _wrap_FPST_format_get, _wrap_FPST_format_set},
    { "subtable", _wrap_FPST_subtable_get, _wrap_FPST_subtable_set},
    { "next", _wrap_FPST_next_get, _wrap_FPST_next_set},
    { "nccnt", _wrap_FPST_nccnt_get, _wrap_FPST_nccnt_set},
    { "bccnt", _wrap_FPST_bccnt_get, _wrap_FPST_bccnt_set},
    { "fccnt", _wrap_FPST_fccnt_get, _wrap_FPST_fccnt_set},
    { "rule_cnt", _wrap_FPST_rule_cnt_get, _wrap_FPST_rule_cnt_set},
    { "nclass", _wrap_FPST_nclass_get, _wrap_FPST_nclass_set},
    { "bclass", _wrap_FPST_bclass_get, _wrap_FPST_bclass_set},
    { "fclass", _wrap_FPST_fclass_get, _wrap_FPST_fclass_set},
    { "ticked", _wrap_FPST_ticked_get, _wrap_FPST_ticked_set},
    { "effectively_by_glyphs", _wrap_FPST_effectively_by_glyphs_get, _wrap_FPST_effectively_by_glyphs_set},
    { "nclassnames", _wrap_FPST_nclassnames_get, _wrap_FPST_nclassnames_set},
    { "bclassnames", _wrap_FPST_bclassnames_get, _wrap_FPST_bclassnames_set},
    { "fclassnames", _wrap_FPST_fclassnames_get, _wrap_FPST_fclassnames_set},
    { "rules", _wrap_FPST_rules_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_generic_fpst_bases[] = {0};
static const char *swig_generic_fpst_base_names[] = {0};
static swig_lua_class _wrap_class_generic_fpst = { "FPST", &SWIGTYPE_p_generic_fpst,_wrap_new_FPST, swig_delete_FPST, swig_generic_fpst_methods, swig_generic_fpst_attributes, swig_generic_fpst_bases, swig_generic_fpst_base_names };

static int _wrap_FPST_rules_lookup_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules *arg1 = (FPST_rules *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules::lookup_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules::lookup_cnt",1,"FPST_rules *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules::lookup_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules,0))){
    SWIG_fail_ptr("FPST_rules_lookup_cnt_set",1,SWIGTYPE_p_FPST_rules);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lookup_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_lookup_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules *arg1 = (FPST_rules *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules::lookup_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules::lookup_cnt",1,"FPST_rules *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules,0))){
    SWIG_fail_ptr("FPST_rules_lookup_cnt_get",1,SWIGTYPE_p_FPST_rules);
  }
  
  result = (int) ((arg1)->lookup_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules *arg1 = (FPST_rules *) 0 ;
  FPST_rules_u *result = 0 ;
  
  SWIG_check_num_args("FPST_rules::u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules::u",1,"FPST_rules *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules,0))){
    SWIG_fail_ptr("FPST_rules_u_get",1,SWIGTYPE_p_FPST_rules);
  }
  
  result = (FPST_rules_u *)& ((arg1)->u);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_lookups_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules *arg1 = (FPST_rules *) 0 ;
  FPST_rules_lookups *result = 0 ;
  
  SWIG_check_num_args("FPST_rules::lookups",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules::lookups",1,"FPST_rules *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules,0))){
    SWIG_fail_ptr("FPST_rules_lookups_get",1,SWIGTYPE_p_FPST_rules);
  }
  
  result = (FPST_rules_lookups *) ((arg1)->lookups);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_lookups,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST_rules(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules *result = 0 ;
  
  SWIG_check_num_args("FPST_rules::FPST_rules",0,0)
  result = (FPST_rules *)calloc(1, sizeof(FPST_rules));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST_rules(void *obj) {
FPST_rules *arg1 = (FPST_rules *) obj;
free((char *) arg1);
}
static swig_lua_method swig_FPST_rules_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_FPST_rules_attributes[] = {
    { "lookup_cnt", _wrap_FPST_rules_lookup_cnt_get, _wrap_FPST_rules_lookup_cnt_set},
    { "u", _wrap_FPST_rules_u_get, SWIG_Lua_set_immutable},
    { "lookups", _wrap_FPST_rules_lookups_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_FPST_rules_bases[] = {0};
static const char *swig_FPST_rules_base_names[] = {0};
static swig_lua_class _wrap_class_FPST_rules = { "FPST_rules", &SWIGTYPE_p_FPST_rules,_wrap_new_FPST_rules, swig_delete_FPST_rules, swig_FPST_rules_methods, swig_FPST_rules_attributes, swig_FPST_rules_bases, swig_FPST_rules_base_names };

static int _wrap_FPST_rules_lookups_seq_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_lookups *arg1 = (FPST_rules_lookups *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_lookups::seq",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_lookups::seq",1,"FPST_rules_lookups *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_lookups::seq",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_lookups,0))){
    SWIG_fail_ptr("FPST_rules_lookups_seq_set",1,SWIGTYPE_p_FPST_rules_lookups);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->seq = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_lookups_seq_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_lookups *arg1 = (FPST_rules_lookups *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_lookups::seq",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_lookups::seq",1,"FPST_rules_lookups *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_lookups,0))){
    SWIG_fail_ptr("FPST_rules_lookups_seq_get",1,SWIGTYPE_p_FPST_rules_lookups);
  }
  
  result = (int) ((arg1)->seq);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_lookups_lookup_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_lookups *arg1 = (FPST_rules_lookups *) 0 ;
  struct otlookup *arg2 = (struct otlookup *) 0 ;
  
  SWIG_check_num_args("FPST_rules_lookups::lookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_lookups::lookup",1,"FPST_rules_lookups *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_lookups::lookup",2,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_lookups,0))){
    SWIG_fail_ptr("FPST_rules_lookups_lookup_set",1,SWIGTYPE_p_FPST_rules_lookups);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FPST_rules_lookups_lookup_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->lookup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_lookups_lookup_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_lookups *arg1 = (FPST_rules_lookups *) 0 ;
  struct otlookup *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_lookups::lookup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_lookups::lookup",1,"FPST_rules_lookups *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_lookups,0))){
    SWIG_fail_ptr("FPST_rules_lookups_lookup_get",1,SWIGTYPE_p_FPST_rules_lookups);
  }
  
  result = (struct otlookup *) ((arg1)->lookup);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST_rules_lookups(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_lookups *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_lookups::FPST_rules_lookups",0,0)
  result = (FPST_rules_lookups *)calloc(1, sizeof(FPST_rules_lookups));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_lookups,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST_rules_lookups(void *obj) {
FPST_rules_lookups *arg1 = (FPST_rules_lookups *) obj;
free((char *) arg1);
}
static swig_lua_method swig_FPST_rules_lookups_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_FPST_rules_lookups_attributes[] = {
    { "seq", _wrap_FPST_rules_lookups_seq_get, _wrap_FPST_rules_lookups_seq_set},
    { "lookup", _wrap_FPST_rules_lookups_lookup_get, _wrap_FPST_rules_lookups_lookup_set},
    {0,0,0}
};
static swig_lua_class *swig_FPST_rules_lookups_bases[] = {0};
static const char *swig_FPST_rules_lookups_base_names[] = {0};
static swig_lua_class _wrap_class_FPST_rules_lookups = { "FPST_rules_lookups", &SWIGTYPE_p_FPST_rules_lookups,_wrap_new_FPST_rules_lookups, swig_delete_FPST_rules_lookups, swig_FPST_rules_lookups_methods, swig_FPST_rules_lookups_attributes, swig_FPST_rules_lookups_bases, swig_FPST_rules_lookups_base_names };

static int _wrap_FPST_rules_u_glyph_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u *arg1 = (FPST_rules_u *) 0 ;
  FPST_rules_u_glyph *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u::glyph",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u::glyph",1,"FPST_rules_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u,0))){
    SWIG_fail_ptr("FPST_rules_u_glyph_get",1,SWIGTYPE_p_FPST_rules_u);
  }
  
  result = (FPST_rules_u_glyph *)& ((arg1)->glyph);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_glyph,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u *arg1 = (FPST_rules_u *) 0 ;
  FPST_rules_u_class *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u::class",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u::class",1,"FPST_rules_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u,0))){
    SWIG_fail_ptr("FPST_rules_u_class_get",1,SWIGTYPE_p_FPST_rules_u);
  }
  
  result = (FPST_rules_u_class *)& ((arg1)->class);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_class,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u *arg1 = (FPST_rules_u *) 0 ;
  FPST_rules_u_coverage *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u::coverage",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u::coverage",1,"FPST_rules_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_get",1,SWIGTYPE_p_FPST_rules_u);
  }
  
  result = (FPST_rules_u_coverage *)& ((arg1)->coverage);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_coverage,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u *arg1 = (FPST_rules_u *) 0 ;
  FPST_rules_u_rcoverage *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u::rcoverage",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u::rcoverage",1,"FPST_rules_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_get",1,SWIGTYPE_p_FPST_rules_u);
  }
  
  result = (FPST_rules_u_rcoverage *)& ((arg1)->rcoverage);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_rcoverage,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST_rules_u(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u::FPST_rules_u",0,0)
  result = (FPST_rules_u *)calloc(1, sizeof(FPST_rules_u));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST_rules_u(void *obj) {
FPST_rules_u *arg1 = (FPST_rules_u *) obj;
free((char *) arg1);
}
static swig_lua_method swig_FPST_rules_u_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_FPST_rules_u_attributes[] = {
    { "glyph", _wrap_FPST_rules_u_glyph_get, SWIG_Lua_set_immutable},
    { "class", _wrap_FPST_rules_u_class_get, SWIG_Lua_set_immutable},
    { "coverage", _wrap_FPST_rules_u_coverage_get, SWIG_Lua_set_immutable},
    { "rcoverage", _wrap_FPST_rules_u_rcoverage_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_FPST_rules_u_bases[] = {0};
static const char *swig_FPST_rules_u_base_names[] = {0};
static swig_lua_class _wrap_class_FPST_rules_u = { "FPST_rules_u", &SWIGTYPE_p_FPST_rules_u,_wrap_new_FPST_rules_u, swig_delete_FPST_rules_u, swig_FPST_rules_u_methods, swig_FPST_rules_u_attributes, swig_FPST_rules_u_bases, swig_FPST_rules_u_base_names };

static int _wrap_FPST_rules_u_rcoverage_always1_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::always1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::always1",1,"FPST_rules_u_rcoverage *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_rcoverage::always1",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_always1_set",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->always1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_always1_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::always1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::always1",1,"FPST_rules_u_rcoverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_always1_get",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  result = (int) ((arg1)->always1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_bcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::bcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::bcnt",1,"FPST_rules_u_rcoverage *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_rcoverage::bcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_bcnt_set",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_bcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::bcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::bcnt",1,"FPST_rules_u_rcoverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_bcnt_get",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  result = (int) ((arg1)->bcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_fcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::fcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::fcnt",1,"FPST_rules_u_rcoverage *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_rcoverage::fcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_fcnt_set",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->fcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_fcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::fcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::fcnt",1,"FPST_rules_u_rcoverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_fcnt_get",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  result = (int) ((arg1)->fcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_ncovers_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::ncovers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::ncovers",1,"FPST_rules_u_rcoverage *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_rcoverage::ncovers",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_ncovers_set",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_ncovers_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->ncovers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_ncovers_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::ncovers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::ncovers",1,"FPST_rules_u_rcoverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_ncovers_get",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  result = (char **) ((arg1)->ncovers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_bcovers_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::bcovers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::bcovers",1,"FPST_rules_u_rcoverage *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_rcoverage::bcovers",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_bcovers_set",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_bcovers_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->bcovers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_bcovers_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::bcovers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::bcovers",1,"FPST_rules_u_rcoverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_bcovers_get",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  result = (char **) ((arg1)->bcovers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_fcovers_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::fcovers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::fcovers",1,"FPST_rules_u_rcoverage *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_rcoverage::fcovers",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_fcovers_set",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_fcovers_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->fcovers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_fcovers_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::fcovers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::fcovers",1,"FPST_rules_u_rcoverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_fcovers_get",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  result = (char **) ((arg1)->fcovers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_replacements_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::replacements",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::replacements",1,"FPST_rules_u_rcoverage *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("FPST_rules_u_rcoverage::replacements",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_replacements_set",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->replacements);
    if (arg2) {
      arg1->replacements = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->replacements, (const char *)arg2);
    } else {
      arg1->replacements = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_rcoverage_replacements_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::replacements",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_rcoverage::replacements",1,"FPST_rules_u_rcoverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_rcoverage,0))){
    SWIG_fail_ptr("FPST_rules_u_rcoverage_replacements_get",1,SWIGTYPE_p_FPST_rules_u_rcoverage);
  }
  
  result = (char *) ((arg1)->replacements);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST_rules_u_rcoverage(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_rcoverage *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_rcoverage::FPST_rules_u_rcoverage",0,0)
  result = (FPST_rules_u_rcoverage *)calloc(1, sizeof(FPST_rules_u_rcoverage));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_rcoverage,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST_rules_u_rcoverage(void *obj) {
FPST_rules_u_rcoverage *arg1 = (FPST_rules_u_rcoverage *) obj;
free((char *) arg1);
}
static swig_lua_method swig_FPST_rules_u_rcoverage_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_FPST_rules_u_rcoverage_attributes[] = {
    { "always1", _wrap_FPST_rules_u_rcoverage_always1_get, _wrap_FPST_rules_u_rcoverage_always1_set},
    { "bcnt", _wrap_FPST_rules_u_rcoverage_bcnt_get, _wrap_FPST_rules_u_rcoverage_bcnt_set},
    { "fcnt", _wrap_FPST_rules_u_rcoverage_fcnt_get, _wrap_FPST_rules_u_rcoverage_fcnt_set},
    { "ncovers", _wrap_FPST_rules_u_rcoverage_ncovers_get, _wrap_FPST_rules_u_rcoverage_ncovers_set},
    { "bcovers", _wrap_FPST_rules_u_rcoverage_bcovers_get, _wrap_FPST_rules_u_rcoverage_bcovers_set},
    { "fcovers", _wrap_FPST_rules_u_rcoverage_fcovers_get, _wrap_FPST_rules_u_rcoverage_fcovers_set},
    { "replacements", _wrap_FPST_rules_u_rcoverage_replacements_get, _wrap_FPST_rules_u_rcoverage_replacements_set},
    {0,0,0}
};
static swig_lua_class *swig_FPST_rules_u_rcoverage_bases[] = {0};
static const char *swig_FPST_rules_u_rcoverage_base_names[] = {0};
static swig_lua_class _wrap_class_FPST_rules_u_rcoverage = { "FPST_rules_u_rcoverage", &SWIGTYPE_p_FPST_rules_u_rcoverage,_wrap_new_FPST_rules_u_rcoverage, swig_delete_FPST_rules_u_rcoverage, swig_FPST_rules_u_rcoverage_methods, swig_FPST_rules_u_rcoverage_attributes, swig_FPST_rules_u_rcoverage_bases, swig_FPST_rules_u_rcoverage_base_names };

static int _wrap_FPST_rules_u_coverage_ncnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::ncnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::ncnt",1,"FPST_rules_u_coverage *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_coverage::ncnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_ncnt_set",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ncnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_ncnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_coverage::ncnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::ncnt",1,"FPST_rules_u_coverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_ncnt_get",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  result = (int) ((arg1)->ncnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_bcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::bcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::bcnt",1,"FPST_rules_u_coverage *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_coverage::bcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_bcnt_set",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_bcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_coverage::bcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::bcnt",1,"FPST_rules_u_coverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_bcnt_get",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  result = (int) ((arg1)->bcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_fcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::fcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::fcnt",1,"FPST_rules_u_coverage *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_coverage::fcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_fcnt_set",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->fcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_fcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_coverage::fcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::fcnt",1,"FPST_rules_u_coverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_fcnt_get",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  result = (int) ((arg1)->fcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_ncovers_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::ncovers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::ncovers",1,"FPST_rules_u_coverage *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_coverage::ncovers",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_ncovers_set",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_ncovers_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->ncovers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_ncovers_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::ncovers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::ncovers",1,"FPST_rules_u_coverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_ncovers_get",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  result = (char **) ((arg1)->ncovers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_bcovers_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::bcovers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::bcovers",1,"FPST_rules_u_coverage *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_coverage::bcovers",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_bcovers_set",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_bcovers_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->bcovers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_bcovers_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::bcovers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::bcovers",1,"FPST_rules_u_coverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_bcovers_get",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  result = (char **) ((arg1)->bcovers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_fcovers_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::fcovers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::fcovers",1,"FPST_rules_u_coverage *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_coverage::fcovers",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_fcovers_set",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_fcovers_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->fcovers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_coverage_fcovers_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::fcovers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_coverage::fcovers",1,"FPST_rules_u_coverage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_coverage,0))){
    SWIG_fail_ptr("FPST_rules_u_coverage_fcovers_get",1,SWIGTYPE_p_FPST_rules_u_coverage);
  }
  
  result = (char **) ((arg1)->fcovers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST_rules_u_coverage(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_coverage *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_coverage::FPST_rules_u_coverage",0,0)
  result = (FPST_rules_u_coverage *)calloc(1, sizeof(FPST_rules_u_coverage));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_coverage,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST_rules_u_coverage(void *obj) {
FPST_rules_u_coverage *arg1 = (FPST_rules_u_coverage *) obj;
free((char *) arg1);
}
static swig_lua_method swig_FPST_rules_u_coverage_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_FPST_rules_u_coverage_attributes[] = {
    { "ncnt", _wrap_FPST_rules_u_coverage_ncnt_get, _wrap_FPST_rules_u_coverage_ncnt_set},
    { "bcnt", _wrap_FPST_rules_u_coverage_bcnt_get, _wrap_FPST_rules_u_coverage_bcnt_set},
    { "fcnt", _wrap_FPST_rules_u_coverage_fcnt_get, _wrap_FPST_rules_u_coverage_fcnt_set},
    { "ncovers", _wrap_FPST_rules_u_coverage_ncovers_get, _wrap_FPST_rules_u_coverage_ncovers_set},
    { "bcovers", _wrap_FPST_rules_u_coverage_bcovers_get, _wrap_FPST_rules_u_coverage_bcovers_set},
    { "fcovers", _wrap_FPST_rules_u_coverage_fcovers_get, _wrap_FPST_rules_u_coverage_fcovers_set},
    {0,0,0}
};
static swig_lua_class *swig_FPST_rules_u_coverage_bases[] = {0};
static const char *swig_FPST_rules_u_coverage_base_names[] = {0};
static swig_lua_class _wrap_class_FPST_rules_u_coverage = { "FPST_rules_u_coverage", &SWIGTYPE_p_FPST_rules_u_coverage,_wrap_new_FPST_rules_u_coverage, swig_delete_FPST_rules_u_coverage, swig_FPST_rules_u_coverage_methods, swig_FPST_rules_u_coverage_attributes, swig_FPST_rules_u_coverage_bases, swig_FPST_rules_u_coverage_base_names };

static int _wrap_FPST_rules_u_class_ncnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_class::ncnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::ncnt",1,"FPST_rules_u_class *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_class::ncnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_ncnt_set",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ncnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_ncnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_class::ncnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::ncnt",1,"FPST_rules_u_class *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_ncnt_get",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  result = (int) ((arg1)->ncnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_bcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_class::bcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::bcnt",1,"FPST_rules_u_class *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_class::bcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_bcnt_set",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_bcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_class::bcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::bcnt",1,"FPST_rules_u_class *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_bcnt_get",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  result = (int) ((arg1)->bcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_fcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("FPST_rules_u_class::fcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::fcnt",1,"FPST_rules_u_class *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPST_rules_u_class::fcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_fcnt_set",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->fcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_fcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  int result;
  
  SWIG_check_num_args("FPST_rules_u_class::fcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::fcnt",1,"FPST_rules_u_class *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_fcnt_get",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  result = (int) ((arg1)->fcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_nclasses_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::nclasses",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::nclasses",1,"FPST_rules_u_class *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_class::nclasses",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_nclasses_set",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FPST_rules_u_class_nclasses_set",2,SWIGTYPE_p_unsigned_short);
  }
  
  if (arg1) (arg1)->nclasses = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_nclasses_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::nclasses",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::nclasses",1,"FPST_rules_u_class *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_nclasses_get",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  result = (uint16 *) ((arg1)->nclasses);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_bclasses_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::bclasses",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::bclasses",1,"FPST_rules_u_class *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_class::bclasses",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_bclasses_set",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FPST_rules_u_class_bclasses_set",2,SWIGTYPE_p_unsigned_short);
  }
  
  if (arg1) (arg1)->bclasses = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_bclasses_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::bclasses",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::bclasses",1,"FPST_rules_u_class *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_bclasses_get",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  result = (uint16 *) ((arg1)->bclasses);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_fclasses_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::fclasses",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::fclasses",1,"FPST_rules_u_class *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_class::fclasses",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_fclasses_set",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FPST_rules_u_class_fclasses_set",2,SWIGTYPE_p_unsigned_short);
  }
  
  if (arg1) (arg1)->fclasses = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_fclasses_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::fclasses",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::fclasses",1,"FPST_rules_u_class *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_fclasses_get",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  result = (uint16 *) ((arg1)->fclasses);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_allclasses_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::allclasses",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::allclasses",1,"FPST_rules_u_class *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPST_rules_u_class::allclasses",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_allclasses_set",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("FPST_rules_u_class_allclasses_set",2,SWIGTYPE_p_unsigned_short);
  }
  
  if (arg1) (arg1)->allclasses = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_class_allclasses_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *arg1 = (FPST_rules_u_class *) 0 ;
  uint16 *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::allclasses",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_class::allclasses",1,"FPST_rules_u_class *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_class,0))){
    SWIG_fail_ptr("FPST_rules_u_class_allclasses_get",1,SWIGTYPE_p_FPST_rules_u_class);
  }
  
  result = (uint16 *) ((arg1)->allclasses);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST_rules_u_class(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_class *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_class::FPST_rules_u_class",0,0)
  result = (FPST_rules_u_class *)calloc(1, sizeof(FPST_rules_u_class));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_class,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST_rules_u_class(void *obj) {
FPST_rules_u_class *arg1 = (FPST_rules_u_class *) obj;
free((char *) arg1);
}
static swig_lua_method swig_FPST_rules_u_class_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_FPST_rules_u_class_attributes[] = {
    { "ncnt", _wrap_FPST_rules_u_class_ncnt_get, _wrap_FPST_rules_u_class_ncnt_set},
    { "bcnt", _wrap_FPST_rules_u_class_bcnt_get, _wrap_FPST_rules_u_class_bcnt_set},
    { "fcnt", _wrap_FPST_rules_u_class_fcnt_get, _wrap_FPST_rules_u_class_fcnt_set},
    { "nclasses", _wrap_FPST_rules_u_class_nclasses_get, _wrap_FPST_rules_u_class_nclasses_set},
    { "bclasses", _wrap_FPST_rules_u_class_bclasses_get, _wrap_FPST_rules_u_class_bclasses_set},
    { "fclasses", _wrap_FPST_rules_u_class_fclasses_get, _wrap_FPST_rules_u_class_fclasses_set},
    { "allclasses", _wrap_FPST_rules_u_class_allclasses_get, _wrap_FPST_rules_u_class_allclasses_set},
    {0,0,0}
};
static swig_lua_class *swig_FPST_rules_u_class_bases[] = {0};
static const char *swig_FPST_rules_u_class_base_names[] = {0};
static swig_lua_class _wrap_class_FPST_rules_u_class = { "FPST_rules_u_class", &SWIGTYPE_p_FPST_rules_u_class,_wrap_new_FPST_rules_u_class, swig_delete_FPST_rules_u_class, swig_FPST_rules_u_class_methods, swig_FPST_rules_u_class_attributes, swig_FPST_rules_u_class_bases, swig_FPST_rules_u_class_base_names };

static int _wrap_FPST_rules_u_glyph_names_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_glyph *arg1 = (FPST_rules_u_glyph *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_glyph::names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_glyph::names",1,"FPST_rules_u_glyph *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("FPST_rules_u_glyph::names",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_glyph,0))){
    SWIG_fail_ptr("FPST_rules_u_glyph_names_set",1,SWIGTYPE_p_FPST_rules_u_glyph);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->names);
    if (arg2) {
      arg1->names = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->names, (const char *)arg2);
    } else {
      arg1->names = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_glyph_names_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_glyph *arg1 = (FPST_rules_u_glyph *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_glyph::names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_glyph::names",1,"FPST_rules_u_glyph *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_glyph,0))){
    SWIG_fail_ptr("FPST_rules_u_glyph_names_get",1,SWIGTYPE_p_FPST_rules_u_glyph);
  }
  
  result = (char *) ((arg1)->names);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_glyph_back_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_glyph *arg1 = (FPST_rules_u_glyph *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_glyph::back",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_glyph::back",1,"FPST_rules_u_glyph *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("FPST_rules_u_glyph::back",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_glyph,0))){
    SWIG_fail_ptr("FPST_rules_u_glyph_back_set",1,SWIGTYPE_p_FPST_rules_u_glyph);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->back);
    if (arg2) {
      arg1->back = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->back, (const char *)arg2);
    } else {
      arg1->back = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_glyph_back_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_glyph *arg1 = (FPST_rules_u_glyph *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_glyph::back",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_glyph::back",1,"FPST_rules_u_glyph *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_glyph,0))){
    SWIG_fail_ptr("FPST_rules_u_glyph_back_get",1,SWIGTYPE_p_FPST_rules_u_glyph);
  }
  
  result = (char *) ((arg1)->back);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_glyph_fore_set(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_glyph *arg1 = (FPST_rules_u_glyph *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("FPST_rules_u_glyph::fore",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_glyph::fore",1,"FPST_rules_u_glyph *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("FPST_rules_u_glyph::fore",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_glyph,0))){
    SWIG_fail_ptr("FPST_rules_u_glyph_fore_set",1,SWIGTYPE_p_FPST_rules_u_glyph);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->fore);
    if (arg2) {
      arg1->fore = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->fore, (const char *)arg2);
    } else {
      arg1->fore = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPST_rules_u_glyph_fore_get(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_glyph *arg1 = (FPST_rules_u_glyph *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_glyph::fore",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPST_rules_u_glyph::fore",1,"FPST_rules_u_glyph *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FPST_rules_u_glyph,0))){
    SWIG_fail_ptr("FPST_rules_u_glyph_fore_get",1,SWIGTYPE_p_FPST_rules_u_glyph);
  }
  
  result = (char *) ((arg1)->fore);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_FPST_rules_u_glyph(lua_State* L) {
  int SWIG_arg = 0;
  FPST_rules_u_glyph *result = 0 ;
  
  SWIG_check_num_args("FPST_rules_u_glyph::FPST_rules_u_glyph",0,0)
  result = (FPST_rules_u_glyph *)calloc(1, sizeof(FPST_rules_u_glyph));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FPST_rules_u_glyph,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_FPST_rules_u_glyph(void *obj) {
FPST_rules_u_glyph *arg1 = (FPST_rules_u_glyph *) obj;
free((char *) arg1);
}
static swig_lua_method swig_FPST_rules_u_glyph_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_FPST_rules_u_glyph_attributes[] = {
    { "names", _wrap_FPST_rules_u_glyph_names_get, _wrap_FPST_rules_u_glyph_names_set},
    { "back", _wrap_FPST_rules_u_glyph_back_get, _wrap_FPST_rules_u_glyph_back_set},
    { "fore", _wrap_FPST_rules_u_glyph_fore_get, _wrap_FPST_rules_u_glyph_fore_set},
    {0,0,0}
};
static swig_lua_class *swig_FPST_rules_u_glyph_bases[] = {0};
static const char *swig_FPST_rules_u_glyph_base_names[] = {0};
static swig_lua_class _wrap_class_FPST_rules_u_glyph = { "FPST_rules_u_glyph", &SWIGTYPE_p_FPST_rules_u_glyph,_wrap_new_FPST_rules_u_glyph, swig_delete_FPST_rules_u_glyph, swig_FPST_rules_u_glyph_methods, swig_FPST_rules_u_glyph_attributes, swig_FPST_rules_u_glyph_bases, swig_FPST_rules_u_glyph_base_names };

static int _wrap_ASM_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  struct generic_asm *arg2 = (struct generic_asm *) 0 ;
  
  SWIG_check_num_args("generic_asm::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::next",1,"struct generic_asm *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_asm::next",2,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_next_set",1,SWIGTYPE_p_generic_asm);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_asm,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ASM_next_set",2,SWIGTYPE_p_generic_asm);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  struct generic_asm *result = 0 ;
  
  SWIG_check_num_args("generic_asm::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::next",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_next_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (struct generic_asm *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_asm,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_asm::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::type",1,"struct generic_asm *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_asm::type",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_type_set",1,SWIGTYPE_p_generic_asm);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_asm::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::type",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_type_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (uint16) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_subtable_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("generic_asm::subtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::subtable",1,"struct generic_asm *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_asm::subtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_subtable_set",1,SWIGTYPE_p_generic_asm);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ASM_subtable_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->subtable = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_subtable_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("generic_asm::subtable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::subtable",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_subtable_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (struct lookup_subtable *) ((arg1)->subtable);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_flags_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_asm::flags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::flags",1,"struct generic_asm *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_asm::flags",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_flags_set",1,SWIGTYPE_p_generic_asm);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->flags = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_flags_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_asm::flags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::flags",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_flags_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (uint16) ((arg1)->flags);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("generic_asm::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::ticked",1,"struct generic_asm *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_asm::ticked",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_ticked_set",1,SWIGTYPE_p_generic_asm);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("generic_asm::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::ticked",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_ticked_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (uint8) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_class_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_asm::class_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::class_cnt",1,"struct generic_asm *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_asm::class_cnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_class_cnt_set",1,SWIGTYPE_p_generic_asm);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->class_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_class_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_asm::class_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::class_cnt",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_class_cnt_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (uint16) ((arg1)->class_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("generic_asm::state_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::state_cnt",1,"struct generic_asm *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("generic_asm::state_cnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_state_cnt_set",1,SWIGTYPE_p_generic_asm);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->state_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("generic_asm::state_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::state_cnt",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_state_cnt_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (uint16) ((arg1)->state_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_classes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("generic_asm::classes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::classes",1,"struct generic_asm *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("generic_asm::classes",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_classes_set",1,SWIGTYPE_p_generic_asm);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("ASM_classes_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->classes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_classes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("generic_asm::classes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::classes",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_classes_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (char **) ((arg1)->classes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_get(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *arg1 = (struct generic_asm *) 0 ;
  ASM_state *result = 0 ;
  
  SWIG_check_num_args("generic_asm::state",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("generic_asm::state",1,"struct generic_asm *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASM_state_get",1,SWIGTYPE_p_generic_asm);
  }
  
  result = (ASM_state *) ((arg1)->state);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ASM(lua_State* L) {
  int SWIG_arg = 0;
  struct generic_asm *result = 0 ;
  
  SWIG_check_num_args("generic_asm::generic_asm",0,0)
  result = (struct generic_asm *)calloc(1, sizeof(struct generic_asm));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_asm,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ASM(void *obj) {
struct generic_asm *arg1 = (struct generic_asm *) obj;
free((char *) arg1);
}
static swig_lua_method swig_generic_asm_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_generic_asm_attributes[] = {
    { "next", _wrap_ASM_next_get, _wrap_ASM_next_set},
    { "type", _wrap_ASM_type_get, _wrap_ASM_type_set},
    { "subtable", _wrap_ASM_subtable_get, _wrap_ASM_subtable_set},
    { "flags", _wrap_ASM_flags_get, _wrap_ASM_flags_set},
    { "ticked", _wrap_ASM_ticked_get, _wrap_ASM_ticked_set},
    { "class_cnt", _wrap_ASM_class_cnt_get, _wrap_ASM_class_cnt_set},
    { "state_cnt", _wrap_ASM_state_cnt_get, _wrap_ASM_state_cnt_set},
    { "classes", _wrap_ASM_classes_get, _wrap_ASM_classes_set},
    { "state", _wrap_ASM_state_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_generic_asm_bases[] = {0};
static const char *swig_generic_asm_base_names[] = {0};
static swig_lua_class _wrap_class_generic_asm = { "ASM", &SWIGTYPE_p_generic_asm,_wrap_new_ASM, swig_delete_ASM, swig_generic_asm_methods, swig_generic_asm_attributes, swig_generic_asm_bases, swig_generic_asm_base_names };

static int _wrap_ASM_state_next_state_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state *arg1 = (ASM_state *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("ASM_state::next_state",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state::next_state",1,"ASM_state *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ASM_state::next_state",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state,0))){
    SWIG_fail_ptr("ASM_state_next_state_set",1,SWIGTYPE_p_ASM_state);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->next_state = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_next_state_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state *arg1 = (ASM_state *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("ASM_state::next_state",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state::next_state",1,"ASM_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state,0))){
    SWIG_fail_ptr("ASM_state_next_state_get",1,SWIGTYPE_p_ASM_state);
  }
  
  result = (uint16) ((arg1)->next_state);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_flags_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state *arg1 = (ASM_state *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("ASM_state::flags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state::flags",1,"ASM_state *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ASM_state::flags",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state,0))){
    SWIG_fail_ptr("ASM_state_flags_set",1,SWIGTYPE_p_ASM_state);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->flags = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_flags_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state *arg1 = (ASM_state *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("ASM_state::flags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state::flags",1,"ASM_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state,0))){
    SWIG_fail_ptr("ASM_state_flags_get",1,SWIGTYPE_p_ASM_state);
  }
  
  result = (uint16) ((arg1)->flags);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state *arg1 = (ASM_state *) 0 ;
  ASM_state_u *result = 0 ;
  
  SWIG_check_num_args("ASM_state::u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state::u",1,"ASM_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state,0))){
    SWIG_fail_ptr("ASM_state_u_get",1,SWIGTYPE_p_ASM_state);
  }
  
  result = (ASM_state_u *)& ((arg1)->u);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ASM_state(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state *result = 0 ;
  
  SWIG_check_num_args("ASM_state::ASM_state",0,0)
  result = (ASM_state *)calloc(1, sizeof(ASM_state));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ASM_state(void *obj) {
ASM_state *arg1 = (ASM_state *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ASM_state_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ASM_state_attributes[] = {
    { "next_state", _wrap_ASM_state_next_state_get, _wrap_ASM_state_next_state_set},
    { "flags", _wrap_ASM_state_flags_get, _wrap_ASM_state_flags_set},
    { "u", _wrap_ASM_state_u_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_ASM_state_bases[] = {0};
static const char *swig_ASM_state_base_names[] = {0};
static swig_lua_class _wrap_class_ASM_state = { "ASM_state", &SWIGTYPE_p_ASM_state,_wrap_new_ASM_state, swig_delete_ASM_state, swig_ASM_state_methods, swig_ASM_state_attributes, swig_ASM_state_bases, swig_ASM_state_base_names };

static int _wrap_ASM_state_u_context_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u *arg1 = (ASM_state_u *) 0 ;
  ASM_state_u_context *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u::context",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u::context",1,"ASM_state_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u,0))){
    SWIG_fail_ptr("ASM_state_u_context_get",1,SWIGTYPE_p_ASM_state_u);
  }
  
  result = (ASM_state_u_context *)& ((arg1)->context);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u_context,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_insert_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u *arg1 = (ASM_state_u *) 0 ;
  ASM_state_u_insert *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u::insert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u::insert",1,"ASM_state_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u,0))){
    SWIG_fail_ptr("ASM_state_u_insert_get",1,SWIGTYPE_p_ASM_state_u);
  }
  
  result = (ASM_state_u_insert *)& ((arg1)->insert);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u_insert,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_kern_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u *arg1 = (ASM_state_u *) 0 ;
  ASM_state_u_kern *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u::kern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u::kern",1,"ASM_state_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u,0))){
    SWIG_fail_ptr("ASM_state_u_kern_get",1,SWIGTYPE_p_ASM_state_u);
  }
  
  result = (ASM_state_u_kern *)& ((arg1)->kern);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u_kern,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ASM_state_u(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u::ASM_state_u",0,0)
  result = (ASM_state_u *)calloc(1, sizeof(ASM_state_u));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ASM_state_u(void *obj) {
ASM_state_u *arg1 = (ASM_state_u *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ASM_state_u_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ASM_state_u_attributes[] = {
    { "context", _wrap_ASM_state_u_context_get, SWIG_Lua_set_immutable},
    { "insert", _wrap_ASM_state_u_insert_get, SWIG_Lua_set_immutable},
    { "kern", _wrap_ASM_state_u_kern_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_ASM_state_u_bases[] = {0};
static const char *swig_ASM_state_u_base_names[] = {0};
static swig_lua_class _wrap_class_ASM_state_u = { "ASM_state_u", &SWIGTYPE_p_ASM_state_u,_wrap_new_ASM_state_u, swig_delete_ASM_state_u, swig_ASM_state_u_methods, swig_ASM_state_u_attributes, swig_ASM_state_u_bases, swig_ASM_state_u_base_names };

static int _wrap_ASM_state_u_kern_kerns_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_kern *arg1 = (ASM_state_u_kern *) 0 ;
  int16 *arg2 = (int16 *) 0 ;
  
  SWIG_check_num_args("ASM_state_u_kern::kerns",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_kern::kerns",1,"ASM_state_u_kern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ASM_state_u_kern::kerns",2,"int16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_kern,0))){
    SWIG_fail_ptr("ASM_state_u_kern_kerns_set",1,SWIGTYPE_p_ASM_state_u_kern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ASM_state_u_kern_kerns_set",2,SWIGTYPE_p_short);
  }
  
  if (arg1) (arg1)->kerns = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_kern_kerns_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_kern *arg1 = (ASM_state_u_kern *) 0 ;
  int16 *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_kern::kerns",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_kern::kerns",1,"ASM_state_u_kern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_kern,0))){
    SWIG_fail_ptr("ASM_state_u_kern_kerns_get",1,SWIGTYPE_p_ASM_state_u_kern);
  }
  
  result = (int16 *) ((arg1)->kerns);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_kern_kcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_kern *arg1 = (ASM_state_u_kern *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ASM_state_u_kern::kcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_kern::kcnt",1,"ASM_state_u_kern *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ASM_state_u_kern::kcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_kern,0))){
    SWIG_fail_ptr("ASM_state_u_kern_kcnt_set",1,SWIGTYPE_p_ASM_state_u_kern);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->kcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_kern_kcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_kern *arg1 = (ASM_state_u_kern *) 0 ;
  int result;
  
  SWIG_check_num_args("ASM_state_u_kern::kcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_kern::kcnt",1,"ASM_state_u_kern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_kern,0))){
    SWIG_fail_ptr("ASM_state_u_kern_kcnt_get",1,SWIGTYPE_p_ASM_state_u_kern);
  }
  
  result = (int) ((arg1)->kcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ASM_state_u_kern(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_kern *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_kern::ASM_state_u_kern",0,0)
  result = (ASM_state_u_kern *)calloc(1, sizeof(ASM_state_u_kern));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u_kern,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ASM_state_u_kern(void *obj) {
ASM_state_u_kern *arg1 = (ASM_state_u_kern *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ASM_state_u_kern_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ASM_state_u_kern_attributes[] = {
    { "kerns", _wrap_ASM_state_u_kern_kerns_get, _wrap_ASM_state_u_kern_kerns_set},
    { "kcnt", _wrap_ASM_state_u_kern_kcnt_get, _wrap_ASM_state_u_kern_kcnt_set},
    {0,0,0}
};
static swig_lua_class *swig_ASM_state_u_kern_bases[] = {0};
static const char *swig_ASM_state_u_kern_base_names[] = {0};
static swig_lua_class _wrap_class_ASM_state_u_kern = { "ASM_state_u_kern", &SWIGTYPE_p_ASM_state_u_kern,_wrap_new_ASM_state_u_kern, swig_delete_ASM_state_u_kern, swig_ASM_state_u_kern_methods, swig_ASM_state_u_kern_attributes, swig_ASM_state_u_kern_bases, swig_ASM_state_u_kern_base_names };

static int _wrap_ASM_state_u_insert_mark_ins_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_insert *arg1 = (ASM_state_u_insert *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("ASM_state_u_insert::mark_ins",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_insert::mark_ins",1,"ASM_state_u_insert *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ASM_state_u_insert::mark_ins",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_insert,0))){
    SWIG_fail_ptr("ASM_state_u_insert_mark_ins_set",1,SWIGTYPE_p_ASM_state_u_insert);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->mark_ins);
    if (arg2) {
      arg1->mark_ins = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->mark_ins, (const char *)arg2);
    } else {
      arg1->mark_ins = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_insert_mark_ins_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_insert *arg1 = (ASM_state_u_insert *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_insert::mark_ins",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_insert::mark_ins",1,"ASM_state_u_insert *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_insert,0))){
    SWIG_fail_ptr("ASM_state_u_insert_mark_ins_get",1,SWIGTYPE_p_ASM_state_u_insert);
  }
  
  result = (char *) ((arg1)->mark_ins);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_insert_cur_ins_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_insert *arg1 = (ASM_state_u_insert *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("ASM_state_u_insert::cur_ins",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_insert::cur_ins",1,"ASM_state_u_insert *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("ASM_state_u_insert::cur_ins",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_insert,0))){
    SWIG_fail_ptr("ASM_state_u_insert_cur_ins_set",1,SWIGTYPE_p_ASM_state_u_insert);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->cur_ins);
    if (arg2) {
      arg1->cur_ins = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->cur_ins, (const char *)arg2);
    } else {
      arg1->cur_ins = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_insert_cur_ins_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_insert *arg1 = (ASM_state_u_insert *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_insert::cur_ins",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_insert::cur_ins",1,"ASM_state_u_insert *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_insert,0))){
    SWIG_fail_ptr("ASM_state_u_insert_cur_ins_get",1,SWIGTYPE_p_ASM_state_u_insert);
  }
  
  result = (char *) ((arg1)->cur_ins);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ASM_state_u_insert(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_insert *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_insert::ASM_state_u_insert",0,0)
  result = (ASM_state_u_insert *)calloc(1, sizeof(ASM_state_u_insert));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u_insert,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ASM_state_u_insert(void *obj) {
ASM_state_u_insert *arg1 = (ASM_state_u_insert *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ASM_state_u_insert_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ASM_state_u_insert_attributes[] = {
    { "mark_ins", _wrap_ASM_state_u_insert_mark_ins_get, _wrap_ASM_state_u_insert_mark_ins_set},
    { "cur_ins", _wrap_ASM_state_u_insert_cur_ins_get, _wrap_ASM_state_u_insert_cur_ins_set},
    {0,0,0}
};
static swig_lua_class *swig_ASM_state_u_insert_bases[] = {0};
static const char *swig_ASM_state_u_insert_base_names[] = {0};
static swig_lua_class _wrap_class_ASM_state_u_insert = { "ASM_state_u_insert", &SWIGTYPE_p_ASM_state_u_insert,_wrap_new_ASM_state_u_insert, swig_delete_ASM_state_u_insert, swig_ASM_state_u_insert_methods, swig_ASM_state_u_insert_attributes, swig_ASM_state_u_insert_bases, swig_ASM_state_u_insert_base_names };

static int _wrap_ASM_state_u_context_mark_lookup_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_context *arg1 = (ASM_state_u_context *) 0 ;
  struct otlookup *arg2 = (struct otlookup *) 0 ;
  
  SWIG_check_num_args("ASM_state_u_context::mark_lookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_context::mark_lookup",1,"ASM_state_u_context *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ASM_state_u_context::mark_lookup",2,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_context,0))){
    SWIG_fail_ptr("ASM_state_u_context_mark_lookup_set",1,SWIGTYPE_p_ASM_state_u_context);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ASM_state_u_context_mark_lookup_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->mark_lookup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_context_mark_lookup_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_context *arg1 = (ASM_state_u_context *) 0 ;
  struct otlookup *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_context::mark_lookup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_context::mark_lookup",1,"ASM_state_u_context *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_context,0))){
    SWIG_fail_ptr("ASM_state_u_context_mark_lookup_get",1,SWIGTYPE_p_ASM_state_u_context);
  }
  
  result = (struct otlookup *) ((arg1)->mark_lookup);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_context_cur_lookup_set(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_context *arg1 = (ASM_state_u_context *) 0 ;
  struct otlookup *arg2 = (struct otlookup *) 0 ;
  
  SWIG_check_num_args("ASM_state_u_context::cur_lookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_context::cur_lookup",1,"ASM_state_u_context *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ASM_state_u_context::cur_lookup",2,"struct otlookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_context,0))){
    SWIG_fail_ptr("ASM_state_u_context_cur_lookup_set",1,SWIGTYPE_p_ASM_state_u_context);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ASM_state_u_context_cur_lookup_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->cur_lookup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASM_state_u_context_cur_lookup_get(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_context *arg1 = (ASM_state_u_context *) 0 ;
  struct otlookup *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_context::cur_lookup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASM_state_u_context::cur_lookup",1,"ASM_state_u_context *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ASM_state_u_context,0))){
    SWIG_fail_ptr("ASM_state_u_context_cur_lookup_get",1,SWIGTYPE_p_ASM_state_u_context);
  }
  
  result = (struct otlookup *) ((arg1)->cur_lookup);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ASM_state_u_context(lua_State* L) {
  int SWIG_arg = 0;
  ASM_state_u_context *result = 0 ;
  
  SWIG_check_num_args("ASM_state_u_context::ASM_state_u_context",0,0)
  result = (ASM_state_u_context *)calloc(1, sizeof(ASM_state_u_context));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ASM_state_u_context,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ASM_state_u_context(void *obj) {
ASM_state_u_context *arg1 = (ASM_state_u_context *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ASM_state_u_context_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ASM_state_u_context_attributes[] = {
    { "mark_lookup", _wrap_ASM_state_u_context_mark_lookup_get, _wrap_ASM_state_u_context_mark_lookup_set},
    { "cur_lookup", _wrap_ASM_state_u_context_cur_lookup_get, _wrap_ASM_state_u_context_cur_lookup_set},
    {0,0,0}
};
static swig_lua_class *swig_ASM_state_u_context_bases[] = {0};
static const char *swig_ASM_state_u_context_base_names[] = {0};
static swig_lua_class _wrap_class_ASM_state_u_context = { "ASM_state_u_context", &SWIGTYPE_p_ASM_state_u_context,_wrap_new_ASM_state_u_context, swig_delete_ASM_state_u_context, swig_ASM_state_u_context_methods, swig_ASM_state_u_context_attributes, swig_ASM_state_u_context_bases, swig_ASM_state_u_context_base_names };

static int _wrap_jstf_prio_enableShrink_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **arg2 = (OTLookup **) 0 ;
  
  SWIG_check_num_args("jstf_prio::enableShrink",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::enableShrink",1,"struct jstf_prio *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_prio::enableShrink",2,"OTLookup **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_enableShrink_set",1,SWIGTYPE_p_jstf_prio);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("jstf_prio_enableShrink_set",2,SWIGTYPE_p_p_otlookup);
  }
  
  if (arg1) (arg1)->enableShrink = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_enableShrink_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("jstf_prio::enableShrink",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::enableShrink",1,"struct jstf_prio *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_enableShrink_get",1,SWIGTYPE_p_jstf_prio);
  }
  
  result = (OTLookup **) ((arg1)->enableShrink);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_disableShrink_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **arg2 = (OTLookup **) 0 ;
  
  SWIG_check_num_args("jstf_prio::disableShrink",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::disableShrink",1,"struct jstf_prio *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_prio::disableShrink",2,"OTLookup **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_disableShrink_set",1,SWIGTYPE_p_jstf_prio);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("jstf_prio_disableShrink_set",2,SWIGTYPE_p_p_otlookup);
  }
  
  if (arg1) (arg1)->disableShrink = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_disableShrink_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("jstf_prio::disableShrink",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::disableShrink",1,"struct jstf_prio *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_disableShrink_get",1,SWIGTYPE_p_jstf_prio);
  }
  
  result = (OTLookup **) ((arg1)->disableShrink);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_maxShrink_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **arg2 = (OTLookup **) 0 ;
  
  SWIG_check_num_args("jstf_prio::maxShrink",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::maxShrink",1,"struct jstf_prio *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_prio::maxShrink",2,"OTLookup **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_maxShrink_set",1,SWIGTYPE_p_jstf_prio);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("jstf_prio_maxShrink_set",2,SWIGTYPE_p_p_otlookup);
  }
  
  if (arg1) (arg1)->maxShrink = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_maxShrink_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("jstf_prio::maxShrink",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::maxShrink",1,"struct jstf_prio *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_maxShrink_get",1,SWIGTYPE_p_jstf_prio);
  }
  
  result = (OTLookup **) ((arg1)->maxShrink);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_enableExtend_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **arg2 = (OTLookup **) 0 ;
  
  SWIG_check_num_args("jstf_prio::enableExtend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::enableExtend",1,"struct jstf_prio *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_prio::enableExtend",2,"OTLookup **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_enableExtend_set",1,SWIGTYPE_p_jstf_prio);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("jstf_prio_enableExtend_set",2,SWIGTYPE_p_p_otlookup);
  }
  
  if (arg1) (arg1)->enableExtend = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_enableExtend_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("jstf_prio::enableExtend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::enableExtend",1,"struct jstf_prio *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_enableExtend_get",1,SWIGTYPE_p_jstf_prio);
  }
  
  result = (OTLookup **) ((arg1)->enableExtend);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_disableExtend_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **arg2 = (OTLookup **) 0 ;
  
  SWIG_check_num_args("jstf_prio::disableExtend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::disableExtend",1,"struct jstf_prio *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_prio::disableExtend",2,"OTLookup **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_disableExtend_set",1,SWIGTYPE_p_jstf_prio);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("jstf_prio_disableExtend_set",2,SWIGTYPE_p_p_otlookup);
  }
  
  if (arg1) (arg1)->disableExtend = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_disableExtend_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("jstf_prio::disableExtend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::disableExtend",1,"struct jstf_prio *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_disableExtend_get",1,SWIGTYPE_p_jstf_prio);
  }
  
  result = (OTLookup **) ((arg1)->disableExtend);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_maxExtend_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **arg2 = (OTLookup **) 0 ;
  
  SWIG_check_num_args("jstf_prio::maxExtend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::maxExtend",1,"struct jstf_prio *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_prio::maxExtend",2,"OTLookup **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_maxExtend_set",1,SWIGTYPE_p_jstf_prio);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("jstf_prio_maxExtend_set",2,SWIGTYPE_p_p_otlookup);
  }
  
  if (arg1) (arg1)->maxExtend = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_prio_maxExtend_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *arg1 = (struct jstf_prio *) 0 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("jstf_prio::maxExtend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_prio::maxExtend",1,"struct jstf_prio *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_prio,0))){
    SWIG_fail_ptr("jstf_prio_maxExtend_get",1,SWIGTYPE_p_jstf_prio);
  }
  
  result = (OTLookup **) ((arg1)->maxExtend);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_jstf_prio(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_prio *result = 0 ;
  
  SWIG_check_num_args("jstf_prio::jstf_prio",0,0)
  result = (struct jstf_prio *)calloc(1, sizeof(struct jstf_prio));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_prio,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_jstf_prio(void *obj) {
struct jstf_prio *arg1 = (struct jstf_prio *) obj;
free((char *) arg1);
}
static swig_lua_method swig_jstf_prio_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_jstf_prio_attributes[] = {
    { "enableShrink", _wrap_jstf_prio_enableShrink_get, _wrap_jstf_prio_enableShrink_set},
    { "disableShrink", _wrap_jstf_prio_disableShrink_get, _wrap_jstf_prio_disableShrink_set},
    { "maxShrink", _wrap_jstf_prio_maxShrink_get, _wrap_jstf_prio_maxShrink_set},
    { "enableExtend", _wrap_jstf_prio_enableExtend_get, _wrap_jstf_prio_enableExtend_set},
    { "disableExtend", _wrap_jstf_prio_disableExtend_get, _wrap_jstf_prio_disableExtend_set},
    { "maxExtend", _wrap_jstf_prio_maxExtend_get, _wrap_jstf_prio_maxExtend_set},
    {0,0,0}
};
static swig_lua_class *swig_jstf_prio_bases[] = {0};
static const char *swig_jstf_prio_base_names[] = {0};
static swig_lua_class _wrap_class_jstf_prio = { "jstf_prio", &SWIGTYPE_p_jstf_prio,_wrap_new_jstf_prio, swig_delete_jstf_prio, swig_jstf_prio_methods, swig_jstf_prio_attributes, swig_jstf_prio_bases, swig_jstf_prio_base_names };

static int _wrap_jstf_lang_lang_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("jstf_lang::lang",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::lang",1,"struct jstf_lang *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("jstf_lang::lang",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_lang_set",1,SWIGTYPE_p_jstf_lang);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->lang = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_lang_lang_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("jstf_lang::lang",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::lang",1,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_lang_get",1,SWIGTYPE_p_jstf_lang);
  }
  
  result = (uint32) ((arg1)->lang);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_lang_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  struct jstf_lang *arg2 = (struct jstf_lang *) 0 ;
  
  SWIG_check_num_args("jstf_lang::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::next",1,"struct jstf_lang *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_lang::next",2,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_next_set",1,SWIGTYPE_p_jstf_lang);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_jstf_lang,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("jstf_lang_next_set",2,SWIGTYPE_p_jstf_lang);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_lang_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  struct jstf_lang *result = 0 ;
  
  SWIG_check_num_args("jstf_lang::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::next",1,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_next_get",1,SWIGTYPE_p_jstf_lang);
  }
  
  result = (struct jstf_lang *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_lang,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_lang_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("jstf_lang::cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::cnt",1,"struct jstf_lang *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("jstf_lang::cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_cnt_set",1,SWIGTYPE_p_jstf_lang);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_lang_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  int result;
  
  SWIG_check_num_args("jstf_lang::cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::cnt",1,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_cnt_get",1,SWIGTYPE_p_jstf_lang);
  }
  
  result = (int) ((arg1)->cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_lang_prios_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  struct jstf_prio *arg2 = (struct jstf_prio *) 0 ;
  
  SWIG_check_num_args("jstf_lang::prios",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::prios",1,"struct jstf_lang *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_lang::prios",2,"struct jstf_prio *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_prios_set",1,SWIGTYPE_p_jstf_lang);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_jstf_prio,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("jstf_lang_prios_set",2,SWIGTYPE_p_jstf_prio);
  }
  
  if (arg1) (arg1)->prios = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_jstf_lang_prios_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  struct jstf_prio *result = 0 ;
  
  SWIG_check_num_args("jstf_lang::prios",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_lang::prios",1,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("jstf_lang_prios_get",1,SWIGTYPE_p_jstf_lang);
  }
  
  result = (struct jstf_prio *) ((arg1)->prios);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_prio,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_jstf_lang(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *result = 0 ;
  
  SWIG_check_num_args("jstf_lang::jstf_lang",0,0)
  result = (struct jstf_lang *)calloc(1, sizeof(struct jstf_lang));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_lang,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_jstf_lang(void *obj) {
struct jstf_lang *arg1 = (struct jstf_lang *) obj;
free((char *) arg1);
}
static swig_lua_method swig_jstf_lang_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_jstf_lang_attributes[] = {
    { "lang", _wrap_jstf_lang_lang_get, _wrap_jstf_lang_lang_set},
    { "next", _wrap_jstf_lang_next_get, _wrap_jstf_lang_next_set},
    { "cnt", _wrap_jstf_lang_cnt_get, _wrap_jstf_lang_cnt_set},
    { "prios", _wrap_jstf_lang_prios_get, _wrap_jstf_lang_prios_set},
    {0,0,0}
};
static swig_lua_class *swig_jstf_lang_bases[] = {0};
static const char *swig_jstf_lang_base_names[] = {0};
static swig_lua_class _wrap_class_jstf_lang = { "jstf_lang", &SWIGTYPE_p_jstf_lang,_wrap_new_jstf_lang, swig_delete_jstf_lang, swig_jstf_lang_methods, swig_jstf_lang_attributes, swig_jstf_lang_bases, swig_jstf_lang_base_names };

static int _wrap_Justify_script_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("jstf_script::script",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::script",1,"struct jstf_script *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("jstf_script::script",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_script_set",1,SWIGTYPE_p_jstf_script);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->script = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Justify_script_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("jstf_script::script",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::script",1,"struct jstf_script *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_script_get",1,SWIGTYPE_p_jstf_script);
  }
  
  result = (uint32) ((arg1)->script);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Justify_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  struct jstf_script *arg2 = (struct jstf_script *) 0 ;
  
  SWIG_check_num_args("jstf_script::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::next",1,"struct jstf_script *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_script::next",2,"struct jstf_script *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_next_set",1,SWIGTYPE_p_jstf_script);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_jstf_script,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Justify_next_set",2,SWIGTYPE_p_jstf_script);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Justify_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  struct jstf_script *result = 0 ;
  
  SWIG_check_num_args("jstf_script::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::next",1,"struct jstf_script *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_next_get",1,SWIGTYPE_p_jstf_script);
  }
  
  result = (struct jstf_script *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_script,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Justify_extenders_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("jstf_script::extenders",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::extenders",1,"struct jstf_script *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("jstf_script::extenders",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_extenders_set",1,SWIGTYPE_p_jstf_script);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->extenders);
    if (arg2) {
      arg1->extenders = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->extenders, (const char *)arg2);
    } else {
      arg1->extenders = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Justify_extenders_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("jstf_script::extenders",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::extenders",1,"struct jstf_script *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_extenders_get",1,SWIGTYPE_p_jstf_script);
  }
  
  result = (char *) ((arg1)->extenders);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Justify_langs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  struct jstf_lang *arg2 = (struct jstf_lang *) 0 ;
  
  SWIG_check_num_args("jstf_script::langs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::langs",1,"struct jstf_script *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("jstf_script::langs",2,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_langs_set",1,SWIGTYPE_p_jstf_script);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_jstf_lang,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Justify_langs_set",2,SWIGTYPE_p_jstf_lang);
  }
  
  if (arg1) (arg1)->langs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Justify_langs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *arg1 = (struct jstf_script *) 0 ;
  struct jstf_lang *result = 0 ;
  
  SWIG_check_num_args("jstf_script::langs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("jstf_script::langs",1,"struct jstf_script *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("Justify_langs_get",1,SWIGTYPE_p_jstf_script);
  }
  
  result = (struct jstf_lang *) ((arg1)->langs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_lang,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Justify(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_script *result = 0 ;
  
  SWIG_check_num_args("jstf_script::jstf_script",0,0)
  result = (struct jstf_script *)calloc(1, sizeof(struct jstf_script));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_script,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Justify(void *obj) {
struct jstf_script *arg1 = (struct jstf_script *) obj;
free((char *) arg1);
}
static swig_lua_method swig_jstf_script_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_jstf_script_attributes[] = {
    { "script", _wrap_Justify_script_get, _wrap_Justify_script_set},
    { "next", _wrap_Justify_next_get, _wrap_Justify_next_set},
    { "extenders", _wrap_Justify_extenders_get, _wrap_Justify_extenders_set},
    { "langs", _wrap_Justify_langs_get, _wrap_Justify_langs_set},
    {0,0,0}
};
static swig_lua_class *swig_jstf_script_bases[] = {0};
static const char *swig_jstf_script_base_names[] = {0};
static swig_lua_class _wrap_class_jstf_script = { "Justify", &SWIGTYPE_p_jstf_script,_wrap_new_Justify, swig_delete_Justify, swig_jstf_script_methods, swig_jstf_script_attributes, swig_jstf_script_bases, swig_jstf_script_base_names };

static int _wrap_opentype_str_sc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct splinechar *arg2 = (struct splinechar *) 0 ;
  
  SWIG_check_num_args("opentype_str::sc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::sc",1,"struct opentype_str *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("opentype_str::sc",2,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_sc_set",1,SWIGTYPE_p_opentype_str);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("opentype_str_sc_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->sc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_sc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("opentype_str::sc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::sc",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_sc_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (struct splinechar *) ((arg1)->sc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_vr_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct vr *arg2 = (struct vr *) 0 ;
  
  SWIG_check_num_args("opentype_str::vr",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::vr",1,"struct opentype_str *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("opentype_str::vr",2,"struct vr *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_vr_set",1,SWIGTYPE_p_opentype_str);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_vr,0))){
    SWIG_fail_ptr("opentype_str_vr_set",2,SWIGTYPE_p_vr);
  }
  
  if (arg1) (arg1)->vr = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_vr_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct vr *result = 0 ;
  
  SWIG_check_num_args("opentype_str::vr",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::vr",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_vr_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (struct vr *)& ((arg1)->vr);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_vr,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_kp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct kernpair *arg2 = (struct kernpair *) 0 ;
  
  SWIG_check_num_args("opentype_str::kp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::kp",1,"struct opentype_str *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("opentype_str::kp",2,"struct kernpair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_kp_set",1,SWIGTYPE_p_opentype_str);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernpair,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("opentype_str_kp_set",2,SWIGTYPE_p_kernpair);
  }
  
  if (arg1) (arg1)->kp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_kp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct kernpair *result = 0 ;
  
  SWIG_check_num_args("opentype_str::kp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::kp",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_kp_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (struct kernpair *) ((arg1)->kp);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernpair,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_kc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct kernclass *arg2 = (struct kernclass *) 0 ;
  
  SWIG_check_num_args("opentype_str::kc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::kc",1,"struct opentype_str *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("opentype_str::kc",2,"struct kernclass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_kc_set",1,SWIGTYPE_p_opentype_str);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("opentype_str_kc_set",2,SWIGTYPE_p_kernclass);
  }
  
  if (arg1) (arg1)->kc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_kc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  struct kernclass *result = 0 ;
  
  SWIG_check_num_args("opentype_str::kc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::kc",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_kc_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (struct kernclass *) ((arg1)->kc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_prev_kc0_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("opentype_str::prev_kc0",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::prev_kc0",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::prev_kc0",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_prev_kc0_set",1,SWIGTYPE_p_opentype_str);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->prev_kc0 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_prev_kc0_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("opentype_str::prev_kc0",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::prev_kc0",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_prev_kc0_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (unsigned int) ((arg1)->prev_kc0);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_next_kc0_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("opentype_str::next_kc0",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::next_kc0",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::next_kc0",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_next_kc0_set",1,SWIGTYPE_p_opentype_str);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->next_kc0 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_next_kc0_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("opentype_str::next_kc0",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::next_kc0",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_next_kc0_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (unsigned int) ((arg1)->next_kc0);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_advance_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("opentype_str::advance_width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::advance_width",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::advance_width",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_advance_width_set",1,SWIGTYPE_p_opentype_str);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->advance_width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_advance_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 result;
  
  SWIG_check_num_args("opentype_str::advance_width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::advance_width",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_advance_width_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (int16) ((arg1)->advance_width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_kc_index_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("opentype_str::kc_index",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::kc_index",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::kc_index",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_kc_index_set",1,SWIGTYPE_p_opentype_str);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->kc_index = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_kc_index_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 result;
  
  SWIG_check_num_args("opentype_str::kc_index",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::kc_index",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_kc_index_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (int16) ((arg1)->kc_index);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_lig_pos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("opentype_str::lig_pos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::lig_pos",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::lig_pos",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_lig_pos_set",1,SWIGTYPE_p_opentype_str);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->lig_pos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_lig_pos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 result;
  
  SWIG_check_num_args("opentype_str::lig_pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::lig_pos",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_lig_pos_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (int16) ((arg1)->lig_pos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_context_pos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("opentype_str::context_pos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::context_pos",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::context_pos",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_context_pos_set",1,SWIGTYPE_p_opentype_str);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->context_pos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_context_pos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 result;
  
  SWIG_check_num_args("opentype_str::context_pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::context_pos",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_context_pos_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (int16) ((arg1)->context_pos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_orig_index_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int32 arg2 ;
  
  SWIG_check_num_args("opentype_str::orig_index",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::orig_index",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::orig_index",2,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_orig_index_set",1,SWIGTYPE_p_opentype_str);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  if (arg1) (arg1)->orig_index = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_orig_index_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int32 result;
  
  SWIG_check_num_args("opentype_str::orig_index",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::orig_index",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_orig_index_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (int32) ((arg1)->orig_index);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_fl_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("opentype_str::fl",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::fl",1,"struct opentype_str *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("opentype_str::fl",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_fl_set",1,SWIGTYPE_p_opentype_str);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"opentype_str_fl_set");
  if (arg1) (arg1)->fl = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_fl_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("opentype_str::fl",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::fl",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_fl_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (void *) ((arg1)->fl);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_line_break_after_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("opentype_str::line_break_after",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::line_break_after",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::line_break_after",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_line_break_after_set",1,SWIGTYPE_p_opentype_str);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->line_break_after = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_line_break_after_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("opentype_str::line_break_after",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::line_break_after",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_line_break_after_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (unsigned int) ((arg1)->line_break_after);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_r2l_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("opentype_str::r2l",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::r2l",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::r2l",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_r2l_set",1,SWIGTYPE_p_opentype_str);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->r2l = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_r2l_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("opentype_str::r2l",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::r2l",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_r2l_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (unsigned int) ((arg1)->r2l);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_bsln_off_set(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("opentype_str::bsln_off",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::bsln_off",1,"struct opentype_str *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("opentype_str::bsln_off",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_bsln_off_set",1,SWIGTYPE_p_opentype_str);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->bsln_off = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_opentype_str_bsln_off_get(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *arg1 = (struct opentype_str *) 0 ;
  int16 result;
  
  SWIG_check_num_args("opentype_str::bsln_off",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("opentype_str::bsln_off",1,"struct opentype_str *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_opentype_str,0))){
    SWIG_fail_ptr("opentype_str_bsln_off_get",1,SWIGTYPE_p_opentype_str);
  }
  
  result = (int16) ((arg1)->bsln_off);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_opentype_str(lua_State* L) {
  int SWIG_arg = 0;
  struct opentype_str *result = 0 ;
  
  SWIG_check_num_args("opentype_str::opentype_str",0,0)
  result = (struct opentype_str *)calloc(1, sizeof(struct opentype_str));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_opentype_str,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_opentype_str(void *obj) {
struct opentype_str *arg1 = (struct opentype_str *) obj;
free((char *) arg1);
}
static swig_lua_method swig_opentype_str_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_opentype_str_attributes[] = {
    { "sc", _wrap_opentype_str_sc_get, _wrap_opentype_str_sc_set},
    { "vr", _wrap_opentype_str_vr_get, _wrap_opentype_str_vr_set},
    { "kp", _wrap_opentype_str_kp_get, _wrap_opentype_str_kp_set},
    { "kc", _wrap_opentype_str_kc_get, _wrap_opentype_str_kc_set},
    { "prev_kc0", _wrap_opentype_str_prev_kc0_get, _wrap_opentype_str_prev_kc0_set},
    { "next_kc0", _wrap_opentype_str_next_kc0_get, _wrap_opentype_str_next_kc0_set},
    { "advance_width", _wrap_opentype_str_advance_width_get, _wrap_opentype_str_advance_width_set},
    { "kc_index", _wrap_opentype_str_kc_index_get, _wrap_opentype_str_kc_index_set},
    { "lig_pos", _wrap_opentype_str_lig_pos_get, _wrap_opentype_str_lig_pos_set},
    { "context_pos", _wrap_opentype_str_context_pos_get, _wrap_opentype_str_context_pos_set},
    { "orig_index", _wrap_opentype_str_orig_index_get, _wrap_opentype_str_orig_index_set},
    { "fl", _wrap_opentype_str_fl_get, _wrap_opentype_str_fl_set},
    { "line_break_after", _wrap_opentype_str_line_break_after_get, _wrap_opentype_str_line_break_after_set},
    { "r2l", _wrap_opentype_str_r2l_get, _wrap_opentype_str_r2l_set},
    { "bsln_off", _wrap_opentype_str_bsln_off_get, _wrap_opentype_str_bsln_off_set},
    {0,0,0}
};
static swig_lua_class *swig_opentype_str_bases[] = {0};
static const char *swig_opentype_str_base_names[] = {0};
static swig_lua_class _wrap_class_opentype_str = { "opentype_str", &SWIGTYPE_p_opentype_str,_wrap_new_opentype_str, swig_delete_opentype_str, swig_opentype_str_methods, swig_opentype_str_attributes, swig_opentype_str_bases, swig_opentype_str_base_names };

static int _wrap_macname_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  struct macname *arg2 = (struct macname *) 0 ;
  
  SWIG_check_num_args("macname::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::next",1,"struct macname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("macname::next",2,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_next_set",1,SWIGTYPE_p_macname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("macname_next_set",2,SWIGTYPE_p_macname);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_macname_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("macname::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::next",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_next_get",1,SWIGTYPE_p_macname);
  }
  
  result = (struct macname *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_macname_enc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("macname::enc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::enc",1,"struct macname *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("macname::enc",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_enc_set",1,SWIGTYPE_p_macname);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->enc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_macname_enc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("macname::enc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::enc",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_enc_get",1,SWIGTYPE_p_macname);
  }
  
  result = (uint16) ((arg1)->enc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_macname_lang_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("macname::lang",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::lang",1,"struct macname *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("macname::lang",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_lang_set",1,SWIGTYPE_p_macname);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->lang = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_macname_lang_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("macname::lang",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::lang",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_lang_get",1,SWIGTYPE_p_macname);
  }
  
  result = (uint16) ((arg1)->lang);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_macname_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("macname::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::name",1,"struct macname *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("macname::name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_name_set",1,SWIGTYPE_p_macname);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->name);
    if (arg2) {
      arg1->name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_macname_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("macname::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macname::name",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("macname_name_get",1,SWIGTYPE_p_macname);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_macname(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("macname::macname",0,0)
  result = (struct macname *)calloc(1, sizeof(struct macname));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_macname(void *obj) {
struct macname *arg1 = (struct macname *) obj;
free((char *) arg1);
}
static swig_lua_method swig_macname_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_macname_attributes[] = {
    { "next", _wrap_macname_next_get, _wrap_macname_next_set},
    { "enc", _wrap_macname_enc_get, _wrap_macname_enc_set},
    { "lang", _wrap_macname_lang_get, _wrap_macname_lang_set},
    { "name", _wrap_macname_name_get, _wrap_macname_name_set},
    {0,0,0}
};
static swig_lua_class *swig_macname_bases[] = {0};
static const char *swig_macname_base_names[] = {0};
static swig_lua_class _wrap_class_macname = { "macname", &SWIGTYPE_p_macname,_wrap_new_macname, swig_delete_macname, swig_macname_methods, swig_macname_attributes, swig_macname_bases, swig_macname_base_names };

static int _wrap_otfname_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *arg1 = (struct otfname *) 0 ;
  struct otfname *arg2 = (struct otfname *) 0 ;
  
  SWIG_check_num_args("otfname::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otfname::next",1,"struct otfname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("otfname::next",2,"struct otfname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otfname,0))){
    SWIG_fail_ptr("otfname_next_set",1,SWIGTYPE_p_otfname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otfname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("otfname_next_set",2,SWIGTYPE_p_otfname);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otfname_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *arg1 = (struct otfname *) 0 ;
  struct otfname *result = 0 ;
  
  SWIG_check_num_args("otfname::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otfname::next",1,"struct otfname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otfname,0))){
    SWIG_fail_ptr("otfname_next_get",1,SWIGTYPE_p_otfname);
  }
  
  result = (struct otfname *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otfname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otfname_lang_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *arg1 = (struct otfname *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("otfname::lang",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otfname::lang",1,"struct otfname *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otfname::lang",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otfname,0))){
    SWIG_fail_ptr("otfname_lang_set",1,SWIGTYPE_p_otfname);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->lang = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otfname_lang_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *arg1 = (struct otfname *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("otfname::lang",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otfname::lang",1,"struct otfname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otfname,0))){
    SWIG_fail_ptr("otfname_lang_get",1,SWIGTYPE_p_otfname);
  }
  
  result = (uint16) ((arg1)->lang);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otfname_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *arg1 = (struct otfname *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("otfname::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otfname::name",1,"struct otfname *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("otfname::name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otfname,0))){
    SWIG_fail_ptr("otfname_name_set",1,SWIGTYPE_p_otfname);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->name);
    if (arg2) {
      arg1->name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otfname_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *arg1 = (struct otfname *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("otfname::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otfname::name",1,"struct otfname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otfname,0))){
    SWIG_fail_ptr("otfname_name_get",1,SWIGTYPE_p_otfname);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_otfname(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *result = 0 ;
  
  SWIG_check_num_args("otfname::otfname",0,0)
  result = (struct otfname *)calloc(1, sizeof(struct otfname));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otfname,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_otfname(void *obj) {
struct otfname *arg1 = (struct otfname *) obj;
free((char *) arg1);
}
static swig_lua_method swig_otfname_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_otfname_attributes[] = {
    { "next", _wrap_otfname_next_get, _wrap_otfname_next_set},
    { "lang", _wrap_otfname_lang_get, _wrap_otfname_lang_set},
    { "name", _wrap_otfname_name_get, _wrap_otfname_name_set},
    {0,0,0}
};
static swig_lua_class *swig_otfname_bases[] = {0};
static const char *swig_otfname_base_names[] = {0};
static swig_lua_class _wrap_class_otfname = { "otfname", &SWIGTYPE_p_otfname,_wrap_new_otfname, swig_delete_otfname, swig_otfname_methods, swig_otfname_attributes, swig_otfname_bases, swig_otfname_base_names };

static int _wrap_otffeatname_tag_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("otffeatname::tag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::tag",1,"struct otffeatname *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otffeatname::tag",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_tag_set",1,SWIGTYPE_p_otffeatname);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->tag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otffeatname_tag_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("otffeatname::tag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::tag",1,"struct otffeatname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_tag_get",1,SWIGTYPE_p_otffeatname);
  }
  
  result = (uint32) ((arg1)->tag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otffeatname_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  struct otfname *arg2 = (struct otfname *) 0 ;
  
  SWIG_check_num_args("otffeatname::names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::names",1,"struct otffeatname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("otffeatname::names",2,"struct otfname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_names_set",1,SWIGTYPE_p_otffeatname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otfname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("otffeatname_names_set",2,SWIGTYPE_p_otfname);
  }
  
  if (arg1) (arg1)->names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otffeatname_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  struct otfname *result = 0 ;
  
  SWIG_check_num_args("otffeatname::names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::names",1,"struct otffeatname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_names_get",1,SWIGTYPE_p_otffeatname);
  }
  
  result = (struct otfname *) ((arg1)->names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otfname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otffeatname_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  struct otffeatname *arg2 = (struct otffeatname *) 0 ;
  
  SWIG_check_num_args("otffeatname::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::next",1,"struct otffeatname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("otffeatname::next",2,"struct otffeatname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_next_set",1,SWIGTYPE_p_otffeatname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otffeatname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("otffeatname_next_set",2,SWIGTYPE_p_otffeatname);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otffeatname_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  struct otffeatname *result = 0 ;
  
  SWIG_check_num_args("otffeatname::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::next",1,"struct otffeatname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_next_get",1,SWIGTYPE_p_otffeatname);
  }
  
  result = (struct otffeatname *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otffeatname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otffeatname_nid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("otffeatname::nid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::nid",1,"struct otffeatname *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("otffeatname::nid",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_nid_set",1,SWIGTYPE_p_otffeatname);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->nid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_otffeatname_nid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("otffeatname::nid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("otffeatname::nid",1,"struct otffeatname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("otffeatname_nid_get",1,SWIGTYPE_p_otffeatname);
  }
  
  result = (uint16) ((arg1)->nid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_otffeatname(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *result = 0 ;
  
  SWIG_check_num_args("otffeatname::otffeatname",0,0)
  result = (struct otffeatname *)calloc(1, sizeof(struct otffeatname));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otffeatname,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_otffeatname(void *obj) {
struct otffeatname *arg1 = (struct otffeatname *) obj;
free((char *) arg1);
}
static swig_lua_method swig_otffeatname_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_otffeatname_attributes[] = {
    { "tag", _wrap_otffeatname_tag_get, _wrap_otffeatname_tag_set},
    { "names", _wrap_otffeatname_names_get, _wrap_otffeatname_names_set},
    { "next", _wrap_otffeatname_next_get, _wrap_otffeatname_next_set},
    { "nid", _wrap_otffeatname_nid_get, _wrap_otffeatname_nid_set},
    {0,0,0}
};
static swig_lua_class *swig_otffeatname_bases[] = {0};
static const char *swig_otffeatname_base_names[] = {0};
static swig_lua_class _wrap_class_otffeatname = { "otffeatname", &SWIGTYPE_p_otffeatname,_wrap_new_otffeatname, swig_delete_otffeatname, swig_otffeatname_methods, swig_otffeatname_attributes, swig_otffeatname_bases, swig_otffeatname_base_names };

static int _wrap_MacFeat_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  struct macfeat *arg2 = (struct macfeat *) 0 ;
  
  SWIG_check_num_args("macfeat::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::next",1,"struct macfeat *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("macfeat::next",2,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_next_set",1,SWIGTYPE_p_macfeat);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macfeat,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MacFeat_next_set",2,SWIGTYPE_p_macfeat);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  struct macfeat *result = 0 ;
  
  SWIG_check_num_args("macfeat::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::next",1,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_next_get",1,SWIGTYPE_p_macfeat);
  }
  
  result = (struct macfeat *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macfeat,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_feature_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("macfeat::feature",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::feature",1,"struct macfeat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("macfeat::feature",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_feature_set",1,SWIGTYPE_p_macfeat);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->feature = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_feature_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("macfeat::feature",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::feature",1,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_feature_get",1,SWIGTYPE_p_macfeat);
  }
  
  result = (uint16) ((arg1)->feature);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_ismutex_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("macfeat::ismutex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::ismutex",1,"struct macfeat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("macfeat::ismutex",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_ismutex_set",1,SWIGTYPE_p_macfeat);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->ismutex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_ismutex_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("macfeat::ismutex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::ismutex",1,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_ismutex_get",1,SWIGTYPE_p_macfeat);
  }
  
  result = (uint8) ((arg1)->ismutex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_default_setting_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("macfeat::default_setting",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::default_setting",1,"struct macfeat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("macfeat::default_setting",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_default_setting_set",1,SWIGTYPE_p_macfeat);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->default_setting = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_default_setting_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("macfeat::default_setting",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::default_setting",1,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_default_setting_get",1,SWIGTYPE_p_macfeat);
  }
  
  result = (uint8) ((arg1)->default_setting);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_strid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("macfeat::strid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::strid",1,"struct macfeat *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("macfeat::strid",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_strid_set",1,SWIGTYPE_p_macfeat);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->strid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_strid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("macfeat::strid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::strid",1,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_strid_get",1,SWIGTYPE_p_macfeat);
  }
  
  result = (uint16) ((arg1)->strid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_featname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  struct macname *arg2 = (struct macname *) 0 ;
  
  SWIG_check_num_args("macfeat::featname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::featname",1,"struct macfeat *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("macfeat::featname",2,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_featname_set",1,SWIGTYPE_p_macfeat);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MacFeat_featname_set",2,SWIGTYPE_p_macname);
  }
  
  if (arg1) (arg1)->featname = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_featname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("macfeat::featname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::featname",1,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_featname_get",1,SWIGTYPE_p_macfeat);
  }
  
  result = (struct macname *) ((arg1)->featname);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_get(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *arg1 = (struct macfeat *) 0 ;
  MacFeat_settings *result = 0 ;
  
  SWIG_check_num_args("macfeat::settings",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("macfeat::settings",1,"struct macfeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeat_settings_get",1,SWIGTYPE_p_macfeat);
  }
  
  result = (MacFeat_settings *) ((arg1)->settings);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MacFeat_settings,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MacFeat(lua_State* L) {
  int SWIG_arg = 0;
  struct macfeat *result = 0 ;
  
  SWIG_check_num_args("macfeat::macfeat",0,0)
  result = (struct macfeat *)calloc(1, sizeof(struct macfeat));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macfeat,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MacFeat(void *obj) {
struct macfeat *arg1 = (struct macfeat *) obj;
free((char *) arg1);
}
static swig_lua_method swig_macfeat_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_macfeat_attributes[] = {
    { "next", _wrap_MacFeat_next_get, _wrap_MacFeat_next_set},
    { "feature", _wrap_MacFeat_feature_get, _wrap_MacFeat_feature_set},
    { "ismutex", _wrap_MacFeat_ismutex_get, _wrap_MacFeat_ismutex_set},
    { "default_setting", _wrap_MacFeat_default_setting_get, _wrap_MacFeat_default_setting_set},
    { "strid", _wrap_MacFeat_strid_get, _wrap_MacFeat_strid_set},
    { "featname", _wrap_MacFeat_featname_get, _wrap_MacFeat_featname_set},
    { "settings", _wrap_MacFeat_settings_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_macfeat_bases[] = {0};
static const char *swig_macfeat_base_names[] = {0};
static swig_lua_class _wrap_class_macfeat = { "MacFeat", &SWIGTYPE_p_macfeat,_wrap_new_MacFeat, swig_delete_MacFeat, swig_macfeat_methods, swig_macfeat_attributes, swig_macfeat_bases, swig_macfeat_base_names };

static int _wrap_MacFeat_settings_next_set(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  struct macsetting *arg2 = (struct macsetting *) 0 ;
  
  SWIG_check_num_args("MacFeat_settings::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::next",1,"MacFeat_settings *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MacFeat_settings::next",2,"struct macsetting *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_next_set",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macsetting,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MacFeat_settings_next_set",2,SWIGTYPE_p_macsetting);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_next_get(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  struct macsetting *result = 0 ;
  
  SWIG_check_num_args("MacFeat_settings::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::next",1,"MacFeat_settings *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_next_get",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  result = (struct macsetting *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macsetting,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_setting_set(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("MacFeat_settings::setting",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::setting",1,"MacFeat_settings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MacFeat_settings::setting",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_setting_set",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->setting = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_setting_get(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("MacFeat_settings::setting",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::setting",1,"MacFeat_settings *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_setting_get",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  result = (uint16) ((arg1)->setting);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_strid_set(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("MacFeat_settings::strid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::strid",1,"MacFeat_settings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MacFeat_settings::strid",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_strid_set",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->strid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_strid_get(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("MacFeat_settings::strid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::strid",1,"MacFeat_settings *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_strid_get",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  result = (uint16) ((arg1)->strid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_setname_set(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  struct macname *arg2 = (struct macname *) 0 ;
  
  SWIG_check_num_args("MacFeat_settings::setname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::setname",1,"MacFeat_settings *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MacFeat_settings::setname",2,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_setname_set",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MacFeat_settings_setname_set",2,SWIGTYPE_p_macname);
  }
  
  if (arg1) (arg1)->setname = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_setname_get(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("MacFeat_settings::setname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::setname",1,"MacFeat_settings *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_setname_get",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  result = (struct macname *) ((arg1)->setname);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_initially_enabled_set(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("MacFeat_settings::initially_enabled",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::initially_enabled",1,"MacFeat_settings *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MacFeat_settings::initially_enabled",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_initially_enabled_set",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->initially_enabled = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeat_settings_initially_enabled_get(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *arg1 = (MacFeat_settings *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("MacFeat_settings::initially_enabled",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeat_settings::initially_enabled",1,"MacFeat_settings *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MacFeat_settings,0))){
    SWIG_fail_ptr("MacFeat_settings_initially_enabled_get",1,SWIGTYPE_p_MacFeat_settings);
  }
  
  result = (unsigned int) ((arg1)->initially_enabled);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MacFeat_settings(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat_settings *result = 0 ;
  
  SWIG_check_num_args("MacFeat_settings::MacFeat_settings",0,0)
  result = (MacFeat_settings *)calloc(1, sizeof(MacFeat_settings));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MacFeat_settings,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MacFeat_settings(void *obj) {
MacFeat_settings *arg1 = (MacFeat_settings *) obj;
free((char *) arg1);
}
static swig_lua_method swig_MacFeat_settings_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_MacFeat_settings_attributes[] = {
    { "next", _wrap_MacFeat_settings_next_get, _wrap_MacFeat_settings_next_set},
    { "setting", _wrap_MacFeat_settings_setting_get, _wrap_MacFeat_settings_setting_set},
    { "strid", _wrap_MacFeat_settings_strid_get, _wrap_MacFeat_settings_strid_set},
    { "setname", _wrap_MacFeat_settings_setname_get, _wrap_MacFeat_settings_setname_set},
    { "initially_enabled", _wrap_MacFeat_settings_initially_enabled_get, _wrap_MacFeat_settings_initially_enabled_set},
    {0,0,0}
};
static swig_lua_class *swig_MacFeat_settings_bases[] = {0};
static const char *swig_MacFeat_settings_base_names[] = {0};
static swig_lua_class _wrap_class_MacFeat_settings = { "MacFeat_settings", &SWIGTYPE_p_MacFeat_settings,_wrap_new_MacFeat_settings, swig_delete_MacFeat_settings, swig_MacFeat_settings_methods, swig_MacFeat_settings_attributes, swig_MacFeat_settings_bases, swig_MacFeat_settings_base_names };

static int _wrap_BDFRefChar_checked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refbdfc::checked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::checked",1,"struct refbdfc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refbdfc::checked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_checked_set",1,SWIGTYPE_p_refbdfc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->checked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_checked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refbdfc::checked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::checked",1,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_checked_get",1,SWIGTYPE_p_refbdfc);
  }
  
  result = (unsigned int) ((arg1)->checked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_selected_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refbdfc::selected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::selected",1,"struct refbdfc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refbdfc::selected",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_selected_set",1,SWIGTYPE_p_refbdfc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->selected = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_selected_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refbdfc::selected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::selected",1,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_selected_get",1,SWIGTYPE_p_refbdfc);
  }
  
  result = (unsigned int) ((arg1)->selected);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_xoff_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  int8 arg2 ;
  
  SWIG_check_num_args("refbdfc::xoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::xoff",1,"struct refbdfc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refbdfc::xoff",2,"int8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_xoff_set",1,SWIGTYPE_p_refbdfc);
  }
  
  arg2 = (int8)lua_tonumber(L, 2);
  if (arg1) (arg1)->xoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_xoff_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  int8 result;
  
  SWIG_check_num_args("refbdfc::xoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::xoff",1,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_xoff_get",1,SWIGTYPE_p_refbdfc);
  }
  
  result = (int8) ((arg1)->xoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_yoff_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  int8 arg2 ;
  
  SWIG_check_num_args("refbdfc::yoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::yoff",1,"struct refbdfc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refbdfc::yoff",2,"int8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_yoff_set",1,SWIGTYPE_p_refbdfc);
  }
  
  arg2 = (int8)lua_tonumber(L, 2);
  if (arg1) (arg1)->yoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_yoff_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  int8 result;
  
  SWIG_check_num_args("refbdfc::yoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::yoff",1,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_yoff_get",1,SWIGTYPE_p_refbdfc);
  }
  
  result = (int8) ((arg1)->yoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_gid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("refbdfc::gid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::gid",1,"struct refbdfc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refbdfc::gid",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_gid_set",1,SWIGTYPE_p_refbdfc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->gid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_gid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("refbdfc::gid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::gid",1,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_gid_get",1,SWIGTYPE_p_refbdfc);
  }
  
  result = (uint16) ((arg1)->gid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  struct refbdfc *arg2 = (struct refbdfc *) 0 ;
  
  SWIG_check_num_args("refbdfc::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::next",1,"struct refbdfc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("refbdfc::next",2,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_next_set",1,SWIGTYPE_p_refbdfc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refbdfc,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFRefChar_next_set",2,SWIGTYPE_p_refbdfc);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  struct refbdfc *result = 0 ;
  
  SWIG_check_num_args("refbdfc::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::next",1,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_next_get",1,SWIGTYPE_p_refbdfc);
  }
  
  result = (struct refbdfc *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refbdfc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_bdfc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  struct bdfchar *arg2 = (struct bdfchar *) 0 ;
  
  SWIG_check_num_args("refbdfc::bdfc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::bdfc",1,"struct refbdfc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("refbdfc::bdfc",2,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_bdfc_set",1,SWIGTYPE_p_refbdfc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFRefChar_bdfc_set",2,SWIGTYPE_p_bdfchar);
  }
  
  if (arg1) (arg1)->bdfc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFRefChar_bdfc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *arg1 = (struct refbdfc *) 0 ;
  struct bdfchar *result = 0 ;
  
  SWIG_check_num_args("refbdfc::bdfc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refbdfc::bdfc",1,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BDFRefChar_bdfc_get",1,SWIGTYPE_p_refbdfc);
  }
  
  result = (struct bdfchar *) ((arg1)->bdfc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BDFRefChar(lua_State* L) {
  int SWIG_arg = 0;
  struct refbdfc *result = 0 ;
  
  SWIG_check_num_args("refbdfc::refbdfc",0,0)
  result = (struct refbdfc *)calloc(1, sizeof(struct refbdfc));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refbdfc,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BDFRefChar(void *obj) {
struct refbdfc *arg1 = (struct refbdfc *) obj;
free((char *) arg1);
}
static swig_lua_method swig_refbdfc_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_refbdfc_attributes[] = {
    { "checked", _wrap_BDFRefChar_checked_get, _wrap_BDFRefChar_checked_set},
    { "selected", _wrap_BDFRefChar_selected_get, _wrap_BDFRefChar_selected_set},
    { "xoff", _wrap_BDFRefChar_xoff_get, _wrap_BDFRefChar_xoff_set},
    { "yoff", _wrap_BDFRefChar_yoff_get, _wrap_BDFRefChar_yoff_set},
    { "gid", _wrap_BDFRefChar_gid_get, _wrap_BDFRefChar_gid_set},
    { "next", _wrap_BDFRefChar_next_get, _wrap_BDFRefChar_next_set},
    { "bdfc", _wrap_BDFRefChar_bdfc_get, _wrap_BDFRefChar_bdfc_set},
    {0,0,0}
};
static swig_lua_class *swig_refbdfc_bases[] = {0};
static const char *swig_refbdfc_base_names[] = {0};
static swig_lua_class _wrap_class_refbdfc = { "BDFRefChar", &SWIGTYPE_p_refbdfc,_wrap_new_BDFRefChar, swig_delete_BDFRefChar, swig_refbdfc_methods, swig_refbdfc_attributes, swig_refbdfc_bases, swig_refbdfc_base_names };

static int _wrap_BDFChar_sc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct splinechar *arg2 = (struct splinechar *) 0 ;
  
  SWIG_check_num_args("bdfchar::sc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::sc",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::sc",2,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_sc_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_sc_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->sc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_sc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("bdfchar::sc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::sc",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_sc_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (struct splinechar *) ((arg1)->sc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_xmin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdfchar::xmin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::xmin",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::xmin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_xmin_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->xmin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_xmin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdfchar::xmin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::xmin",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_xmin_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int16) ((arg1)->xmin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_xmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdfchar::xmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::xmax",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::xmax",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_xmax_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->xmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_xmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdfchar::xmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::xmax",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_xmax_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int16) ((arg1)->xmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_ymin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdfchar::ymin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::ymin",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::ymin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_ymin_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ymin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_ymin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdfchar::ymin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::ymin",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_ymin_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int16) ((arg1)->ymin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_ymax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdfchar::ymax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::ymax",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::ymax",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_ymax_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ymax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_ymax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdfchar::ymax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::ymax",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_ymax_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int16) ((arg1)->ymax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdfchar::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::width",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::width",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_width_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdfchar::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::width",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_width_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int16) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_bytes_per_line_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdfchar::bytes_per_line",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::bytes_per_line",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::bytes_per_line",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_bytes_per_line_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->bytes_per_line = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_bytes_per_line_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdfchar::bytes_per_line",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::bytes_per_line",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_bytes_per_line_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int16) ((arg1)->bytes_per_line);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_bitmap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("bdfchar::bitmap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::bitmap",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::bitmap",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_bitmap_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_bitmap_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->bitmap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_bitmap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("bdfchar::bitmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::bitmap",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_bitmap_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (uint8 *) ((arg1)->bitmap);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_refs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct refbdfc *arg2 = (struct refbdfc *) 0 ;
  
  SWIG_check_num_args("bdfchar::refs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::refs",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::refs",2,"struct refbdfc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_refs_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refbdfc,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_refs_set",2,SWIGTYPE_p_refbdfc);
  }
  
  if (arg1) (arg1)->refs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_refs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct refbdfc *result = 0 ;
  
  SWIG_check_num_args("bdfchar::refs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::refs",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_refs_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (struct refbdfc *) ((arg1)->refs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refbdfc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_orig_pos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bdfchar::orig_pos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::orig_pos",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::orig_pos",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_orig_pos_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->orig_pos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_orig_pos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int result;
  
  SWIG_check_num_args("bdfchar::orig_pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::orig_pos",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_orig_pos_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int) ((arg1)->orig_pos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_pixelsize_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdfchar::pixelsize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::pixelsize",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::pixelsize",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_pixelsize_set",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->pixelsize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_pixelsize_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdfchar::pixelsize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::pixelsize",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_pixelsize_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int16) ((arg1)->pixelsize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_views_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct bitmapview *arg2 = (struct bitmapview *) 0 ;
  
  SWIG_check_num_args("bdfchar::views",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::views",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::views",2,"struct bitmapview *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_views_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bitmapview,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_views_set",2,SWIGTYPE_p_bitmapview);
  }
  
  if (arg1) (arg1)->views = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_views_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct bitmapview *result = 0 ;
  
  SWIG_check_num_args("bdfchar::views",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::views",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_views_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (struct bitmapview *) ((arg1)->views);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bitmapview,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_undoes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct undoes *arg2 = (struct undoes *) 0 ;
  
  SWIG_check_num_args("bdfchar::undoes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::undoes",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::undoes",2,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_undoes_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_undoes_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->undoes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_undoes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("bdfchar::undoes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::undoes",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_undoes_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (struct undoes *) ((arg1)->undoes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_redoes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct undoes *arg2 = (struct undoes *) 0 ;
  
  SWIG_check_num_args("bdfchar::redoes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::redoes",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::redoes",2,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_redoes_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_redoes_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->redoes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_redoes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("bdfchar::redoes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::redoes",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_redoes_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (struct undoes *) ((arg1)->redoes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_changed_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdfchar::changed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::changed",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::changed",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_changed_set",1,SWIGTYPE_p_bdfchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_changed_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdfchar::changed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::changed",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_changed_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (unsigned int) ((arg1)->changed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_byte_data_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdfchar::byte_data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::byte_data",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::byte_data",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_byte_data_set",1,SWIGTYPE_p_bdfchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->byte_data = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_byte_data_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdfchar::byte_data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::byte_data",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_byte_data_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (unsigned int) ((arg1)->byte_data);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_widthgroup_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdfchar::widthgroup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::widthgroup",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::widthgroup",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_widthgroup_set",1,SWIGTYPE_p_bdfchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->widthgroup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_widthgroup_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdfchar::widthgroup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::widthgroup",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_widthgroup_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (unsigned int) ((arg1)->widthgroup);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_isreference_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdfchar::isreference",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::isreference",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::isreference",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_isreference_set",1,SWIGTYPE_p_bdfchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->isreference = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_isreference_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdfchar::isreference",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::isreference",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_isreference_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (unsigned int) ((arg1)->isreference);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdfchar::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::ticked",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_ticked_set",1,SWIGTYPE_p_bdfchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdfchar::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::ticked",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_ticked_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_depth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("bdfchar::depth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::depth",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::depth",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_depth_set",1,SWIGTYPE_p_bdfchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->depth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_depth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("bdfchar::depth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::depth",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_depth_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (uint8) ((arg1)->depth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_vwidth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("bdfchar::vwidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::vwidth",1,"struct bdfchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfchar::vwidth",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_vwidth_set",1,SWIGTYPE_p_bdfchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->vwidth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_vwidth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("bdfchar::vwidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::vwidth",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_vwidth_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (uint16) ((arg1)->vwidth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_selection_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  BDFFloat *arg2 = (BDFFloat *) 0 ;
  
  SWIG_check_num_args("bdfchar::selection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::selection",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::selection",2,"BDFFloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_selection_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffloat,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_selection_set",2,SWIGTYPE_p_bdffloat);
  }
  
  if (arg1) (arg1)->selection = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_selection_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  BDFFloat *result = 0 ;
  
  SWIG_check_num_args("bdfchar::selection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::selection",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_selection_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (BDFFloat *) ((arg1)->selection);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffloat,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_backup_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  BDFFloat *arg2 = (BDFFloat *) 0 ;
  
  SWIG_check_num_args("bdfchar::backup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::backup",1,"struct bdfchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdfchar::backup",2,"BDFFloat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_backup_set",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffloat,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_backup_set",2,SWIGTYPE_p_bdffloat);
  }
  
  if (arg1) (arg1)->backup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_backup_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  BDFFloat *result = 0 ;
  
  SWIG_check_num_args("bdfchar::backup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::backup",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_backup_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (BDFFloat *) ((arg1)->backup);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffloat,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_dependents_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *arg1 = (struct bdfchar *) 0 ;
  BDFChar_dependents *result = 0 ;
  
  SWIG_check_num_args("bdfchar::dependents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfchar::dependents",1,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFChar_dependents_get",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (BDFChar_dependents *) ((arg1)->dependents);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_BDFChar_dependents,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BDFChar(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfchar *result = 0 ;
  
  SWIG_check_num_args("bdfchar::bdfchar",0,0)
  result = (struct bdfchar *)calloc(1, sizeof(struct bdfchar));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BDFChar(void *obj) {
struct bdfchar *arg1 = (struct bdfchar *) obj;
free((char *) arg1);
}
static swig_lua_method swig_bdfchar_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_bdfchar_attributes[] = {
    { "sc", _wrap_BDFChar_sc_get, _wrap_BDFChar_sc_set},
    { "xmin", _wrap_BDFChar_xmin_get, _wrap_BDFChar_xmin_set},
    { "xmax", _wrap_BDFChar_xmax_get, _wrap_BDFChar_xmax_set},
    { "ymin", _wrap_BDFChar_ymin_get, _wrap_BDFChar_ymin_set},
    { "ymax", _wrap_BDFChar_ymax_get, _wrap_BDFChar_ymax_set},
    { "width", _wrap_BDFChar_width_get, _wrap_BDFChar_width_set},
    { "bytes_per_line", _wrap_BDFChar_bytes_per_line_get, _wrap_BDFChar_bytes_per_line_set},
    { "bitmap", _wrap_BDFChar_bitmap_get, _wrap_BDFChar_bitmap_set},
    { "refs", _wrap_BDFChar_refs_get, _wrap_BDFChar_refs_set},
    { "orig_pos", _wrap_BDFChar_orig_pos_get, _wrap_BDFChar_orig_pos_set},
    { "pixelsize", _wrap_BDFChar_pixelsize_get, _wrap_BDFChar_pixelsize_set},
    { "views", _wrap_BDFChar_views_get, _wrap_BDFChar_views_set},
    { "undoes", _wrap_BDFChar_undoes_get, _wrap_BDFChar_undoes_set},
    { "redoes", _wrap_BDFChar_redoes_get, _wrap_BDFChar_redoes_set},
    { "changed", _wrap_BDFChar_changed_get, _wrap_BDFChar_changed_set},
    { "byte_data", _wrap_BDFChar_byte_data_get, _wrap_BDFChar_byte_data_set},
    { "widthgroup", _wrap_BDFChar_widthgroup_get, _wrap_BDFChar_widthgroup_set},
    { "isreference", _wrap_BDFChar_isreference_get, _wrap_BDFChar_isreference_set},
    { "ticked", _wrap_BDFChar_ticked_get, _wrap_BDFChar_ticked_set},
    { "depth", _wrap_BDFChar_depth_get, _wrap_BDFChar_depth_set},
    { "vwidth", _wrap_BDFChar_vwidth_get, _wrap_BDFChar_vwidth_set},
    { "selection", _wrap_BDFChar_selection_get, _wrap_BDFChar_selection_set},
    { "backup", _wrap_BDFChar_backup_get, _wrap_BDFChar_backup_set},
    { "dependents", _wrap_BDFChar_dependents_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_bdfchar_bases[] = {0};
static const char *swig_bdfchar_base_names[] = {0};
static swig_lua_class _wrap_class_bdfchar = { "BDFChar", &SWIGTYPE_p_bdfchar,_wrap_new_BDFChar, swig_delete_BDFChar, swig_bdfchar_methods, swig_bdfchar_attributes, swig_bdfchar_bases, swig_bdfchar_base_names };

static int _wrap_BDFChar_dependents_bc_set(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar_dependents *arg1 = (BDFChar_dependents *) 0 ;
  struct bdfchar *arg2 = (struct bdfchar *) 0 ;
  
  SWIG_check_num_args("BDFChar_dependents::bc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFChar_dependents::bc",1,"BDFChar_dependents *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BDFChar_dependents::bc",2,"struct bdfchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFChar_dependents,0))){
    SWIG_fail_ptr("BDFChar_dependents_bc_set",1,SWIGTYPE_p_BDFChar_dependents);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_dependents_bc_set",2,SWIGTYPE_p_bdfchar);
  }
  
  if (arg1) (arg1)->bc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_dependents_bc_get(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar_dependents *arg1 = (BDFChar_dependents *) 0 ;
  struct bdfchar *result = 0 ;
  
  SWIG_check_num_args("BDFChar_dependents::bc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFChar_dependents::bc",1,"BDFChar_dependents *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFChar_dependents,0))){
    SWIG_fail_ptr("BDFChar_dependents_bc_get",1,SWIGTYPE_p_BDFChar_dependents);
  }
  
  result = (struct bdfchar *) ((arg1)->bc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_dependents_next_set(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar_dependents *arg1 = (BDFChar_dependents *) 0 ;
  struct bdfcharlist *arg2 = (struct bdfcharlist *) 0 ;
  
  SWIG_check_num_args("BDFChar_dependents::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFChar_dependents::next",1,"BDFChar_dependents *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BDFChar_dependents::next",2,"struct bdfcharlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFChar_dependents,0))){
    SWIG_fail_ptr("BDFChar_dependents_next_set",1,SWIGTYPE_p_BDFChar_dependents);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfcharlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFChar_dependents_next_set",2,SWIGTYPE_p_bdfcharlist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFChar_dependents_next_get(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar_dependents *arg1 = (BDFChar_dependents *) 0 ;
  struct bdfcharlist *result = 0 ;
  
  SWIG_check_num_args("BDFChar_dependents::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFChar_dependents::next",1,"BDFChar_dependents *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFChar_dependents,0))){
    SWIG_fail_ptr("BDFChar_dependents_next_get",1,SWIGTYPE_p_BDFChar_dependents);
  }
  
  result = (struct bdfcharlist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfcharlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BDFChar_dependents(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar_dependents *result = 0 ;
  
  SWIG_check_num_args("BDFChar_dependents::BDFChar_dependents",0,0)
  result = (BDFChar_dependents *)calloc(1, sizeof(BDFChar_dependents));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_BDFChar_dependents,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BDFChar_dependents(void *obj) {
BDFChar_dependents *arg1 = (BDFChar_dependents *) obj;
free((char *) arg1);
}
static swig_lua_method swig_BDFChar_dependents_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_BDFChar_dependents_attributes[] = {
    { "bc", _wrap_BDFChar_dependents_bc_get, _wrap_BDFChar_dependents_bc_set},
    { "next", _wrap_BDFChar_dependents_next_get, _wrap_BDFChar_dependents_next_set},
    {0,0,0}
};
static swig_lua_class *swig_BDFChar_dependents_bases[] = {0};
static const char *swig_BDFChar_dependents_base_names[] = {0};
static swig_lua_class _wrap_class_BDFChar_dependents = { "BDFChar_dependents", &SWIGTYPE_p_BDFChar_dependents,_wrap_new_BDFChar_dependents, swig_delete_BDFChar_dependents, swig_BDFChar_dependents_methods, swig_BDFChar_dependents_attributes, swig_BDFChar_dependents_bases, swig_BDFChar_dependents_base_names };

static int _wrap_Undoes_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  struct undoes *arg2 = (struct undoes *) 0 ;
  
  SWIG_check_num_args("undoes::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::next",1,"struct undoes *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("undoes::next",2,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_next_set",1,SWIGTYPE_p_undoes);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_next_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("undoes::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::next",1,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_next_get",1,SWIGTYPE_p_undoes);
  }
  
  result = (struct undoes *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_was_modified_set(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("undoes::was_modified",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::was_modified",1,"struct undoes *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("undoes::was_modified",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_was_modified_set",1,SWIGTYPE_p_undoes);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->was_modified = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_was_modified_get(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("undoes::was_modified",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::was_modified",1,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_was_modified_get",1,SWIGTYPE_p_undoes);
  }
  
  result = (unsigned int) ((arg1)->was_modified);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_was_order2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("undoes::was_order2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::was_order2",1,"struct undoes *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("undoes::was_order2",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_was_order2_set",1,SWIGTYPE_p_undoes);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->was_order2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_was_order2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("undoes::was_order2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::was_order2",1,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_was_order2_get",1,SWIGTYPE_p_undoes);
  }
  
  result = (unsigned int) ((arg1)->was_order2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_copied_from_set(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  struct splinefont *arg2 = (struct splinefont *) 0 ;
  
  SWIG_check_num_args("undoes::copied_from",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::copied_from",1,"struct undoes *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("undoes::copied_from",2,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_copied_from_set",1,SWIGTYPE_p_undoes);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_copied_from_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->copied_from = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_copied_from_get(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  struct splinefont *result = 0 ;
  
  SWIG_check_num_args("undoes::copied_from",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::copied_from",1,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_copied_from_get",1,SWIGTYPE_p_undoes);
  }
  
  result = (struct splinefont *) ((arg1)->copied_from);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_get(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *arg1 = (struct undoes *) 0 ;
  Undoes_u *result = 0 ;
  
  SWIG_check_num_args("undoes::u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("undoes::u",1,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("Undoes_u_get",1,SWIGTYPE_p_undoes);
  }
  
  result = (Undoes_u *)& ((arg1)->u);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Undoes(lua_State* L) {
  int SWIG_arg = 0;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("undoes::undoes",0,0)
  result = (struct undoes *)calloc(1, sizeof(struct undoes));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Undoes(void *obj) {
struct undoes *arg1 = (struct undoes *) obj;
free((char *) arg1);
}
static swig_lua_method swig_undoes_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_undoes_attributes[] = {
    { "next", _wrap_Undoes_next_get, _wrap_Undoes_next_set},
    { "was_modified", _wrap_Undoes_was_modified_get, _wrap_Undoes_was_modified_set},
    { "was_order2", _wrap_Undoes_was_order2_get, _wrap_Undoes_was_order2_set},
    { "copied_from", _wrap_Undoes_copied_from_get, _wrap_Undoes_copied_from_set},
    { "u", _wrap_Undoes_u_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_undoes_bases[] = {0};
static const char *swig_undoes_base_names[] = {0};
static swig_lua_class _wrap_class_undoes = { "Undoes", &SWIGTYPE_p_undoes,_wrap_new_Undoes, swig_delete_Undoes, swig_undoes_methods, swig_undoes_attributes, swig_undoes_bases, swig_undoes_base_names };

static int _wrap_Undoes_u_width_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Undoes_u::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::width",1,"Undoes_u *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u::width",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_width_set",1,SWIGTYPE_p_Undoes_u);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_width_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  int result;
  
  SWIG_check_num_args("Undoes_u::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::width",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_width_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (int) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_lbearing_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Undoes_u::lbearing",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::lbearing",1,"Undoes_u *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u::lbearing",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_lbearing_set",1,SWIGTYPE_p_Undoes_u);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lbearing = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_lbearing_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  int result;
  
  SWIG_check_num_args("Undoes_u::lbearing",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::lbearing",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_lbearing_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (int) ((arg1)->lbearing);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_rbearing_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Undoes_u::rbearing",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::rbearing",1,"Undoes_u *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u::rbearing",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_rbearing_set",1,SWIGTYPE_p_Undoes_u);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->rbearing = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_rbearing_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  int result;
  
  SWIG_check_num_args("Undoes_u::rbearing",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::rbearing",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_rbearing_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (int) ((arg1)->rbearing);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_bmpstate_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  BDFChar *arg2 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("Undoes_u::bmpstate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::bmpstate",1,"Undoes_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u::bmpstate",2,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_bmpstate_set",1,SWIGTYPE_p_Undoes_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("Undoes_u_bmpstate_set",2,SWIGTYPE_p_bdfchar);
  }
  
  if (arg1) (arg1)->bmpstate = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_bmpstate_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("Undoes_u::bmpstate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::bmpstate",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_bmpstate_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (BDFChar *)& ((arg1)->bmpstate);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_bitmap_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("Undoes_u::bitmap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::bitmap",1,"Undoes_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u::bitmap",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_bitmap_set",1,SWIGTYPE_p_Undoes_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_bitmap_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->bitmap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_bitmap_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("Undoes_u::bitmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::bitmap",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_bitmap_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (uint8 *) ((arg1)->bitmap);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  Undoes_u_state *result = 0 ;
  
  SWIG_check_num_args("Undoes_u::state",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::state",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_state_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (Undoes_u_state *)& ((arg1)->state);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_state,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_composit_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  Undoes_u_composit *result = 0 ;
  
  SWIG_check_num_args("Undoes_u::composit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::composit",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_composit_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (Undoes_u_composit *)& ((arg1)->composit);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_composit,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_multiple_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  Undoes_u_multiple *result = 0 ;
  
  SWIG_check_num_args("Undoes_u::multiple",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::multiple",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_multiple_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (Undoes_u_multiple *)& ((arg1)->multiple);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_multiple,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *arg1 = (Undoes_u *) 0 ;
  Undoes_u_possub *result = 0 ;
  
  SWIG_check_num_args("Undoes_u::possub",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u::possub",1,"Undoes_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u,0))){
    SWIG_fail_ptr("Undoes_u_possub_get",1,SWIGTYPE_p_Undoes_u);
  }
  
  result = (Undoes_u_possub *)& ((arg1)->possub);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_possub,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Undoes_u(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u *result = 0 ;
  
  SWIG_check_num_args("Undoes_u::Undoes_u",0,0)
  result = (Undoes_u *)calloc(1, sizeof(Undoes_u));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Undoes_u(void *obj) {
Undoes_u *arg1 = (Undoes_u *) obj;
free((char *) arg1);
}
static swig_lua_method swig_Undoes_u_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Undoes_u_attributes[] = {
    { "width", _wrap_Undoes_u_width_get, _wrap_Undoes_u_width_set},
    { "lbearing", _wrap_Undoes_u_lbearing_get, _wrap_Undoes_u_lbearing_set},
    { "rbearing", _wrap_Undoes_u_rbearing_get, _wrap_Undoes_u_rbearing_set},
    { "bmpstate", _wrap_Undoes_u_bmpstate_get, _wrap_Undoes_u_bmpstate_set},
    { "bitmap", _wrap_Undoes_u_bitmap_get, _wrap_Undoes_u_bitmap_set},
    { "state", _wrap_Undoes_u_state_get, SWIG_Lua_set_immutable},
    { "composit", _wrap_Undoes_u_composit_get, SWIG_Lua_set_immutable},
    { "multiple", _wrap_Undoes_u_multiple_get, SWIG_Lua_set_immutable},
    { "possub", _wrap_Undoes_u_possub_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_Undoes_u_bases[] = {0};
static const char *swig_Undoes_u_base_names[] = {0};
static swig_lua_class _wrap_class_Undoes_u = { "Undoes_u", &SWIGTYPE_p_Undoes_u,_wrap_new_Undoes_u, swig_delete_Undoes_u, swig_Undoes_u_methods, swig_Undoes_u_attributes, swig_Undoes_u_bases, swig_Undoes_u_base_names };

static int _wrap_Undoes_u_possub_pst_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  enum possub_type arg2 ;
  
  SWIG_check_num_args("Undoes_u_possub::pst",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::pst",1,"Undoes_u_possub *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_possub::pst",2,"enum possub_type");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_pst_set",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  arg2 = (enum possub_type)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pst = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_pst_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  enum possub_type result;
  
  SWIG_check_num_args("Undoes_u_possub::pst",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::pst",1,"Undoes_u_possub *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_pst_get",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  result = (enum possub_type) ((arg1)->pst);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_data_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("Undoes_u_possub::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::data",1,"Undoes_u_possub *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_possub::data",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_data_set",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("Undoes_u_possub_data_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->data = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_data_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("Undoes_u_possub::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::data",1,"Undoes_u_possub *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_data_get",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  result = (char **) ((arg1)->data);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_more_pst_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  struct undoes *arg2 = (struct undoes *) 0 ;
  
  SWIG_check_num_args("Undoes_u_possub::more_pst",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::more_pst",1,"Undoes_u_possub *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_possub::more_pst",2,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_more_pst_set",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_possub_more_pst_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->more_pst = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_more_pst_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_possub::more_pst",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::more_pst",1,"Undoes_u_possub *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_more_pst_get",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  result = (struct undoes *) ((arg1)->more_pst);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("Undoes_u_possub::cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::cnt",1,"Undoes_u_possub *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_possub::cnt",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_cnt_set",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  if (arg1) (arg1)->cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  short result;
  
  SWIG_check_num_args("Undoes_u_possub::cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::cnt",1,"Undoes_u_possub *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_cnt_get",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  result = (short) ((arg1)->cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_max_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("Undoes_u_possub::max",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::max",1,"Undoes_u_possub *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_possub::max",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_max_set",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  if (arg1) (arg1)->max = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_possub_max_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *arg1 = (Undoes_u_possub *) 0 ;
  short result;
  
  SWIG_check_num_args("Undoes_u_possub::max",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_possub::max",1,"Undoes_u_possub *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_possub,0))){
    SWIG_fail_ptr("Undoes_u_possub_max_get",1,SWIGTYPE_p_Undoes_u_possub);
  }
  
  result = (short) ((arg1)->max);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Undoes_u_possub(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_possub *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_possub::Undoes_u_possub",0,0)
  result = (Undoes_u_possub *)calloc(1, sizeof(Undoes_u_possub));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_possub,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Undoes_u_possub(void *obj) {
Undoes_u_possub *arg1 = (Undoes_u_possub *) obj;
free((char *) arg1);
}
static swig_lua_method swig_Undoes_u_possub_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Undoes_u_possub_attributes[] = {
    { "pst", _wrap_Undoes_u_possub_pst_get, _wrap_Undoes_u_possub_pst_set},
    { "data", _wrap_Undoes_u_possub_data_get, _wrap_Undoes_u_possub_data_set},
    { "more_pst", _wrap_Undoes_u_possub_more_pst_get, _wrap_Undoes_u_possub_more_pst_set},
    { "cnt", _wrap_Undoes_u_possub_cnt_get, _wrap_Undoes_u_possub_cnt_set},
    { "max", _wrap_Undoes_u_possub_max_get, _wrap_Undoes_u_possub_max_set},
    {0,0,0}
};
static swig_lua_class *swig_Undoes_u_possub_bases[] = {0};
static const char *swig_Undoes_u_possub_base_names[] = {0};
static swig_lua_class _wrap_class_Undoes_u_possub = { "Undoes_u_possub", &SWIGTYPE_p_Undoes_u_possub,_wrap_new_Undoes_u_possub, swig_delete_Undoes_u_possub, swig_Undoes_u_possub_methods, swig_Undoes_u_possub_attributes, swig_Undoes_u_possub_bases, swig_Undoes_u_possub_base_names };

static int _wrap_Undoes_u_multiple_mult_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_multiple *arg1 = (Undoes_u_multiple *) 0 ;
  struct undoes *arg2 = (struct undoes *) 0 ;
  
  SWIG_check_num_args("Undoes_u_multiple::mult",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_multiple::mult",1,"Undoes_u_multiple *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_multiple::mult",2,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_multiple,0))){
    SWIG_fail_ptr("Undoes_u_multiple_mult_set",1,SWIGTYPE_p_Undoes_u_multiple);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_multiple_mult_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->mult = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_multiple_mult_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_multiple *arg1 = (Undoes_u_multiple *) 0 ;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_multiple::mult",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_multiple::mult",1,"Undoes_u_multiple *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_multiple,0))){
    SWIG_fail_ptr("Undoes_u_multiple_mult_get",1,SWIGTYPE_p_Undoes_u_multiple);
  }
  
  result = (struct undoes *) ((arg1)->mult);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Undoes_u_multiple(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_multiple *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_multiple::Undoes_u_multiple",0,0)
  result = (Undoes_u_multiple *)calloc(1, sizeof(Undoes_u_multiple));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_multiple,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Undoes_u_multiple(void *obj) {
Undoes_u_multiple *arg1 = (Undoes_u_multiple *) obj;
free((char *) arg1);
}
static swig_lua_method swig_Undoes_u_multiple_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Undoes_u_multiple_attributes[] = {
    { "mult", _wrap_Undoes_u_multiple_mult_get, _wrap_Undoes_u_multiple_mult_set},
    {0,0,0}
};
static swig_lua_class *swig_Undoes_u_multiple_bases[] = {0};
static const char *swig_Undoes_u_multiple_base_names[] = {0};
static swig_lua_class _wrap_class_Undoes_u_multiple = { "Undoes_u_multiple", &SWIGTYPE_p_Undoes_u_multiple,_wrap_new_Undoes_u_multiple, swig_delete_Undoes_u_multiple, swig_Undoes_u_multiple_methods, swig_Undoes_u_multiple_attributes, swig_Undoes_u_multiple_bases, swig_Undoes_u_multiple_base_names };

static int _wrap_Undoes_u_composit_state_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_composit *arg1 = (Undoes_u_composit *) 0 ;
  struct undoes *arg2 = (struct undoes *) 0 ;
  
  SWIG_check_num_args("Undoes_u_composit::state",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_composit::state",1,"Undoes_u_composit *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_composit::state",2,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_composit,0))){
    SWIG_fail_ptr("Undoes_u_composit_state_set",1,SWIGTYPE_p_Undoes_u_composit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_composit_state_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->state = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_composit_state_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_composit *arg1 = (Undoes_u_composit *) 0 ;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_composit::state",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_composit::state",1,"Undoes_u_composit *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_composit,0))){
    SWIG_fail_ptr("Undoes_u_composit_state_get",1,SWIGTYPE_p_Undoes_u_composit);
  }
  
  result = (struct undoes *) ((arg1)->state);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_composit_bitmaps_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_composit *arg1 = (Undoes_u_composit *) 0 ;
  struct undoes *arg2 = (struct undoes *) 0 ;
  
  SWIG_check_num_args("Undoes_u_composit::bitmaps",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_composit::bitmaps",1,"Undoes_u_composit *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_composit::bitmaps",2,"struct undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_composit,0))){
    SWIG_fail_ptr("Undoes_u_composit_bitmaps_set",1,SWIGTYPE_p_Undoes_u_composit);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_composit_bitmaps_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->bitmaps = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_composit_bitmaps_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_composit *arg1 = (Undoes_u_composit *) 0 ;
  struct undoes *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_composit::bitmaps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_composit::bitmaps",1,"Undoes_u_composit *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_composit,0))){
    SWIG_fail_ptr("Undoes_u_composit_bitmaps_get",1,SWIGTYPE_p_Undoes_u_composit);
  }
  
  result = (struct undoes *) ((arg1)->bitmaps);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Undoes_u_composit(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_composit *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_composit::Undoes_u_composit",0,0)
  result = (Undoes_u_composit *)calloc(1, sizeof(Undoes_u_composit));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_composit,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Undoes_u_composit(void *obj) {
Undoes_u_composit *arg1 = (Undoes_u_composit *) obj;
free((char *) arg1);
}
static swig_lua_method swig_Undoes_u_composit_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Undoes_u_composit_attributes[] = {
    { "state", _wrap_Undoes_u_composit_state_get, _wrap_Undoes_u_composit_state_set},
    { "bitmaps", _wrap_Undoes_u_composit_bitmaps_get, _wrap_Undoes_u_composit_bitmaps_set},
    {0,0,0}
};
static swig_lua_class *swig_Undoes_u_composit_bases[] = {0};
static const char *swig_Undoes_u_composit_base_names[] = {0};
static swig_lua_class _wrap_class_Undoes_u_composit = { "Undoes_u_composit", &SWIGTYPE_p_Undoes_u_composit,_wrap_new_Undoes_u_composit, swig_delete_Undoes_u_composit, swig_Undoes_u_composit_methods, swig_Undoes_u_composit_attributes, swig_Undoes_u_composit_bases, swig_Undoes_u_composit_base_names };

static int _wrap_Undoes_u_state_width_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("Undoes_u_state::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::width",1,"Undoes_u_state *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_state::width",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_width_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_width_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int16 result;
  
  SWIG_check_num_args("Undoes_u_state::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::width",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_width_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (int16) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_vwidth_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("Undoes_u_state::vwidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::vwidth",1,"Undoes_u_state *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_state::vwidth",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_vwidth_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->vwidth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_vwidth_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int16 result;
  
  SWIG_check_num_args("Undoes_u_state::vwidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::vwidth",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_vwidth_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (int16) ((arg1)->vwidth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_lbearingchange_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("Undoes_u_state::lbearingchange",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::lbearingchange",1,"Undoes_u_state *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_state::lbearingchange",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_lbearingchange_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->lbearingchange = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_lbearingchange_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int16 result;
  
  SWIG_check_num_args("Undoes_u_state::lbearingchange",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::lbearingchange",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_lbearingchange_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (int16) ((arg1)->lbearingchange);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_unicodeenc_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Undoes_u_state::unicodeenc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::unicodeenc",1,"Undoes_u_state *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_state::unicodeenc",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_unicodeenc_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unicodeenc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_unicodeenc_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int result;
  
  SWIG_check_num_args("Undoes_u_state::unicodeenc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::unicodeenc",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_unicodeenc_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (int) ((arg1)->unicodeenc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_charname_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::charname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::charname",1,"Undoes_u_state *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Undoes_u_state::charname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_charname_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->charname);
    if (arg2) {
      arg1->charname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->charname, (const char *)arg2);
    } else {
      arg1->charname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_charname_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::charname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::charname",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_charname_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (char *) ((arg1)->charname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_comment_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::comment",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::comment",1,"Undoes_u_state *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("Undoes_u_state::comment",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_comment_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->comment);
    if (arg2) {
      arg1->comment = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->comment, (const char *)arg2);
    } else {
      arg1->comment = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_comment_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::comment",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::comment",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_comment_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (char *) ((arg1)->comment);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_possub_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  PST *arg2 = (PST *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::possub",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::possub",1,"Undoes_u_state *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_state::possub",2,"PST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_possub_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_pst,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_state_possub_set",2,SWIGTYPE_p_generic_pst);
  }
  
  if (arg1) (arg1)->possub = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_possub_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  PST *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::possub",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::possub",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_possub_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (PST *) ((arg1)->possub);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_pst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_splines_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  struct splinepointlist *arg2 = (struct splinepointlist *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::splines",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::splines",1,"Undoes_u_state *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_state::splines",2,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_splines_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_state_splines_set",2,SWIGTYPE_p_splinepointlist);
  }
  
  if (arg1) (arg1)->splines = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_splines_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  struct splinepointlist *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::splines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::splines",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_splines_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (struct splinepointlist *) ((arg1)->splines);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_refs_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  struct refchar *arg2 = (struct refchar *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::refs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::refs",1,"Undoes_u_state *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_state::refs",2,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_refs_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refchar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_state_refs_set",2,SWIGTYPE_p_refchar);
  }
  
  if (arg1) (arg1)->refs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_refs_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  struct refchar *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::refs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::refs",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_refs_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (struct refchar *) ((arg1)->refs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_images_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  struct imagelist *arg2 = (struct imagelist *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::images",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::images",1,"Undoes_u_state *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_state::images",2,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_images_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_imagelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_state_images_set",2,SWIGTYPE_p_imagelist);
  }
  
  if (arg1) (arg1)->images = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_images_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  struct imagelist *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::images",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::images",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_images_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (struct imagelist *) ((arg1)->images);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_imagelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_hints_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::hints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::hints",1,"Undoes_u_state *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_state::hints",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_hints_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"Undoes_u_state_hints_set");
  if (arg1) (arg1)->hints = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_hints_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::hints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::hints",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_hints_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (void *) ((arg1)->hints);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_instrs_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::instrs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::instrs",1,"Undoes_u_state *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_state::instrs",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_instrs_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_state_instrs_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->instrs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_instrs_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::instrs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::instrs",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_instrs_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (uint8 *) ((arg1)->instrs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_instrs_len_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Undoes_u_state::instrs_len",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::instrs_len",1,"Undoes_u_state *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Undoes_u_state::instrs_len",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_instrs_len_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->instrs_len = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_instrs_len_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  int result;
  
  SWIG_check_num_args("Undoes_u_state::instrs_len",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::instrs_len",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_instrs_len_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (int) ((arg1)->instrs_len);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_anchor_set(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  AnchorPoint *arg2 = (AnchorPoint *) 0 ;
  
  SWIG_check_num_args("Undoes_u_state::anchor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::anchor",1,"Undoes_u_state *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Undoes_u_state::anchor",2,"AnchorPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_anchor_set",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorpoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Undoes_u_state_anchor_set",2,SWIGTYPE_p_anchorpoint);
  }
  
  if (arg1) (arg1)->anchor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Undoes_u_state_anchor_get(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *arg1 = (Undoes_u_state *) 0 ;
  AnchorPoint *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::anchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Undoes_u_state::anchor",1,"Undoes_u_state *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Undoes_u_state,0))){
    SWIG_fail_ptr("Undoes_u_state_anchor_get",1,SWIGTYPE_p_Undoes_u_state);
  }
  
  result = (AnchorPoint *) ((arg1)->anchor);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Undoes_u_state(lua_State* L) {
  int SWIG_arg = 0;
  Undoes_u_state *result = 0 ;
  
  SWIG_check_num_args("Undoes_u_state::Undoes_u_state",0,0)
  result = (Undoes_u_state *)calloc(1, sizeof(Undoes_u_state));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Undoes_u_state,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Undoes_u_state(void *obj) {
Undoes_u_state *arg1 = (Undoes_u_state *) obj;
free((char *) arg1);
}
static swig_lua_method swig_Undoes_u_state_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Undoes_u_state_attributes[] = {
    { "width", _wrap_Undoes_u_state_width_get, _wrap_Undoes_u_state_width_set},
    { "vwidth", _wrap_Undoes_u_state_vwidth_get, _wrap_Undoes_u_state_vwidth_set},
    { "lbearingchange", _wrap_Undoes_u_state_lbearingchange_get, _wrap_Undoes_u_state_lbearingchange_set},
    { "unicodeenc", _wrap_Undoes_u_state_unicodeenc_get, _wrap_Undoes_u_state_unicodeenc_set},
    { "charname", _wrap_Undoes_u_state_charname_get, _wrap_Undoes_u_state_charname_set},
    { "comment", _wrap_Undoes_u_state_comment_get, _wrap_Undoes_u_state_comment_set},
    { "possub", _wrap_Undoes_u_state_possub_get, _wrap_Undoes_u_state_possub_set},
    { "splines", _wrap_Undoes_u_state_splines_get, _wrap_Undoes_u_state_splines_set},
    { "refs", _wrap_Undoes_u_state_refs_get, _wrap_Undoes_u_state_refs_set},
    { "images", _wrap_Undoes_u_state_images_get, _wrap_Undoes_u_state_images_set},
    { "hints", _wrap_Undoes_u_state_hints_get, _wrap_Undoes_u_state_hints_set},
    { "instrs", _wrap_Undoes_u_state_instrs_get, _wrap_Undoes_u_state_instrs_set},
    { "instrs_len", _wrap_Undoes_u_state_instrs_len_get, _wrap_Undoes_u_state_instrs_len_set},
    { "anchor", _wrap_Undoes_u_state_anchor_get, _wrap_Undoes_u_state_anchor_set},
    {0,0,0}
};
static swig_lua_class *swig_Undoes_u_state_bases[] = {0};
static const char *swig_Undoes_u_state_base_names[] = {0};
static swig_lua_class _wrap_class_Undoes_u_state = { "Undoes_u_state", &SWIGTYPE_p_Undoes_u_state,_wrap_new_Undoes_u_state, swig_delete_Undoes_u_state, swig_Undoes_u_state_methods, swig_Undoes_u_state_attributes, swig_Undoes_u_state_bases, swig_Undoes_u_state_base_names };

static int _wrap_Encoding_enc_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("enc::enc_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::enc_name",1,"struct enc *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("enc::enc_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_enc_name_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->enc_name);
    if (arg2) {
      arg1->enc_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->enc_name, (const char *)arg2);
    } else {
      arg1->enc_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_enc_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("enc::enc_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::enc_name",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_enc_name_get",1,SWIGTYPE_p_enc);
  }
  
  result = (char *) ((arg1)->enc_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_char_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("enc::char_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::char_cnt",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::char_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_char_cnt_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->char_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_char_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int result;
  
  SWIG_check_num_args("enc::char_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::char_cnt",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_char_cnt_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int) ((arg1)->char_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_unicode_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int32 *arg2 = (int32 *) 0 ;
  
  SWIG_check_num_args("enc::unicode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::unicode",1,"struct enc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("enc::unicode",2,"int32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_unicode_set",1,SWIGTYPE_p_enc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Encoding_unicode_set",2,SWIGTYPE_p_int);
  }
  
  if (arg1) (arg1)->unicode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_unicode_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int32 *result = 0 ;
  
  SWIG_check_num_args("enc::unicode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::unicode",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_unicode_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int32 *) ((arg1)->unicode);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_psnames_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("enc::psnames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::psnames",1,"struct enc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("enc::psnames",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_psnames_set",1,SWIGTYPE_p_enc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("Encoding_psnames_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->psnames = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_psnames_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("enc::psnames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::psnames",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_psnames_get",1,SWIGTYPE_p_enc);
  }
  
  result = (char **) ((arg1)->psnames);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  struct enc *arg2 = (struct enc *) 0 ;
  
  SWIG_check_num_args("enc::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::next",1,"struct enc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("enc::next",2,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_next_set",1,SWIGTYPE_p_enc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_enc,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Encoding_next_set",2,SWIGTYPE_p_enc);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  struct enc *result = 0 ;
  
  SWIG_check_num_args("enc::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::next",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_next_get",1,SWIGTYPE_p_enc);
  }
  
  result = (struct enc *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_builtin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::builtin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::builtin",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::builtin",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_builtin_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->builtin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_builtin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::builtin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::builtin",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_builtin_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->builtin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_hidden_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::hidden",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::hidden",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::hidden",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_hidden_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hidden = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_hidden_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::hidden",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::hidden",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_hidden_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->hidden);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_only_1byte_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::only_1byte",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::only_1byte",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::only_1byte",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_only_1byte_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->only_1byte = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_only_1byte_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::only_1byte",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::only_1byte",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_only_1byte_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->only_1byte);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_has_1byte_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::has_1byte",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::has_1byte",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::has_1byte",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_has_1byte_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->has_1byte = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_has_1byte_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::has_1byte",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::has_1byte",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_has_1byte_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->has_1byte);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_has_2byte_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::has_2byte",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::has_2byte",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::has_2byte",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_has_2byte_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->has_2byte = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_has_2byte_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::has_2byte",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::has_2byte",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_has_2byte_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->has_2byte);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_unicodebmp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_unicodebmp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_unicodebmp",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_unicodebmp",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_unicodebmp_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_unicodebmp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_unicodebmp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_unicodebmp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_unicodebmp",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_unicodebmp_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_unicodebmp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_unicodefull_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_unicodefull",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_unicodefull",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_unicodefull",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_unicodefull_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_unicodefull = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_unicodefull_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_unicodefull",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_unicodefull",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_unicodefull_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_unicodefull);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_custom_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_custom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_custom",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_custom",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_custom_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_custom = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_custom_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_custom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_custom",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_custom_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_custom);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_original_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_original",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_original",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_original",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_original_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_original = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_original_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_original",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_original",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_original_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_original);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_compact_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_compact",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_compact",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_compact",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_compact_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_compact = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_compact_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_compact",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_compact",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_compact_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_compact);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_japanese_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_japanese",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_japanese",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_japanese",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_japanese_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_japanese = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_japanese_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_japanese",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_japanese",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_japanese_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_japanese);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_korean_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_korean",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_korean",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_korean",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_korean_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_korean = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_korean_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_korean",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_korean",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_korean_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_korean);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_tradchinese_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_tradchinese",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_tradchinese",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_tradchinese",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_tradchinese_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_tradchinese = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_tradchinese_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_tradchinese",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_tradchinese",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_tradchinese_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_tradchinese);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_simplechinese_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_simplechinese",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_simplechinese",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_simplechinese",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_simplechinese_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_simplechinese = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_simplechinese_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_simplechinese",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_simplechinese",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_simplechinese_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_simplechinese);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_iso_2022_escape_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("enc::iso_2022_escape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::iso_2022_escape",1,"struct enc *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("enc::iso_2022_escape",2,"char [8]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_iso_2022_escape_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->iso_2022_escape, (const char *)arg2, 8-1);
      arg1->iso_2022_escape[8-1] = 0;
    } else {
      arg1->iso_2022_escape[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_iso_2022_escape_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("enc::iso_2022_escape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::iso_2022_escape",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_iso_2022_escape_get",1,SWIGTYPE_p_enc);
  }
  
  result = (char *)(char *) ((arg1)->iso_2022_escape);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_iso_2022_escape_len_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("enc::iso_2022_escape_len",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::iso_2022_escape_len",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::iso_2022_escape_len",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_iso_2022_escape_len_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->iso_2022_escape_len = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_iso_2022_escape_len_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int result;
  
  SWIG_check_num_args("enc::iso_2022_escape_len",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::iso_2022_escape_len",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_iso_2022_escape_len_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int) ((arg1)->iso_2022_escape_len);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_low_page_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("enc::low_page",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::low_page",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::low_page",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_low_page_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->low_page = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_low_page_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int result;
  
  SWIG_check_num_args("enc::low_page",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::low_page",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_low_page_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int) ((arg1)->low_page);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_high_page_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("enc::high_page",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::high_page",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::high_page",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_high_page_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->high_page = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_high_page_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int result;
  
  SWIG_check_num_args("enc::high_page",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::high_page",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_high_page_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int) ((arg1)->high_page);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_iconv_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("enc::iconv_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::iconv_name",1,"struct enc *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("enc::iconv_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_iconv_name_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->iconv_name);
    if (arg2) {
      arg1->iconv_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->iconv_name, (const char *)arg2);
    } else {
      arg1->iconv_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_iconv_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("enc::iconv_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::iconv_name",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_iconv_name_get",1,SWIGTYPE_p_enc);
  }
  
  result = (char *) ((arg1)->iconv_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_tounicode_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  iconv_t *arg2 = (iconv_t *) 0 ;
  
  SWIG_check_num_args("enc::tounicode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::tounicode",1,"struct enc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("enc::tounicode",2,"iconv_t *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_tounicode_set",1,SWIGTYPE_p_enc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_iconv_t,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Encoding_tounicode_set",2,SWIGTYPE_p_iconv_t);
  }
  
  if (arg1) (arg1)->tounicode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_tounicode_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  iconv_t *result = 0 ;
  
  SWIG_check_num_args("enc::tounicode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::tounicode",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_tounicode_get",1,SWIGTYPE_p_enc);
  }
  
  result = (iconv_t *) ((arg1)->tounicode);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_iconv_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_fromunicode_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  iconv_t *arg2 = (iconv_t *) 0 ;
  
  SWIG_check_num_args("enc::fromunicode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::fromunicode",1,"struct enc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("enc::fromunicode",2,"iconv_t *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_fromunicode_set",1,SWIGTYPE_p_enc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_iconv_t,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Encoding_fromunicode_set",2,SWIGTYPE_p_iconv_t);
  }
  
  if (arg1) (arg1)->fromunicode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_fromunicode_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  iconv_t *result = 0 ;
  
  SWIG_check_num_args("enc::fromunicode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::fromunicode",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_fromunicode_get",1,SWIGTYPE_p_enc);
  }
  
  result = (iconv_t *) ((arg1)->fromunicode);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_iconv_t,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_tounicode_func_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int (*arg2)(int) = (int (*)(int)) 0 ;
  
  SWIG_check_num_args("enc::tounicode_func",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::tounicode_func",1,"struct enc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("enc::tounicode_func",2,"int (*)(int)");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_tounicode_func_set",1,SWIGTYPE_p_enc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_int__int,0))){
    SWIG_fail_ptr("Encoding_tounicode_func_set",2,SWIGTYPE_p_f_int__int);
  }
  
  if (arg1) (arg1)->tounicode_func = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_tounicode_func_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int (*result)(int) = 0 ;
  
  SWIG_check_num_args("enc::tounicode_func",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::tounicode_func",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_tounicode_func_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int (*)(int)) ((arg1)->tounicode_func);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_f_int__int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_fromunicode_func_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int (*arg2)(int) = (int (*)(int)) 0 ;
  
  SWIG_check_num_args("enc::fromunicode_func",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::fromunicode_func",1,"struct enc *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("enc::fromunicode_func",2,"int (*)(int)");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_fromunicode_func_set",1,SWIGTYPE_p_enc);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_f_int__int,0))){
    SWIG_fail_ptr("Encoding_fromunicode_func_set",2,SWIGTYPE_p_f_int__int);
  }
  
  if (arg1) (arg1)->fromunicode_func = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_fromunicode_func_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int (*result)(int) = 0 ;
  
  SWIG_check_num_args("enc::fromunicode_func",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::fromunicode_func",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_fromunicode_func_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int (*)(int)) ((arg1)->fromunicode_func);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_f_int__int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_temporary_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("enc::is_temporary",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_temporary",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::is_temporary",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_temporary_set",1,SWIGTYPE_p_enc);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_temporary = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_is_temporary_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("enc::is_temporary",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::is_temporary",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_is_temporary_get",1,SWIGTYPE_p_enc);
  }
  
  result = (unsigned int) ((arg1)->is_temporary);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_char_max_set(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("enc::char_max",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::char_max",1,"struct enc *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("enc::char_max",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_char_max_set",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->char_max = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Encoding_char_max_get(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *arg1 = (struct enc *) 0 ;
  int result;
  
  SWIG_check_num_args("enc::char_max",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enc::char_max",1,"struct enc *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("Encoding_char_max_get",1,SWIGTYPE_p_enc);
  }
  
  result = (int) ((arg1)->char_max);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Encoding(lua_State* L) {
  int SWIG_arg = 0;
  struct enc *result = 0 ;
  
  SWIG_check_num_args("enc::enc",0,0)
  result = (struct enc *)calloc(1, sizeof(struct enc));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Encoding(void *obj) {
struct enc *arg1 = (struct enc *) obj;
free((char *) arg1);
}
static swig_lua_method swig_enc_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_enc_attributes[] = {
    { "enc_name", _wrap_Encoding_enc_name_get, _wrap_Encoding_enc_name_set},
    { "char_cnt", _wrap_Encoding_char_cnt_get, _wrap_Encoding_char_cnt_set},
    { "unicode", _wrap_Encoding_unicode_get, _wrap_Encoding_unicode_set},
    { "psnames", _wrap_Encoding_psnames_get, _wrap_Encoding_psnames_set},
    { "next", _wrap_Encoding_next_get, _wrap_Encoding_next_set},
    { "builtin", _wrap_Encoding_builtin_get, _wrap_Encoding_builtin_set},
    { "hidden", _wrap_Encoding_hidden_get, _wrap_Encoding_hidden_set},
    { "only_1byte", _wrap_Encoding_only_1byte_get, _wrap_Encoding_only_1byte_set},
    { "has_1byte", _wrap_Encoding_has_1byte_get, _wrap_Encoding_has_1byte_set},
    { "has_2byte", _wrap_Encoding_has_2byte_get, _wrap_Encoding_has_2byte_set},
    { "is_unicodebmp", _wrap_Encoding_is_unicodebmp_get, _wrap_Encoding_is_unicodebmp_set},
    { "is_unicodefull", _wrap_Encoding_is_unicodefull_get, _wrap_Encoding_is_unicodefull_set},
    { "is_custom", _wrap_Encoding_is_custom_get, _wrap_Encoding_is_custom_set},
    { "is_original", _wrap_Encoding_is_original_get, _wrap_Encoding_is_original_set},
    { "is_compact", _wrap_Encoding_is_compact_get, _wrap_Encoding_is_compact_set},
    { "is_japanese", _wrap_Encoding_is_japanese_get, _wrap_Encoding_is_japanese_set},
    { "is_korean", _wrap_Encoding_is_korean_get, _wrap_Encoding_is_korean_set},
    { "is_tradchinese", _wrap_Encoding_is_tradchinese_get, _wrap_Encoding_is_tradchinese_set},
    { "is_simplechinese", _wrap_Encoding_is_simplechinese_get, _wrap_Encoding_is_simplechinese_set},
    { "iso_2022_escape", _wrap_Encoding_iso_2022_escape_get, _wrap_Encoding_iso_2022_escape_set},
    { "iso_2022_escape_len", _wrap_Encoding_iso_2022_escape_len_get, _wrap_Encoding_iso_2022_escape_len_set},
    { "low_page", _wrap_Encoding_low_page_get, _wrap_Encoding_low_page_set},
    { "high_page", _wrap_Encoding_high_page_get, _wrap_Encoding_high_page_set},
    { "iconv_name", _wrap_Encoding_iconv_name_get, _wrap_Encoding_iconv_name_set},
    { "tounicode", _wrap_Encoding_tounicode_get, _wrap_Encoding_tounicode_set},
    { "fromunicode", _wrap_Encoding_fromunicode_get, _wrap_Encoding_fromunicode_set},
    { "tounicode_func", _wrap_Encoding_tounicode_func_get, _wrap_Encoding_tounicode_func_set},
    { "fromunicode_func", _wrap_Encoding_fromunicode_func_get, _wrap_Encoding_fromunicode_func_set},
    { "is_temporary", _wrap_Encoding_is_temporary_get, _wrap_Encoding_is_temporary_set},
    { "char_max", _wrap_Encoding_char_max_get, _wrap_Encoding_char_max_set},
    {0,0,0}
};
static swig_lua_class *swig_enc_bases[] = {0};
static const char *swig_enc_base_names[] = {0};
static swig_lua_class _wrap_class_enc = { "Encoding", &SWIGTYPE_p_enc,_wrap_new_Encoding, swig_delete_Encoding, swig_enc_methods, swig_enc_attributes, swig_enc_bases, swig_enc_base_names };

static int _wrap_NameList_basedon_set(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  struct namelist *arg2 = (struct namelist *) 0 ;
  
  SWIG_check_num_args("namelist::basedon",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::basedon",1,"struct namelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("namelist::basedon",2,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_basedon_set",1,SWIGTYPE_p_namelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_namelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("NameList_basedon_set",2,SWIGTYPE_p_namelist);
  }
  
  if (arg1) (arg1)->basedon = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_basedon_get(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  struct namelist *result = 0 ;
  
  SWIG_check_num_args("namelist::basedon",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::basedon",1,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_basedon_get",1,SWIGTYPE_p_namelist);
  }
  
  result = (struct namelist *) ((arg1)->basedon);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_namelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_title_set(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("namelist::title",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::title",1,"struct namelist *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("namelist::title",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_title_set",1,SWIGTYPE_p_namelist);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->title);
    if (arg2) {
      arg1->title = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->title, (const char *)arg2);
    } else {
      arg1->title = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_title_get(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("namelist::title",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::title",1,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_title_get",1,SWIGTYPE_p_namelist);
  }
  
  result = (char *) ((arg1)->title);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_unicode_set(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  char ****arg2 ;
  
  SWIG_check_num_args("namelist::unicode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::unicode",1,"struct namelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("namelist::unicode",2,"char const ***[17]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_unicode_set",1,SWIGTYPE_p_namelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_p_p_char,0))){
    SWIG_fail_ptr("NameList_unicode_set",2,SWIGTYPE_p_p_p_p_char);
  }
  
  {
    size_t ii;
    char const *** *b = (char const *** *) arg1->unicode;
    for (ii = 0; ii < (size_t)17; ii++) b[ii] = *((char const *** *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_unicode_get(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  char ****result = 0 ;
  
  SWIG_check_num_args("namelist::unicode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::unicode",1,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_unicode_get",1,SWIGTYPE_p_namelist);
  }
  
  result = (char ****)(char ****) ((arg1)->unicode);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  struct namelist *arg2 = (struct namelist *) 0 ;
  
  SWIG_check_num_args("namelist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::next",1,"struct namelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("namelist::next",2,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_next_set",1,SWIGTYPE_p_namelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_namelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("NameList_next_set",2,SWIGTYPE_p_namelist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  struct namelist *result = 0 ;
  
  SWIG_check_num_args("namelist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::next",1,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_next_get",1,SWIGTYPE_p_namelist);
  }
  
  result = (struct namelist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_namelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_uses_unicode_set(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("namelist::uses_unicode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::uses_unicode",1,"struct namelist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("namelist::uses_unicode",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_uses_unicode_set",1,SWIGTYPE_p_namelist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->uses_unicode = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_uses_unicode_get(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  int result;
  
  SWIG_check_num_args("namelist::uses_unicode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::uses_unicode",1,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_uses_unicode_get",1,SWIGTYPE_p_namelist);
  }
  
  result = (int) ((arg1)->uses_unicode);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_a_utf8_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("namelist::a_utf8_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::a_utf8_name",1,"struct namelist *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("namelist::a_utf8_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_a_utf8_name_set",1,SWIGTYPE_p_namelist);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->a_utf8_name);
    if (arg2) {
      arg1->a_utf8_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->a_utf8_name, (const char *)arg2);
    } else {
      arg1->a_utf8_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_a_utf8_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("namelist::a_utf8_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::a_utf8_name",1,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_a_utf8_name_get",1,SWIGTYPE_p_namelist);
  }
  
  result = (char *) ((arg1)->a_utf8_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_renames_get(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *arg1 = (struct namelist *) 0 ;
  NameList_renames *result = 0 ;
  
  SWIG_check_num_args("namelist::renames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("namelist::renames",1,"struct namelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("NameList_renames_get",1,SWIGTYPE_p_namelist);
  }
  
  result = (NameList_renames *) ((arg1)->renames);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_NameList_renames,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_NameList(lua_State* L) {
  int SWIG_arg = 0;
  struct namelist *result = 0 ;
  
  SWIG_check_num_args("namelist::namelist",0,0)
  result = (struct namelist *)calloc(1, sizeof(struct namelist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_namelist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_NameList(void *obj) {
struct namelist *arg1 = (struct namelist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_namelist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_namelist_attributes[] = {
    { "basedon", _wrap_NameList_basedon_get, _wrap_NameList_basedon_set},
    { "title", _wrap_NameList_title_get, _wrap_NameList_title_set},
    { "unicode", _wrap_NameList_unicode_get, _wrap_NameList_unicode_set},
    { "next", _wrap_NameList_next_get, _wrap_NameList_next_set},
    { "uses_unicode", _wrap_NameList_uses_unicode_get, _wrap_NameList_uses_unicode_set},
    { "a_utf8_name", _wrap_NameList_a_utf8_name_get, _wrap_NameList_a_utf8_name_set},
    { "renames", _wrap_NameList_renames_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_namelist_bases[] = {0};
static const char *swig_namelist_base_names[] = {0};
static swig_lua_class _wrap_class_namelist = { "NameList", &SWIGTYPE_p_namelist,_wrap_new_NameList, swig_delete_NameList, swig_namelist_methods, swig_namelist_attributes, swig_namelist_bases, swig_namelist_base_names };

static int _wrap_NameList_renames_from_set(lua_State* L) {
  int SWIG_arg = 0;
  NameList_renames *arg1 = (NameList_renames *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("NameList_renames::from",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NameList_renames::from",1,"NameList_renames *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("NameList_renames::from",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_NameList_renames,0))){
    SWIG_fail_ptr("NameList_renames_from_set",1,SWIGTYPE_p_NameList_renames);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->from);
    if (arg2) {
      arg1->from = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->from, (const char *)arg2);
    } else {
      arg1->from = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_renames_from_get(lua_State* L) {
  int SWIG_arg = 0;
  NameList_renames *arg1 = (NameList_renames *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("NameList_renames::from",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NameList_renames::from",1,"NameList_renames *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_NameList_renames,0))){
    SWIG_fail_ptr("NameList_renames_from_get",1,SWIGTYPE_p_NameList_renames);
  }
  
  result = (char *) ((arg1)->from);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_renames_to_set(lua_State* L) {
  int SWIG_arg = 0;
  NameList_renames *arg1 = (NameList_renames *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("NameList_renames::to",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NameList_renames::to",1,"NameList_renames *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("NameList_renames::to",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_NameList_renames,0))){
    SWIG_fail_ptr("NameList_renames_to_set",1,SWIGTYPE_p_NameList_renames);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->to);
    if (arg2) {
      arg1->to = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->to, (const char *)arg2);
    } else {
      arg1->to = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameList_renames_to_get(lua_State* L) {
  int SWIG_arg = 0;
  NameList_renames *arg1 = (NameList_renames *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("NameList_renames::to",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NameList_renames::to",1,"NameList_renames *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_NameList_renames,0))){
    SWIG_fail_ptr("NameList_renames_to_get",1,SWIGTYPE_p_NameList_renames);
  }
  
  result = (char *) ((arg1)->to);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_NameList_renames(lua_State* L) {
  int SWIG_arg = 0;
  NameList_renames *result = 0 ;
  
  SWIG_check_num_args("NameList_renames::NameList_renames",0,0)
  result = (NameList_renames *)calloc(1, sizeof(NameList_renames));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_NameList_renames,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_NameList_renames(void *obj) {
NameList_renames *arg1 = (NameList_renames *) obj;
free((char *) arg1);
}
static swig_lua_method swig_NameList_renames_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_NameList_renames_attributes[] = {
    { "from", _wrap_NameList_renames_from_get, _wrap_NameList_renames_from_set},
    { "to", _wrap_NameList_renames_to_get, _wrap_NameList_renames_to_set},
    {0,0,0}
};
static swig_lua_class *swig_NameList_renames_bases[] = {0};
static const char *swig_NameList_renames_base_names[] = {0};
static swig_lua_class _wrap_class_NameList_renames = { "NameList_renames", &SWIGTYPE_p_NameList_renames,_wrap_new_NameList_renames, swig_delete_NameList_renames, swig_NameList_renames_methods, swig_NameList_renames_attributes, swig_NameList_renames_bases, swig_NameList_renames_base_names };

static int _wrap_remap_firstenc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct remap *arg1 = (struct remap *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("remap::firstenc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("remap::firstenc",1,"struct remap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("remap::firstenc",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_remap,0))){
    SWIG_fail_ptr("remap_firstenc_set",1,SWIGTYPE_p_remap);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->firstenc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_remap_firstenc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct remap *arg1 = (struct remap *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("remap::firstenc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("remap::firstenc",1,"struct remap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_remap,0))){
    SWIG_fail_ptr("remap_firstenc_get",1,SWIGTYPE_p_remap);
  }
  
  result = (uint32) ((arg1)->firstenc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_remap_lastenc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct remap *arg1 = (struct remap *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("remap::lastenc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("remap::lastenc",1,"struct remap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("remap::lastenc",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_remap,0))){
    SWIG_fail_ptr("remap_lastenc_set",1,SWIGTYPE_p_remap);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->lastenc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_remap_lastenc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct remap *arg1 = (struct remap *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("remap::lastenc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("remap::lastenc",1,"struct remap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_remap,0))){
    SWIG_fail_ptr("remap_lastenc_get",1,SWIGTYPE_p_remap);
  }
  
  result = (uint32) ((arg1)->lastenc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_remap_infont_set(lua_State* L) {
  int SWIG_arg = 0;
  struct remap *arg1 = (struct remap *) 0 ;
  int32 arg2 ;
  
  SWIG_check_num_args("remap::infont",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("remap::infont",1,"struct remap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("remap::infont",2,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_remap,0))){
    SWIG_fail_ptr("remap_infont_set",1,SWIGTYPE_p_remap);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  if (arg1) (arg1)->infont = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_remap_infont_get(lua_State* L) {
  int SWIG_arg = 0;
  struct remap *arg1 = (struct remap *) 0 ;
  int32 result;
  
  SWIG_check_num_args("remap::infont",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("remap::infont",1,"struct remap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_remap,0))){
    SWIG_fail_ptr("remap_infont_get",1,SWIGTYPE_p_remap);
  }
  
  result = (int32) ((arg1)->infont);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_remap(lua_State* L) {
  int SWIG_arg = 0;
  struct remap *result = 0 ;
  
  SWIG_check_num_args("remap::remap",0,0)
  result = (struct remap *)calloc(1, sizeof(struct remap));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_remap,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_remap(void *obj) {
struct remap *arg1 = (struct remap *) obj;
free((char *) arg1);
}
static swig_lua_method swig_remap_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_remap_attributes[] = {
    { "firstenc", _wrap_remap_firstenc_get, _wrap_remap_firstenc_set},
    { "lastenc", _wrap_remap_lastenc_get, _wrap_remap_lastenc_set},
    { "infont", _wrap_remap_infont_get, _wrap_remap_infont_set},
    {0,0,0}
};
static swig_lua_class *swig_remap_bases[] = {0};
static const char *swig_remap_base_names[] = {0};
static swig_lua_class _wrap_class_remap = { "remap", &SWIGTYPE_p_remap,_wrap_new_remap, swig_delete_remap, swig_remap_methods, swig_remap_attributes, swig_remap_bases, swig_remap_base_names };

static int _wrap_EncMap_map_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int32 *arg2 = (int32 *) 0 ;
  
  SWIG_check_num_args("encmap::map",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::map",1,"struct encmap *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("encmap::map",2,"int32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_map_set",1,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("EncMap_map_set",2,SWIGTYPE_p_int);
  }
  
  if (arg1) (arg1)->map = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_map_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int32 *result = 0 ;
  
  SWIG_check_num_args("encmap::map",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::map",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_map_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (int32 *) ((arg1)->map);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_backmap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int32 *arg2 = (int32 *) 0 ;
  
  SWIG_check_num_args("encmap::backmap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::backmap",1,"struct encmap *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("encmap::backmap",2,"int32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_backmap_set",1,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("EncMap_backmap_set",2,SWIGTYPE_p_int);
  }
  
  if (arg1) (arg1)->backmap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_backmap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int32 *result = 0 ;
  
  SWIG_check_num_args("encmap::backmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::backmap",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_backmap_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (int32 *) ((arg1)->backmap);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_enccount_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("encmap::enccount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::enccount",1,"struct encmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("encmap::enccount",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_enccount_set",1,SWIGTYPE_p_encmap);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->enccount = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_enccount_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int result;
  
  SWIG_check_num_args("encmap::enccount",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::enccount",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_enccount_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (int) ((arg1)->enccount);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_encmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("encmap::encmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::encmax",1,"struct encmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("encmap::encmax",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_encmax_set",1,SWIGTYPE_p_encmap);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->encmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_encmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int result;
  
  SWIG_check_num_args("encmap::encmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::encmax",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_encmax_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (int) ((arg1)->encmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_backmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("encmap::backmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::backmax",1,"struct encmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("encmap::backmax",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_backmax_set",1,SWIGTYPE_p_encmap);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->backmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_backmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  int result;
  
  SWIG_check_num_args("encmap::backmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::backmax",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_backmax_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (int) ((arg1)->backmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_remap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  struct remap *arg2 = (struct remap *) 0 ;
  
  SWIG_check_num_args("encmap::remap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::remap",1,"struct encmap *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("encmap::remap",2,"struct remap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_remap_set",1,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_remap,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("EncMap_remap_set",2,SWIGTYPE_p_remap);
  }
  
  if (arg1) (arg1)->remap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_remap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  struct remap *result = 0 ;
  
  SWIG_check_num_args("encmap::remap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::remap",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_remap_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (struct remap *) ((arg1)->remap);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_remap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_enc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  Encoding *arg2 = (Encoding *) 0 ;
  
  SWIG_check_num_args("encmap::enc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::enc",1,"struct encmap *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("encmap::enc",2,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_enc_set",1,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_enc,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("EncMap_enc_set",2,SWIGTYPE_p_enc);
  }
  
  if (arg1) (arg1)->enc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_enc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  Encoding *result = 0 ;
  
  SWIG_check_num_args("encmap::enc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::enc",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_enc_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (Encoding *) ((arg1)->enc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("encmap::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::ticked",1,"struct encmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("encmap::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_ticked_set",1,SWIGTYPE_p_encmap);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *arg1 = (struct encmap *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("encmap::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("encmap::ticked",1,"struct encmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMap_ticked_get",1,SWIGTYPE_p_encmap);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_EncMap(lua_State* L) {
  int SWIG_arg = 0;
  struct encmap *result = 0 ;
  
  SWIG_check_num_args("encmap::encmap",0,0)
  result = (struct encmap *)calloc(1, sizeof(struct encmap));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_EncMap(void *obj) {
struct encmap *arg1 = (struct encmap *) obj;
free((char *) arg1);
}
static swig_lua_method swig_encmap_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_encmap_attributes[] = {
    { "map", _wrap_EncMap_map_get, _wrap_EncMap_map_set},
    { "backmap", _wrap_EncMap_backmap_get, _wrap_EncMap_backmap_set},
    { "enccount", _wrap_EncMap_enccount_get, _wrap_EncMap_enccount_set},
    { "encmax", _wrap_EncMap_encmax_get, _wrap_EncMap_encmax_set},
    { "backmax", _wrap_EncMap_backmax_get, _wrap_EncMap_backmax_set},
    { "remap", _wrap_EncMap_remap_get, _wrap_EncMap_remap_set},
    { "enc", _wrap_EncMap_enc_get, _wrap_EncMap_enc_set},
    { "ticked", _wrap_EncMap_ticked_get, _wrap_EncMap_ticked_set},
    {0,0,0}
};
static swig_lua_class *swig_encmap_bases[] = {0};
static const char *swig_encmap_base_names[] = {0};
static swig_lua_class _wrap_class_encmap = { "EncMap", &SWIGTYPE_p_encmap,_wrap_new_EncMap, swig_delete_EncMap, swig_encmap_methods, swig_encmap_attributes, swig_encmap_bases, swig_encmap_base_names };

static int _wrap_BDFProperties_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfprops *arg1 = (struct bdfprops *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("bdfprops::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfprops::name",1,"struct bdfprops *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("bdfprops::name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfprops,0))){
    SWIG_fail_ptr("BDFProperties_name_set",1,SWIGTYPE_p_bdfprops);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->name);
    if (arg2) {
      arg1->name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfprops *arg1 = (struct bdfprops *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("bdfprops::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfprops::name",1,"struct bdfprops *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfprops,0))){
    SWIG_fail_ptr("BDFProperties_name_get",1,SWIGTYPE_p_bdfprops);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfprops *arg1 = (struct bdfprops *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bdfprops::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfprops::type",1,"struct bdfprops *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdfprops::type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfprops,0))){
    SWIG_fail_ptr("BDFProperties_type_set",1,SWIGTYPE_p_bdfprops);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfprops *arg1 = (struct bdfprops *) 0 ;
  int result;
  
  SWIG_check_num_args("bdfprops::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfprops::type",1,"struct bdfprops *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfprops,0))){
    SWIG_fail_ptr("BDFProperties_type_get",1,SWIGTYPE_p_bdfprops);
  }
  
  result = (int) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_u_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfprops *arg1 = (struct bdfprops *) 0 ;
  BDFProperties_u *result = 0 ;
  
  SWIG_check_num_args("bdfprops::u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdfprops::u",1,"struct bdfprops *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfprops,0))){
    SWIG_fail_ptr("BDFProperties_u_get",1,SWIGTYPE_p_bdfprops);
  }
  
  result = (BDFProperties_u *)& ((arg1)->u);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_BDFProperties_u,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BDFProperties(lua_State* L) {
  int SWIG_arg = 0;
  struct bdfprops *result = 0 ;
  
  SWIG_check_num_args("bdfprops::bdfprops",0,0)
  result = (struct bdfprops *)calloc(1, sizeof(struct bdfprops));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfprops,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BDFProperties(void *obj) {
struct bdfprops *arg1 = (struct bdfprops *) obj;
free((char *) arg1);
}
static swig_lua_method swig_bdfprops_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_bdfprops_attributes[] = {
    { "name", _wrap_BDFProperties_name_get, _wrap_BDFProperties_name_set},
    { "type", _wrap_BDFProperties_type_get, _wrap_BDFProperties_type_set},
    { "u", _wrap_BDFProperties_u_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_bdfprops_bases[] = {0};
static const char *swig_bdfprops_base_names[] = {0};
static swig_lua_class _wrap_class_bdfprops = { "BDFProperties", &SWIGTYPE_p_bdfprops,_wrap_new_BDFProperties, swig_delete_BDFProperties, swig_bdfprops_methods, swig_bdfprops_attributes, swig_bdfprops_bases, swig_bdfprops_base_names };

static int _wrap_BDFProperties_u_str_set(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties_u *arg1 = (BDFProperties_u *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("BDFProperties_u::str",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFProperties_u::str",1,"BDFProperties_u *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("BDFProperties_u::str",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFProperties_u,0))){
    SWIG_fail_ptr("BDFProperties_u_str_set",1,SWIGTYPE_p_BDFProperties_u);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->str);
    if (arg2) {
      arg1->str = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->str, (const char *)arg2);
    } else {
      arg1->str = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_u_str_get(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties_u *arg1 = (BDFProperties_u *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("BDFProperties_u::str",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFProperties_u::str",1,"BDFProperties_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFProperties_u,0))){
    SWIG_fail_ptr("BDFProperties_u_str_get",1,SWIGTYPE_p_BDFProperties_u);
  }
  
  result = (char *) ((arg1)->str);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_u_atom_set(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties_u *arg1 = (BDFProperties_u *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("BDFProperties_u::atom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFProperties_u::atom",1,"BDFProperties_u *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("BDFProperties_u::atom",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFProperties_u,0))){
    SWIG_fail_ptr("BDFProperties_u_atom_set",1,SWIGTYPE_p_BDFProperties_u);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->atom);
    if (arg2) {
      arg1->atom = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->atom, (const char *)arg2);
    } else {
      arg1->atom = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_u_atom_get(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties_u *arg1 = (BDFProperties_u *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("BDFProperties_u::atom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFProperties_u::atom",1,"BDFProperties_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFProperties_u,0))){
    SWIG_fail_ptr("BDFProperties_u_atom_get",1,SWIGTYPE_p_BDFProperties_u);
  }
  
  result = (char *) ((arg1)->atom);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_u_val_set(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties_u *arg1 = (BDFProperties_u *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("BDFProperties_u::val",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFProperties_u::val",1,"BDFProperties_u *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BDFProperties_u::val",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFProperties_u,0))){
    SWIG_fail_ptr("BDFProperties_u_val_set",1,SWIGTYPE_p_BDFProperties_u);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->val = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFProperties_u_val_get(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties_u *arg1 = (BDFProperties_u *) 0 ;
  int result;
  
  SWIG_check_num_args("BDFProperties_u::val",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFProperties_u::val",1,"BDFProperties_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_BDFProperties_u,0))){
    SWIG_fail_ptr("BDFProperties_u_val_get",1,SWIGTYPE_p_BDFProperties_u);
  }
  
  result = (int) ((arg1)->val);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BDFProperties_u(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties_u *result = 0 ;
  
  SWIG_check_num_args("BDFProperties_u::BDFProperties_u",0,0)
  result = (BDFProperties_u *)calloc(1, sizeof(BDFProperties_u));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_BDFProperties_u,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BDFProperties_u(void *obj) {
BDFProperties_u *arg1 = (BDFProperties_u *) obj;
free((char *) arg1);
}
static swig_lua_method swig_BDFProperties_u_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_BDFProperties_u_attributes[] = {
    { "str", _wrap_BDFProperties_u_str_get, _wrap_BDFProperties_u_str_set},
    { "atom", _wrap_BDFProperties_u_atom_get, _wrap_BDFProperties_u_atom_set},
    { "val", _wrap_BDFProperties_u_val_get, _wrap_BDFProperties_u_val_set},
    {0,0,0}
};
static swig_lua_class *swig_BDFProperties_u_bases[] = {0};
static const char *swig_BDFProperties_u_base_names[] = {0};
static swig_lua_class _wrap_class_BDFProperties_u = { "BDFProperties_u", &SWIGTYPE_p_BDFProperties_u,_wrap_new_BDFProperties_u, swig_delete_BDFProperties_u, swig_BDFProperties_u_methods, swig_BDFProperties_u_attributes, swig_BDFProperties_u_bases, swig_BDFProperties_u_base_names };

static int _wrap_BDFFont_sf_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  struct splinefont *arg2 = (struct splinefont *) 0 ;
  
  SWIG_check_num_args("bdffont::sf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::sf",1,"struct bdffont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdffont::sf",2,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_sf_set",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFFont_sf_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->sf = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_sf_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  struct splinefont *result = 0 ;
  
  SWIG_check_num_args("bdffont::sf",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::sf",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_sf_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (struct splinefont *) ((arg1)->sf);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_glyphcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bdffont::glyphcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::glyphcnt",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::glyphcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_glyphcnt_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->glyphcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_glyphcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int result;
  
  SWIG_check_num_args("bdffont::glyphcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::glyphcnt",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_glyphcnt_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int) ((arg1)->glyphcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_glyphmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bdffont::glyphmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::glyphmax",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::glyphmax",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_glyphmax_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->glyphmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_glyphmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int result;
  
  SWIG_check_num_args("bdffont::glyphmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::glyphmax",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_glyphmax_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int) ((arg1)->glyphmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_glyphs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  BDFChar **arg2 = (BDFChar **) 0 ;
  
  SWIG_check_num_args("bdffont::glyphs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::glyphs",1,"struct bdffont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdffont::glyphs",2,"BDFChar **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_glyphs_set",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_bdfchar,0))){
    SWIG_fail_ptr("BDFFont_glyphs_set",2,SWIGTYPE_p_p_bdfchar);
  }
  
  if (arg1) (arg1)->glyphs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_glyphs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  BDFChar **result = 0 ;
  
  SWIG_check_num_args("bdffont::glyphs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::glyphs",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_glyphs_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (BDFChar **) ((arg1)->glyphs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_pixelsize_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffont::pixelsize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::pixelsize",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::pixelsize",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_pixelsize_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->pixelsize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_pixelsize_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffont::pixelsize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::pixelsize",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_pixelsize_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int16) ((arg1)->pixelsize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_ascent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffont::ascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::ascent",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::ascent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_ascent_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_ascent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffont::ascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::ascent",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_ascent_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int16) ((arg1)->ascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_descent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffont::descent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::descent",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::descent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_descent_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->descent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_descent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffont::descent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::descent",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_descent_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int16) ((arg1)->descent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_layer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffont::layer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::layer",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::layer",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_layer_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->layer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_layer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffont::layer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::layer",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_layer_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int16) ((arg1)->layer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_piecemeal_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdffont::piecemeal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::piecemeal",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::piecemeal",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_piecemeal_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->piecemeal = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_piecemeal_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdffont::piecemeal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::piecemeal",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_piecemeal_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (unsigned int) ((arg1)->piecemeal);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_bbsized_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdffont::bbsized",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::bbsized",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::bbsized",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_bbsized_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bbsized = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_bbsized_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdffont::bbsized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::bbsized",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_bbsized_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (unsigned int) ((arg1)->bbsized);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdffont::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::ticked",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_ticked_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdffont::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::ticked",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_ticked_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_unhinted_freetype_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdffont::unhinted_freetype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::unhinted_freetype",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::unhinted_freetype",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_unhinted_freetype_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unhinted_freetype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_unhinted_freetype_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdffont::unhinted_freetype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::unhinted_freetype",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_unhinted_freetype_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (unsigned int) ((arg1)->unhinted_freetype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_recontext_freetype_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("bdffont::recontext_freetype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::recontext_freetype",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::recontext_freetype",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_recontext_freetype_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->recontext_freetype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_recontext_freetype_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("bdffont::recontext_freetype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::recontext_freetype",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_recontext_freetype_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (unsigned int) ((arg1)->recontext_freetype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  struct bdffont *arg2 = (struct bdffont *) 0 ;
  
  SWIG_check_num_args("bdffont::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::next",1,"struct bdffont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdffont::next",2,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_next_set",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFFont_next_set",2,SWIGTYPE_p_bdffont);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  struct bdffont *result = 0 ;
  
  SWIG_check_num_args("bdffont::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::next",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_next_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (struct bdffont *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_clut_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  struct clut *arg2 = (struct clut *) 0 ;
  
  SWIG_check_num_args("bdffont::clut",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::clut",1,"struct bdffont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdffont::clut",2,"struct clut *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_clut_set",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_clut,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFFont_clut_set",2,SWIGTYPE_p_clut);
  }
  
  if (arg1) (arg1)->clut = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_clut_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  struct clut *result = 0 ;
  
  SWIG_check_num_args("bdffont::clut",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::clut",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_clut_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (struct clut *) ((arg1)->clut);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_clut,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_foundry_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("bdffont::foundry",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::foundry",1,"struct bdffont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("bdffont::foundry",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_foundry_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->foundry);
    if (arg2) {
      arg1->foundry = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->foundry, (const char *)arg2);
    } else {
      arg1->foundry = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_foundry_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("bdffont::foundry",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::foundry",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_foundry_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (char *) ((arg1)->foundry);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_res_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bdffont::res",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::res",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::res",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_res_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->res = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_res_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int result;
  
  SWIG_check_num_args("bdffont::res",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::res",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_res_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int) ((arg1)->res);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_freetype_context_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("bdffont::freetype_context",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::freetype_context",1,"struct bdffont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdffont::freetype_context",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_freetype_context_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"BDFFont_freetype_context_set");
  if (arg1) (arg1)->freetype_context = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_freetype_context_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("bdffont::freetype_context",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::freetype_context",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_freetype_context_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (void *) ((arg1)->freetype_context);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_truesize_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("bdffont::truesize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::truesize",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::truesize",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_truesize_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->truesize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_truesize_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("bdffont::truesize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::truesize",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_truesize_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (uint16) ((arg1)->truesize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_prop_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffont::prop_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::prop_cnt",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::prop_cnt",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_prop_cnt_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->prop_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_prop_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffont::prop_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::prop_cnt",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_prop_cnt_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int16) ((arg1)->prop_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_prop_max_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("bdffont::prop_max",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::prop_max",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::prop_max",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_prop_max_set",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->prop_max = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_prop_max_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  int16 result;
  
  SWIG_check_num_args("bdffont::prop_max",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::prop_max",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_prop_max_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int16) ((arg1)->prop_max);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_props_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  BDFProperties *arg2 = (BDFProperties *) 0 ;
  
  SWIG_check_num_args("bdffont::props",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::props",1,"struct bdffont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("bdffont::props",2,"BDFProperties *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_props_set",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfprops,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("BDFFont_props_set",2,SWIGTYPE_p_bdfprops);
  }
  
  if (arg1) (arg1)->props = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_props_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  BDFProperties *result = 0 ;
  
  SWIG_check_num_args("bdffont::props",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::props",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_props_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (BDFProperties *) ((arg1)->props);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfprops,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_ptsize_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("bdffont::ptsize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::ptsize",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::ptsize",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_ptsize_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ptsize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_ptsize_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("bdffont::ptsize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::ptsize",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_ptsize_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (uint16) ((arg1)->ptsize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_dpi_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("bdffont::dpi",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::dpi",1,"struct bdffont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bdffont::dpi",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_dpi_set",1,SWIGTYPE_p_bdffont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->dpi = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFont_dpi_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *arg1 = (struct bdffont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("bdffont::dpi",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bdffont::dpi",1,"struct bdffont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFont_dpi_get",1,SWIGTYPE_p_bdffont);
  }
  
  result = (uint16) ((arg1)->dpi);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BDFFont(lua_State* L) {
  int SWIG_arg = 0;
  struct bdffont *result = 0 ;
  
  SWIG_check_num_args("bdffont::bdffont",0,0)
  result = (struct bdffont *)calloc(1, sizeof(struct bdffont));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BDFFont(void *obj) {
struct bdffont *arg1 = (struct bdffont *) obj;
free((char *) arg1);
}
static swig_lua_method swig_bdffont_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_bdffont_attributes[] = {
    { "sf", _wrap_BDFFont_sf_get, _wrap_BDFFont_sf_set},
    { "glyphcnt", _wrap_BDFFont_glyphcnt_get, _wrap_BDFFont_glyphcnt_set},
    { "glyphmax", _wrap_BDFFont_glyphmax_get, _wrap_BDFFont_glyphmax_set},
    { "glyphs", _wrap_BDFFont_glyphs_get, _wrap_BDFFont_glyphs_set},
    { "pixelsize", _wrap_BDFFont_pixelsize_get, _wrap_BDFFont_pixelsize_set},
    { "ascent", _wrap_BDFFont_ascent_get, _wrap_BDFFont_ascent_set},
    { "descent", _wrap_BDFFont_descent_get, _wrap_BDFFont_descent_set},
    { "layer", _wrap_BDFFont_layer_get, _wrap_BDFFont_layer_set},
    { "piecemeal", _wrap_BDFFont_piecemeal_get, _wrap_BDFFont_piecemeal_set},
    { "bbsized", _wrap_BDFFont_bbsized_get, _wrap_BDFFont_bbsized_set},
    { "ticked", _wrap_BDFFont_ticked_get, _wrap_BDFFont_ticked_set},
    { "unhinted_freetype", _wrap_BDFFont_unhinted_freetype_get, _wrap_BDFFont_unhinted_freetype_set},
    { "recontext_freetype", _wrap_BDFFont_recontext_freetype_get, _wrap_BDFFont_recontext_freetype_set},
    { "next", _wrap_BDFFont_next_get, _wrap_BDFFont_next_set},
    { "clut", _wrap_BDFFont_clut_get, _wrap_BDFFont_clut_set},
    { "foundry", _wrap_BDFFont_foundry_get, _wrap_BDFFont_foundry_set},
    { "res", _wrap_BDFFont_res_get, _wrap_BDFFont_res_set},
    { "freetype_context", _wrap_BDFFont_freetype_context_get, _wrap_BDFFont_freetype_context_set},
    { "truesize", _wrap_BDFFont_truesize_get, _wrap_BDFFont_truesize_set},
    { "prop_cnt", _wrap_BDFFont_prop_cnt_get, _wrap_BDFFont_prop_cnt_set},
    { "prop_max", _wrap_BDFFont_prop_max_get, _wrap_BDFFont_prop_max_set},
    { "props", _wrap_BDFFont_props_get, _wrap_BDFFont_props_set},
    { "ptsize", _wrap_BDFFont_ptsize_get, _wrap_BDFFont_ptsize_set},
    { "dpi", _wrap_BDFFont_dpi_get, _wrap_BDFFont_dpi_set},
    {0,0,0}
};
static swig_lua_class *swig_bdffont_bases[] = {0};
static const char *swig_bdffont_base_names[] = {0};
static swig_lua_class _wrap_class_bdffont = { "BDFFont", &SWIGTYPE_p_bdffont,_wrap_new_BDFFont, swig_delete_BDFFont, swig_bdffont_methods, swig_bdffont_attributes, swig_bdffont_bases, swig_bdffont_base_names };

static int _wrap_SplinePoint_me_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("splinepoint::me",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::me",1,"struct splinepoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepoint::me",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_me_set",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SplinePoint_me_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->me = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_me_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("splinepoint::me",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::me",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_me_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (BasePoint *)& ((arg1)->me);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nextcp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("splinepoint::nextcp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nextcp",1,"struct splinepoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepoint::nextcp",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nextcp_set",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SplinePoint_nextcp_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->nextcp = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nextcp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("splinepoint::nextcp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nextcp",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nextcp_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (BasePoint *)& ((arg1)->nextcp);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_prevcp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("splinepoint::prevcp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::prevcp",1,"struct splinepoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepoint::prevcp",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_prevcp_set",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SplinePoint_prevcp_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->prevcp = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_prevcp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("splinepoint::prevcp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::prevcp",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_prevcp_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (BasePoint *)& ((arg1)->prevcp);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nonextcp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::nonextcp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nonextcp",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::nonextcp",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nonextcp_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->nonextcp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nonextcp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::nonextcp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nonextcp",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nonextcp_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->nonextcp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_noprevcp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::noprevcp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::noprevcp",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::noprevcp",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_noprevcp_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->noprevcp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_noprevcp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::noprevcp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::noprevcp",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_noprevcp_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->noprevcp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nextcpdef_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::nextcpdef",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nextcpdef",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::nextcpdef",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nextcpdef_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->nextcpdef = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nextcpdef_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::nextcpdef",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nextcpdef",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nextcpdef_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->nextcpdef);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_prevcpdef_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::prevcpdef",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::prevcpdef",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::prevcpdef",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_prevcpdef_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->prevcpdef = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_prevcpdef_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::prevcpdef",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::prevcpdef",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_prevcpdef_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->prevcpdef);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_selected_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::selected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::selected",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::selected",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_selected_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->selected = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_selected_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::selected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::selected",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_selected_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->selected);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_pointtype_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::pointtype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::pointtype",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::pointtype",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_pointtype_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pointtype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_pointtype_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::pointtype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::pointtype",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_pointtype_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->pointtype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_isintersection_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::isintersection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::isintersection",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::isintersection",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_isintersection_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->isintersection = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_isintersection_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::isintersection",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::isintersection",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_isintersection_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->isintersection);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_flexy_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::flexy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::flexy",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::flexy",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_flexy_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->flexy = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_flexy_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::flexy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::flexy",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_flexy_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->flexy);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_flexx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::flexx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::flexx",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::flexx",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_flexx_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->flexx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_flexx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::flexx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::flexx",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_flexx_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->flexx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_roundx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::roundx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::roundx",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::roundx",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_roundx_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->roundx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_roundx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::roundx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::roundx",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_roundx_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->roundx);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_roundy_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::roundy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::roundy",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::roundy",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_roundy_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->roundy = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_roundy_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::roundy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::roundy",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_roundy_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->roundy);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_dontinterpolate_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::dontinterpolate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::dontinterpolate",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::dontinterpolate",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_dontinterpolate_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->dontinterpolate = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_dontinterpolate_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::dontinterpolate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::dontinterpolate",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_dontinterpolate_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->dontinterpolate);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::ticked",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_ticked_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::ticked",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_ticked_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_watched_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinepoint::watched",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::watched",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::watched",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_watched_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->watched = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_watched_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinepoint::watched",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::watched",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_watched_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (unsigned int) ((arg1)->watched);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_ptindex_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinepoint::ptindex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::ptindex",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::ptindex",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_ptindex_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ptindex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_ptindex_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinepoint::ptindex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::ptindex",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_ptindex_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (uint16) ((arg1)->ptindex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_ttfindex_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinepoint::ttfindex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::ttfindex",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::ttfindex",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_ttfindex_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ttfindex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_ttfindex_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinepoint::ttfindex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::ttfindex",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_ttfindex_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (uint16) ((arg1)->ttfindex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nextcpindex_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinepoint::nextcpindex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nextcpindex",1,"struct splinepoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepoint::nextcpindex",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nextcpindex_set",1,SWIGTYPE_p_splinepoint);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->nextcpindex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_nextcpindex_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinepoint::nextcpindex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::nextcpindex",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_nextcpindex_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (uint16) ((arg1)->nextcpindex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  struct spline *arg2 = (struct spline *) 0 ;
  
  SWIG_check_num_args("splinepoint::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::next",1,"struct splinepoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepoint::next",2,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_next_set",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_spline,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplinePoint_next_set",2,SWIGTYPE_p_spline);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  struct spline *result = 0 ;
  
  SWIG_check_num_args("splinepoint::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::next",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_next_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (struct spline *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_prev_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  struct spline *arg2 = (struct spline *) 0 ;
  
  SWIG_check_num_args("splinepoint::prev",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::prev",1,"struct splinepoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepoint::prev",2,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_prev_set",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_spline,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplinePoint_prev_set",2,SWIGTYPE_p_spline);
  }
  
  if (arg1) (arg1)->prev = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_prev_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  struct spline *result = 0 ;
  
  SWIG_check_num_args("splinepoint::prev",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::prev",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_prev_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (struct spline *) ((arg1)->prev);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_hintmask_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  HintMask *arg2 = (HintMask *) 0 ;
  
  SWIG_check_num_args("splinepoint::hintmask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::hintmask",1,"struct splinepoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepoint::hintmask",2,"HintMask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_hintmask_set",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_a_96_8__unsigned_char,0))){
    SWIG_fail_ptr("SplinePoint_hintmask_set",2,SWIGTYPE_p_a_96_8__unsigned_char);
  }
  
  if (arg1) (arg1)->hintmask = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePoint_hintmask_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *arg1 = (struct splinepoint *) 0 ;
  HintMask *result = 0 ;
  
  SWIG_check_num_args("splinepoint::hintmask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepoint::hintmask",1,"struct splinepoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePoint_hintmask_get",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (HintMask *) ((arg1)->hintmask);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_a_96_8__unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplinePoint(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepoint *result = 0 ;
  
  SWIG_check_num_args("splinepoint::splinepoint",0,0)
  result = (struct splinepoint *)calloc(1, sizeof(struct splinepoint));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplinePoint(void *obj) {
struct splinepoint *arg1 = (struct splinepoint *) obj;
free((char *) arg1);
}
static swig_lua_method swig_splinepoint_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_splinepoint_attributes[] = {
    { "me", _wrap_SplinePoint_me_get, _wrap_SplinePoint_me_set},
    { "nextcp", _wrap_SplinePoint_nextcp_get, _wrap_SplinePoint_nextcp_set},
    { "prevcp", _wrap_SplinePoint_prevcp_get, _wrap_SplinePoint_prevcp_set},
    { "nonextcp", _wrap_SplinePoint_nonextcp_get, _wrap_SplinePoint_nonextcp_set},
    { "noprevcp", _wrap_SplinePoint_noprevcp_get, _wrap_SplinePoint_noprevcp_set},
    { "nextcpdef", _wrap_SplinePoint_nextcpdef_get, _wrap_SplinePoint_nextcpdef_set},
    { "prevcpdef", _wrap_SplinePoint_prevcpdef_get, _wrap_SplinePoint_prevcpdef_set},
    { "selected", _wrap_SplinePoint_selected_get, _wrap_SplinePoint_selected_set},
    { "pointtype", _wrap_SplinePoint_pointtype_get, _wrap_SplinePoint_pointtype_set},
    { "isintersection", _wrap_SplinePoint_isintersection_get, _wrap_SplinePoint_isintersection_set},
    { "flexy", _wrap_SplinePoint_flexy_get, _wrap_SplinePoint_flexy_set},
    { "flexx", _wrap_SplinePoint_flexx_get, _wrap_SplinePoint_flexx_set},
    { "roundx", _wrap_SplinePoint_roundx_get, _wrap_SplinePoint_roundx_set},
    { "roundy", _wrap_SplinePoint_roundy_get, _wrap_SplinePoint_roundy_set},
    { "dontinterpolate", _wrap_SplinePoint_dontinterpolate_get, _wrap_SplinePoint_dontinterpolate_set},
    { "ticked", _wrap_SplinePoint_ticked_get, _wrap_SplinePoint_ticked_set},
    { "watched", _wrap_SplinePoint_watched_get, _wrap_SplinePoint_watched_set},
    { "ptindex", _wrap_SplinePoint_ptindex_get, _wrap_SplinePoint_ptindex_set},
    { "ttfindex", _wrap_SplinePoint_ttfindex_get, _wrap_SplinePoint_ttfindex_set},
    { "nextcpindex", _wrap_SplinePoint_nextcpindex_get, _wrap_SplinePoint_nextcpindex_set},
    { "next", _wrap_SplinePoint_next_get, _wrap_SplinePoint_next_set},
    { "prev", _wrap_SplinePoint_prev_get, _wrap_SplinePoint_prev_set},
    { "hintmask", _wrap_SplinePoint_hintmask_get, _wrap_SplinePoint_hintmask_set},
    {0,0,0}
};
static swig_lua_class *swig_splinepoint_bases[] = {0};
static const char *swig_splinepoint_base_names[] = {0};
static swig_lua_class _wrap_class_splinepoint = { "SplinePoint", &SWIGTYPE_p_splinepoint,_wrap_new_SplinePoint, swig_delete_SplinePoint, swig_splinepoint_methods, swig_splinepoint_attributes, swig_splinepoint_bases, swig_splinepoint_base_names };

static int _wrap_LineList_here_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  IPoint *arg2 = (IPoint *) 0 ;
  
  SWIG_check_num_args("linelist::here",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::here",1,"struct linelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("linelist::here",2,"IPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_here_set",1,SWIGTYPE_p_linelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ipoint,0))){
    SWIG_fail_ptr("LineList_here_set",2,SWIGTYPE_p_ipoint);
  }
  
  if (arg1) (arg1)->here = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_here_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  IPoint *result = 0 ;
  
  SWIG_check_num_args("linelist::here",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::here",1,"struct linelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_here_get",1,SWIGTYPE_p_linelist);
  }
  
  result = (IPoint *)& ((arg1)->here);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ipoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  struct linelist *arg2 = (struct linelist *) 0 ;
  
  SWIG_check_num_args("linelist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::next",1,"struct linelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("linelist::next",2,"struct linelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_next_set",1,SWIGTYPE_p_linelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_linelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("LineList_next_set",2,SWIGTYPE_p_linelist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  struct linelist *result = 0 ;
  
  SWIG_check_num_args("linelist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::next",1,"struct linelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_next_get",1,SWIGTYPE_p_linelist);
  }
  
  result = (struct linelist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_linelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_flags_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("linelist::flags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::flags",1,"struct linelist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("linelist::flags",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_flags_set",1,SWIGTYPE_p_linelist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1 && sizeof(int) == sizeof((arg1)->flags)) *(int*)(void*)&((arg1)->flags) = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_flags_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  int result;
  
  SWIG_check_num_args("linelist::flags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::flags",1,"struct linelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_flags_get",1,SWIGTYPE_p_linelist);
  }
  
  result = (int) ((arg1)->flags);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_asend_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  IPoint *arg2 = (IPoint *) 0 ;
  
  SWIG_check_num_args("linelist::asend",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::asend",1,"struct linelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("linelist::asend",2,"IPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_asend_set",1,SWIGTYPE_p_linelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ipoint,0))){
    SWIG_fail_ptr("LineList_asend_set",2,SWIGTYPE_p_ipoint);
  }
  
  if (arg1) (arg1)->asend = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_asend_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  IPoint *result = 0 ;
  
  SWIG_check_num_args("linelist::asend",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::asend",1,"struct linelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_asend_get",1,SWIGTYPE_p_linelist);
  }
  
  result = (IPoint *)& ((arg1)->asend);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ipoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_asstart_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  IPoint *arg2 = (IPoint *) 0 ;
  
  SWIG_check_num_args("linelist::asstart",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::asstart",1,"struct linelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("linelist::asstart",2,"IPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_asstart_set",1,SWIGTYPE_p_linelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ipoint,0))){
    SWIG_fail_ptr("LineList_asstart_set",2,SWIGTYPE_p_ipoint);
  }
  
  if (arg1) (arg1)->asstart = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineList_asstart_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *arg1 = (struct linelist *) 0 ;
  IPoint *result = 0 ;
  
  SWIG_check_num_args("linelist::asstart",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linelist::asstart",1,"struct linelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineList_asstart_get",1,SWIGTYPE_p_linelist);
  }
  
  result = (IPoint *)& ((arg1)->asstart);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ipoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LineList(lua_State* L) {
  int SWIG_arg = 0;
  struct linelist *result = 0 ;
  
  SWIG_check_num_args("linelist::linelist",0,0)
  result = (struct linelist *)calloc(1, sizeof(struct linelist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_linelist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LineList(void *obj) {
struct linelist *arg1 = (struct linelist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_linelist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_linelist_attributes[] = {
    { "here", _wrap_LineList_here_get, _wrap_LineList_here_set},
    { "next", _wrap_LineList_next_get, _wrap_LineList_next_set},
    { "flags", _wrap_LineList_flags_get, _wrap_LineList_flags_set},
    { "asend", _wrap_LineList_asend_get, _wrap_LineList_asend_set},
    { "asstart", _wrap_LineList_asstart_get, _wrap_LineList_asstart_set},
    {0,0,0}
};
static swig_lua_class *swig_linelist_bases[] = {0};
static const char *swig_linelist_base_names[] = {0};
static swig_lua_class _wrap_class_linelist = { "LineList", &SWIGTYPE_p_linelist,_wrap_new_LineList, swig_delete_LineList, swig_linelist_methods, swig_linelist_attributes, swig_linelist_bases, swig_linelist_base_names };

static int _wrap_LinearApprox_scale_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("linearapprox::scale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::scale",1,"struct linearapprox *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("linearapprox::scale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_scale_set",1,SWIGTYPE_p_linearapprox);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->scale = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_scale_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  float result;
  
  SWIG_check_num_args("linearapprox::scale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::scale",1,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_scale_get",1,SWIGTYPE_p_linearapprox);
  }
  
  result = (float) ((arg1)->scale);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_oneline_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("linearapprox::oneline",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::oneline",1,"struct linearapprox *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("linearapprox::oneline",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_oneline_set",1,SWIGTYPE_p_linearapprox);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->oneline = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_oneline_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("linearapprox::oneline",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::oneline",1,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_oneline_get",1,SWIGTYPE_p_linearapprox);
  }
  
  result = (unsigned int) ((arg1)->oneline);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_onepoint_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("linearapprox::onepoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::onepoint",1,"struct linearapprox *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("linearapprox::onepoint",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_onepoint_set",1,SWIGTYPE_p_linearapprox);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->onepoint = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_onepoint_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("linearapprox::onepoint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::onepoint",1,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_onepoint_get",1,SWIGTYPE_p_linearapprox);
  }
  
  result = (unsigned int) ((arg1)->onepoint);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_any_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("linearapprox::any",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::any",1,"struct linearapprox *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("linearapprox::any",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_any_set",1,SWIGTYPE_p_linearapprox);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->any = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_any_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("linearapprox::any",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::any",1,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_any_get",1,SWIGTYPE_p_linearapprox);
  }
  
  result = (unsigned int) ((arg1)->any);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_lines_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  struct linelist *arg2 = (struct linelist *) 0 ;
  
  SWIG_check_num_args("linearapprox::lines",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::lines",1,"struct linearapprox *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("linearapprox::lines",2,"struct linelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_lines_set",1,SWIGTYPE_p_linearapprox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_linelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("LinearApprox_lines_set",2,SWIGTYPE_p_linelist);
  }
  
  if (arg1) (arg1)->lines = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_lines_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  struct linelist *result = 0 ;
  
  SWIG_check_num_args("linearapprox::lines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::lines",1,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_lines_get",1,SWIGTYPE_p_linearapprox);
  }
  
  result = (struct linelist *) ((arg1)->lines);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_linelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  struct linearapprox *arg2 = (struct linearapprox *) 0 ;
  
  SWIG_check_num_args("linearapprox::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::next",1,"struct linearapprox *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("linearapprox::next",2,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_next_set",1,SWIGTYPE_p_linearapprox);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_linearapprox,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("LinearApprox_next_set",2,SWIGTYPE_p_linearapprox);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApprox_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *arg1 = (struct linearapprox *) 0 ;
  struct linearapprox *result = 0 ;
  
  SWIG_check_num_args("linearapprox::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("linearapprox::next",1,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApprox_next_get",1,SWIGTYPE_p_linearapprox);
  }
  
  result = (struct linearapprox *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_linearapprox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LinearApprox(lua_State* L) {
  int SWIG_arg = 0;
  struct linearapprox *result = 0 ;
  
  SWIG_check_num_args("linearapprox::linearapprox",0,0)
  result = (struct linearapprox *)calloc(1, sizeof(struct linearapprox));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_linearapprox,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LinearApprox(void *obj) {
struct linearapprox *arg1 = (struct linearapprox *) obj;
free((char *) arg1);
}
static swig_lua_method swig_linearapprox_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_linearapprox_attributes[] = {
    { "scale", _wrap_LinearApprox_scale_get, _wrap_LinearApprox_scale_set},
    { "oneline", _wrap_LinearApprox_oneline_get, _wrap_LinearApprox_oneline_set},
    { "onepoint", _wrap_LinearApprox_onepoint_get, _wrap_LinearApprox_onepoint_set},
    { "any", _wrap_LinearApprox_any_get, _wrap_LinearApprox_any_set},
    { "lines", _wrap_LinearApprox_lines_get, _wrap_LinearApprox_lines_set},
    { "next", _wrap_LinearApprox_next_get, _wrap_LinearApprox_next_set},
    {0,0,0}
};
static swig_lua_class *swig_linearapprox_bases[] = {0};
static const char *swig_linearapprox_base_names[] = {0};
static swig_lua_class _wrap_class_linearapprox = { "LinearApprox", &SWIGTYPE_p_linearapprox,_wrap_new_LinearApprox, swig_delete_LinearApprox, swig_linearapprox_methods, swig_linearapprox_attributes, swig_linearapprox_bases, swig_linearapprox_base_names };

static int _wrap_Spline1D_a_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("spline1d::a",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::a",1,"struct spline1d *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline1d::a",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_a_set",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->a = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1D_a_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float result;
  
  SWIG_check_num_args("spline1d::a",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::a",1,"struct spline1d *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_a_get",1,SWIGTYPE_p_spline1d);
  }
  
  result = (float) ((arg1)->a);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1D_b_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("spline1d::b",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::b",1,"struct spline1d *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline1d::b",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_b_set",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->b = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1D_b_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float result;
  
  SWIG_check_num_args("spline1d::b",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::b",1,"struct spline1d *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_b_get",1,SWIGTYPE_p_spline1d);
  }
  
  result = (float) ((arg1)->b);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1D_c_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("spline1d::c",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::c",1,"struct spline1d *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline1d::c",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_c_set",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->c = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1D_c_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float result;
  
  SWIG_check_num_args("spline1d::c",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::c",1,"struct spline1d *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_c_get",1,SWIGTYPE_p_spline1d);
  }
  
  result = (float) ((arg1)->c);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1D_d_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("spline1d::d",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::d",1,"struct spline1d *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline1d::d",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_d_set",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->d = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1D_d_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *arg1 = (struct spline1d *) 0 ;
  float result;
  
  SWIG_check_num_args("spline1d::d",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline1d::d",1,"struct spline1d *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline1D_d_get",1,SWIGTYPE_p_spline1d);
  }
  
  result = (float) ((arg1)->d);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Spline1D(lua_State* L) {
  int SWIG_arg = 0;
  struct spline1d *result = 0 ;
  
  SWIG_check_num_args("spline1d::spline1d",0,0)
  result = (struct spline1d *)calloc(1, sizeof(struct spline1d));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline1d,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Spline1D(void *obj) {
struct spline1d *arg1 = (struct spline1d *) obj;
free((char *) arg1);
}
static swig_lua_method swig_spline1d_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_spline1d_attributes[] = {
    { "a", _wrap_Spline1D_a_get, _wrap_Spline1D_a_set},
    { "b", _wrap_Spline1D_b_get, _wrap_Spline1D_b_set},
    { "c", _wrap_Spline1D_c_get, _wrap_Spline1D_c_set},
    { "d", _wrap_Spline1D_d_get, _wrap_Spline1D_d_set},
    {0,0,0}
};
static swig_lua_class *swig_spline1d_bases[] = {0};
static const char *swig_spline1d_base_names[] = {0};
static swig_lua_class _wrap_class_spline1d = { "Spline1D", &SWIGTYPE_p_spline1d,_wrap_new_Spline1D, swig_delete_Spline1D, swig_spline1d_methods, swig_spline1d_attributes, swig_spline1d_bases, swig_spline1d_base_names };

static int _wrap_Spline_islinear_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::islinear",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::islinear",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::islinear",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_islinear_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->islinear = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_islinear_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::islinear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::islinear",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_islinear_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->islinear);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isquadratic_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::isquadratic",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isquadratic",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::isquadratic",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isquadratic_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->isquadratic = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isquadratic_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::isquadratic",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isquadratic",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isquadratic_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->isquadratic);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::isticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isticked",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::isticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isticked_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->isticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::isticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isticked",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isticked_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->isticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isneeded_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::isneeded",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isneeded",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::isneeded",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isneeded_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->isneeded = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isneeded_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::isneeded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isneeded",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isneeded_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->isneeded);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isunneeded_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::isunneeded",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isunneeded",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::isunneeded",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isunneeded_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->isunneeded = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_isunneeded_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::isunneeded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::isunneeded",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_isunneeded_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->isunneeded);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_exclude_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::exclude",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::exclude",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::exclude",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_exclude_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->exclude = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_exclude_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::exclude",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::exclude",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_exclude_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->exclude);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_ishorvert_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::ishorvert",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::ishorvert",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::ishorvert",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_ishorvert_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ishorvert = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_ishorvert_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::ishorvert",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::ishorvert",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_ishorvert_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->ishorvert);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_knowncurved_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::knowncurved",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::knowncurved",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::knowncurved",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_knowncurved_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->knowncurved = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_knowncurved_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::knowncurved",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::knowncurved",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_knowncurved_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->knowncurved);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_knownlinear_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::knownlinear",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::knownlinear",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::knownlinear",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_knownlinear_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->knownlinear = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_knownlinear_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::knownlinear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::knownlinear",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_knownlinear_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->knownlinear);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_order2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::order2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::order2",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::order2",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_order2_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->order2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_order2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::order2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::order2",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_order2_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->order2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_touched_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::touched",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::touched",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::touched",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_touched_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->touched = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_touched_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::touched",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::touched",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_touched_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->touched);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_leftedge_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::leftedge",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::leftedge",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::leftedge",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_leftedge_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->leftedge = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_leftedge_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::leftedge",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::leftedge",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_leftedge_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->leftedge);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_rightedge_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::rightedge",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::rightedge",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::rightedge",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_rightedge_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->rightedge = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_rightedge_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::rightedge",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::rightedge",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_rightedge_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->rightedge);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_acceptableextrema_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("spline::acceptableextrema",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::acceptableextrema",1,"struct spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("spline::acceptableextrema",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_acceptableextrema_set",1,SWIGTYPE_p_spline);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->acceptableextrema = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_acceptableextrema_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("spline::acceptableextrema",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::acceptableextrema",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_acceptableextrema_get",1,SWIGTYPE_p_spline);
  }
  
  result = (unsigned int) ((arg1)->acceptableextrema);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_from_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("spline::from",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::from",1,"struct spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("spline::from",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_from_set",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Spline_from_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->from = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_from_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("spline::from",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::from",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_from_get",1,SWIGTYPE_p_spline);
  }
  
  result = (SplinePoint *) ((arg1)->from);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_to_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("spline::to",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::to",1,"struct spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("spline::to",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_to_set",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Spline_to_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->to = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_to_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("spline::to",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::to",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_to_get",1,SWIGTYPE_p_spline);
  }
  
  result = (SplinePoint *) ((arg1)->to);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_splines_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  Spline1D *arg2 ;
  
  SWIG_check_num_args("spline::splines",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::splines",1,"struct spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("spline::splines",2,"Spline1D [2]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_splines_set",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("Spline_splines_set",2,SWIGTYPE_p_spline1d);
  }
  
  {
    size_t ii;
    Spline1D *b = (Spline1D *) arg1->splines;
    for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((Spline1D *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_splines_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  Spline1D *result = 0 ;
  
  SWIG_check_num_args("spline::splines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::splines",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_splines_get",1,SWIGTYPE_p_spline);
  }
  
  result = (Spline1D *)(Spline1D *) ((arg1)->splines);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline1d,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_approx_set(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  struct linearapprox *arg2 = (struct linearapprox *) 0 ;
  
  SWIG_check_num_args("spline::approx",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::approx",1,"struct spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("spline::approx",2,"struct linearapprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_approx_set",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_linearapprox,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Spline_approx_set",2,SWIGTYPE_p_linearapprox);
  }
  
  if (arg1) (arg1)->approx = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline_approx_get(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *arg1 = (struct spline *) 0 ;
  struct linearapprox *result = 0 ;
  
  SWIG_check_num_args("spline::approx",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("spline::approx",1,"struct spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline_approx_get",1,SWIGTYPE_p_spline);
  }
  
  result = (struct linearapprox *) ((arg1)->approx);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_linearapprox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Spline(lua_State* L) {
  int SWIG_arg = 0;
  struct spline *result = 0 ;
  
  SWIG_check_num_args("spline::spline",0,0)
  result = (struct spline *)calloc(1, sizeof(struct spline));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Spline(void *obj) {
struct spline *arg1 = (struct spline *) obj;
free((char *) arg1);
}
static swig_lua_method swig_spline_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_spline_attributes[] = {
    { "islinear", _wrap_Spline_islinear_get, _wrap_Spline_islinear_set},
    { "isquadratic", _wrap_Spline_isquadratic_get, _wrap_Spline_isquadratic_set},
    { "isticked", _wrap_Spline_isticked_get, _wrap_Spline_isticked_set},
    { "isneeded", _wrap_Spline_isneeded_get, _wrap_Spline_isneeded_set},
    { "isunneeded", _wrap_Spline_isunneeded_get, _wrap_Spline_isunneeded_set},
    { "exclude", _wrap_Spline_exclude_get, _wrap_Spline_exclude_set},
    { "ishorvert", _wrap_Spline_ishorvert_get, _wrap_Spline_ishorvert_set},
    { "knowncurved", _wrap_Spline_knowncurved_get, _wrap_Spline_knowncurved_set},
    { "knownlinear", _wrap_Spline_knownlinear_get, _wrap_Spline_knownlinear_set},
    { "order2", _wrap_Spline_order2_get, _wrap_Spline_order2_set},
    { "touched", _wrap_Spline_touched_get, _wrap_Spline_touched_set},
    { "leftedge", _wrap_Spline_leftedge_get, _wrap_Spline_leftedge_set},
    { "rightedge", _wrap_Spline_rightedge_get, _wrap_Spline_rightedge_set},
    { "acceptableextrema", _wrap_Spline_acceptableextrema_get, _wrap_Spline_acceptableextrema_set},
    { "from", _wrap_Spline_from_get, _wrap_Spline_from_set},
    { "to", _wrap_Spline_to_get, _wrap_Spline_to_set},
    { "splines", _wrap_Spline_splines_get, _wrap_Spline_splines_set},
    { "approx", _wrap_Spline_approx_get, _wrap_Spline_approx_set},
    {0,0,0}
};
static swig_lua_class *swig_spline_bases[] = {0};
static const char *swig_spline_base_names[] = {0};
static swig_lua_class _wrap_class_spline = { "Spline", &SWIGTYPE_p_spline,_wrap_new_Spline, swig_delete_Spline, swig_spline_methods, swig_spline_attributes, swig_spline_bases, swig_spline_base_names };

static int _wrap_SplinePointList_first_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("splinepointlist::first",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::first",1,"struct splinepointlist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepointlist::first",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_first_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplinePointList_first_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->first = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_first_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("splinepointlist::first",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::first",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_first_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplinePoint *) ((arg1)->first);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_last_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("splinepointlist::last",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::last",1,"struct splinepointlist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepointlist::last",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_last_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplinePointList_last_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->last = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_last_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("splinepointlist::last",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::last",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_last_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplinePoint *) ((arg1)->last);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  struct splinepointlist *arg2 = (struct splinepointlist *) 0 ;
  
  SWIG_check_num_args("splinepointlist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::next",1,"struct splinepointlist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepointlist::next",2,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_next_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplinePointList_next_set",2,SWIGTYPE_p_splinepointlist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  struct splinepointlist *result = 0 ;
  
  SWIG_check_num_args("splinepointlist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::next",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_next_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (struct splinepointlist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_spiros_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  spiro_cp *arg2 = (spiro_cp *) 0 ;
  
  SWIG_check_num_args("splinepointlist::spiros",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::spiros",1,"struct splinepointlist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinepointlist::spiros",2,"spiro_cp *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_spiros_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_spiro_cp,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplinePointList_spiros_set",2,SWIGTYPE_p_spiro_cp);
  }
  
  if (arg1) (arg1)->spiros = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_spiros_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  spiro_cp *result = 0 ;
  
  SWIG_check_num_args("splinepointlist::spiros",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::spiros",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_spiros_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (spiro_cp *) ((arg1)->spiros);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spiro_cp,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_spiro_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinepointlist::spiro_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::spiro_cnt",1,"struct splinepointlist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepointlist::spiro_cnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_spiro_cnt_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->spiro_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_spiro_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinepointlist::spiro_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::spiro_cnt",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_spiro_cnt_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (uint16) ((arg1)->spiro_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_spiro_max_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinepointlist::spiro_max",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::spiro_max",1,"struct splinepointlist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepointlist::spiro_max",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_spiro_max_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->spiro_max = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_spiro_max_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinepointlist::spiro_max",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::spiro_max",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_spiro_max_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (uint16) ((arg1)->spiro_max);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("splinepointlist::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::ticked",1,"struct splinepointlist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepointlist::ticked",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_ticked_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("splinepointlist::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::ticked",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_ticked_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (uint8) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_beziers_need_optimizer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("splinepointlist::beziers_need_optimizer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::beziers_need_optimizer",1,"struct splinepointlist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepointlist::beziers_need_optimizer",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_beziers_need_optimizer_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->beziers_need_optimizer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_beziers_need_optimizer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("splinepointlist::beziers_need_optimizer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::beziers_need_optimizer",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_beziers_need_optimizer_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (uint8) ((arg1)->beziers_need_optimizer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_is_clip_path_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("splinepointlist::is_clip_path",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::is_clip_path",1,"struct splinepointlist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinepointlist::is_clip_path",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_is_clip_path_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_clip_path = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_is_clip_path_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("splinepointlist::is_clip_path",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::is_clip_path",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_is_clip_path_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (uint8) ((arg1)->is_clip_path);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_contour_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinepointlist::contour_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::contour_name",1,"struct splinepointlist *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinepointlist::contour_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_contour_name_set",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->contour_name);
    if (arg2) {
      arg1->contour_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->contour_name, (const char *)arg2);
    } else {
      arg1->contour_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointList_contour_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *arg1 = (struct splinepointlist *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinepointlist::contour_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinepointlist::contour_name",1,"struct splinepointlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointList_contour_name_get",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (char *) ((arg1)->contour_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplinePointList(lua_State* L) {
  int SWIG_arg = 0;
  struct splinepointlist *result = 0 ;
  
  SWIG_check_num_args("splinepointlist::splinepointlist",0,0)
  result = (struct splinepointlist *)calloc(1, sizeof(struct splinepointlist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplinePointList(void *obj) {
struct splinepointlist *arg1 = (struct splinepointlist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_splinepointlist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_splinepointlist_attributes[] = {
    { "first", _wrap_SplinePointList_first_get, _wrap_SplinePointList_first_set},
    { "last", _wrap_SplinePointList_last_get, _wrap_SplinePointList_last_set},
    { "next", _wrap_SplinePointList_next_get, _wrap_SplinePointList_next_set},
    { "spiros", _wrap_SplinePointList_spiros_get, _wrap_SplinePointList_spiros_set},
    { "spiro_cnt", _wrap_SplinePointList_spiro_cnt_get, _wrap_SplinePointList_spiro_cnt_set},
    { "spiro_max", _wrap_SplinePointList_spiro_max_get, _wrap_SplinePointList_spiro_max_set},
    { "ticked", _wrap_SplinePointList_ticked_get, _wrap_SplinePointList_ticked_set},
    { "beziers_need_optimizer", _wrap_SplinePointList_beziers_need_optimizer_get, _wrap_SplinePointList_beziers_need_optimizer_set},
    { "is_clip_path", _wrap_SplinePointList_is_clip_path_get, _wrap_SplinePointList_is_clip_path_set},
    { "contour_name", _wrap_SplinePointList_contour_name_get, _wrap_SplinePointList_contour_name_set},
    {0,0,0}
};
static swig_lua_class *swig_splinepointlist_bases[] = {0};
static const char *swig_splinepointlist_base_names[] = {0};
static swig_lua_class _wrap_class_splinepointlist = { "SplinePointList", &SWIGTYPE_p_splinepointlist,_wrap_new_SplinePointList, swig_delete_SplinePointList, swig_splinepointlist_methods, swig_splinepointlist_attributes, swig_splinepointlist_bases, swig_splinepointlist_base_names };

static int _wrap_ImageList_image_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  struct gimage *arg2 = (struct gimage *) 0 ;
  
  SWIG_check_num_args("imagelist::image",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::image",1,"struct imagelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("imagelist::image",2,"struct gimage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_image_set",1,SWIGTYPE_p_imagelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gimage,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ImageList_image_set",2,SWIGTYPE_p_gimage);
  }
  
  if (arg1) (arg1)->image = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_image_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  struct gimage *result = 0 ;
  
  SWIG_check_num_args("imagelist::image",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::image",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_image_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (struct gimage *) ((arg1)->image);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gimage,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_xoff_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("imagelist::xoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::xoff",1,"struct imagelist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("imagelist::xoff",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_xoff_set",1,SWIGTYPE_p_imagelist);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_xoff_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float result;
  
  SWIG_check_num_args("imagelist::xoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::xoff",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_xoff_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (float) ((arg1)->xoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_yoff_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("imagelist::yoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::yoff",1,"struct imagelist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("imagelist::yoff",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_yoff_set",1,SWIGTYPE_p_imagelist);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->yoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_yoff_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float result;
  
  SWIG_check_num_args("imagelist::yoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::yoff",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_yoff_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (float) ((arg1)->yoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_xscale_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("imagelist::xscale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::xscale",1,"struct imagelist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("imagelist::xscale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_xscale_set",1,SWIGTYPE_p_imagelist);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->xscale = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_xscale_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float result;
  
  SWIG_check_num_args("imagelist::xscale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::xscale",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_xscale_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (float) ((arg1)->xscale);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_yscale_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("imagelist::yscale",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::yscale",1,"struct imagelist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("imagelist::yscale",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_yscale_set",1,SWIGTYPE_p_imagelist);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->yscale = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_yscale_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  float result;
  
  SWIG_check_num_args("imagelist::yscale",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::yscale",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_yscale_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (float) ((arg1)->yscale);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_bb_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("imagelist::bb",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::bb",1,"struct imagelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("imagelist::bb",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_bb_set",1,SWIGTYPE_p_imagelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("ImageList_bb_set",2,SWIGTYPE_p_dbounds);
  }
  
  if (arg1) (arg1)->bb = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_bb_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  DBounds *result = 0 ;
  
  SWIG_check_num_args("imagelist::bb",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::bb",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_bb_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (DBounds *)& ((arg1)->bb);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dbounds,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  struct imagelist *arg2 = (struct imagelist *) 0 ;
  
  SWIG_check_num_args("imagelist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::next",1,"struct imagelist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("imagelist::next",2,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_next_set",1,SWIGTYPE_p_imagelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_imagelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ImageList_next_set",2,SWIGTYPE_p_imagelist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  struct imagelist *result = 0 ;
  
  SWIG_check_num_args("imagelist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::next",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_next_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (struct imagelist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_imagelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_selected_set(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("imagelist::selected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::selected",1,"struct imagelist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("imagelist::selected",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_selected_set",1,SWIGTYPE_p_imagelist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->selected = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageList_selected_get(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *arg1 = (struct imagelist *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("imagelist::selected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("imagelist::selected",1,"struct imagelist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageList_selected_get",1,SWIGTYPE_p_imagelist);
  }
  
  result = (unsigned int) ((arg1)->selected);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ImageList(lua_State* L) {
  int SWIG_arg = 0;
  struct imagelist *result = 0 ;
  
  SWIG_check_num_args("imagelist::imagelist",0,0)
  result = (struct imagelist *)calloc(1, sizeof(struct imagelist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_imagelist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ImageList(void *obj) {
struct imagelist *arg1 = (struct imagelist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_imagelist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_imagelist_attributes[] = {
    { "image", _wrap_ImageList_image_get, _wrap_ImageList_image_set},
    { "xoff", _wrap_ImageList_xoff_get, _wrap_ImageList_xoff_set},
    { "yoff", _wrap_ImageList_yoff_get, _wrap_ImageList_yoff_set},
    { "xscale", _wrap_ImageList_xscale_get, _wrap_ImageList_xscale_set},
    { "yscale", _wrap_ImageList_yscale_get, _wrap_ImageList_yscale_set},
    { "bb", _wrap_ImageList_bb_get, _wrap_ImageList_bb_set},
    { "next", _wrap_ImageList_next_get, _wrap_ImageList_next_set},
    { "selected", _wrap_ImageList_selected_get, _wrap_ImageList_selected_set},
    {0,0,0}
};
static swig_lua_class *swig_imagelist_bases[] = {0};
static const char *swig_imagelist_base_names[] = {0};
static swig_lua_class _wrap_class_imagelist = { "ImageList", &SWIGTYPE_p_imagelist,_wrap_new_ImageList, swig_delete_ImageList, swig_imagelist_methods, swig_imagelist_attributes, swig_imagelist_bases, swig_imagelist_base_names };

static int _wrap_RefChar_checked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::checked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::checked",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::checked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_checked_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->checked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_checked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::checked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::checked",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_checked_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->checked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_selected_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::selected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::selected",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::selected",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_selected_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->selected = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_selected_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::selected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::selected",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_selected_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->selected);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_point_match_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::point_match",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::point_match",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::point_match",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_point_match_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->point_match = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_point_match_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::point_match",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::point_match",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_point_match_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->point_match);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_encoded_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::encoded",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::encoded",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::encoded",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_encoded_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->encoded = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_encoded_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::encoded",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::encoded",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_encoded_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->encoded);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_justtranslated_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::justtranslated",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::justtranslated",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::justtranslated",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_justtranslated_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->justtranslated = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_justtranslated_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::justtranslated",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::justtranslated",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_justtranslated_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->justtranslated);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_use_my_metrics_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::use_my_metrics",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::use_my_metrics",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::use_my_metrics",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_use_my_metrics_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->use_my_metrics = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_use_my_metrics_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::use_my_metrics",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::use_my_metrics",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_use_my_metrics_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->use_my_metrics);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_round_translation_to_grid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::round_translation_to_grid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::round_translation_to_grid",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::round_translation_to_grid",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_round_translation_to_grid_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->round_translation_to_grid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_round_translation_to_grid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::round_translation_to_grid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::round_translation_to_grid",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_round_translation_to_grid_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->round_translation_to_grid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_point_match_out_of_date_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("refchar::point_match_out_of_date",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::point_match_out_of_date",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::point_match_out_of_date",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_point_match_out_of_date_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->point_match_out_of_date = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_point_match_out_of_date_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("refchar::point_match_out_of_date",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::point_match_out_of_date",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_point_match_out_of_date_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (unsigned int) ((arg1)->point_match_out_of_date);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_adobe_enc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("refchar::adobe_enc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::adobe_enc",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::adobe_enc",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_adobe_enc_set",1,SWIGTYPE_p_refchar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->adobe_enc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_adobe_enc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("refchar::adobe_enc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::adobe_enc",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_adobe_enc_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (int16) ((arg1)->adobe_enc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_orig_pos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("refchar::orig_pos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::orig_pos",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::orig_pos",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_orig_pos_set",1,SWIGTYPE_p_refchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->orig_pos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_orig_pos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int result;
  
  SWIG_check_num_args("refchar::orig_pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::orig_pos",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_orig_pos_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (int) ((arg1)->orig_pos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_unicode_enc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("refchar::unicode_enc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::unicode_enc",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::unicode_enc",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_unicode_enc_set",1,SWIGTYPE_p_refchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unicode_enc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_unicode_enc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int result;
  
  SWIG_check_num_args("refchar::unicode_enc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::unicode_enc",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_unicode_enc_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (int) ((arg1)->unicode_enc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_transform_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("refchar::transform",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::transform",1,"struct refchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("refchar::transform",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_transform_set",1,SWIGTYPE_p_refchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("RefChar_transform_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->transform;
    for (ii = 0; ii < (size_t)6; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_transform_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("refchar::transform",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::transform",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_transform_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (float *)(float *) ((arg1)->transform);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layer_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("refchar::layer_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::layer_cnt",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::layer_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_layer_cnt_set",1,SWIGTYPE_p_refchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->layer_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layer_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  int result;
  
  SWIG_check_num_args("refchar::layer_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::layer_cnt",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_layer_cnt_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (int) ((arg1)->layer_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  struct refchar *arg2 = (struct refchar *) 0 ;
  
  SWIG_check_num_args("refchar::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::next",1,"struct refchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("refchar::next",2,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_next_set",1,SWIGTYPE_p_refchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refchar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("RefChar_next_set",2,SWIGTYPE_p_refchar);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  struct refchar *result = 0 ;
  
  SWIG_check_num_args("refchar::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::next",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_next_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (struct refchar *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_bb_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("refchar::bb",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::bb",1,"struct refchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("refchar::bb",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_bb_set",1,SWIGTYPE_p_refchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("RefChar_bb_set",2,SWIGTYPE_p_dbounds);
  }
  
  if (arg1) (arg1)->bb = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_bb_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  DBounds *result = 0 ;
  
  SWIG_check_num_args("refchar::bb",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::bb",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_bb_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (DBounds *)& ((arg1)->bb);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dbounds,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_sc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  struct splinechar *arg2 = (struct splinechar *) 0 ;
  
  SWIG_check_num_args("refchar::sc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::sc",1,"struct refchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("refchar::sc",2,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_sc_set",1,SWIGTYPE_p_refchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("RefChar_sc_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->sc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_sc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("refchar::sc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::sc",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_sc_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (struct splinechar *) ((arg1)->sc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_top_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("refchar::top",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::top",1,"struct refchar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("refchar::top",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_top_set",1,SWIGTYPE_p_refchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("RefChar_top_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->top = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_top_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("refchar::top",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::top",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_top_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (BasePoint *)& ((arg1)->top);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_match_pt_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("refchar::match_pt_base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::match_pt_base",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::match_pt_base",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_match_pt_base_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->match_pt_base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_match_pt_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("refchar::match_pt_base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::match_pt_base",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_match_pt_base_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (uint16) ((arg1)->match_pt_base);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_match_pt_ref_set(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("refchar::match_pt_ref",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::match_pt_ref",1,"struct refchar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("refchar::match_pt_ref",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_match_pt_ref_set",1,SWIGTYPE_p_refchar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->match_pt_ref = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_match_pt_ref_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("refchar::match_pt_ref",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::match_pt_ref",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_match_pt_ref_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (uint16) ((arg1)->match_pt_ref);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_get(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *arg1 = (struct refchar *) 0 ;
  RefChar_layers *result = 0 ;
  
  SWIG_check_num_args("refchar::layers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("refchar::layers",1,"struct refchar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefChar_layers_get",1,SWIGTYPE_p_refchar);
  }
  
  result = (RefChar_layers *) ((arg1)->layers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_RefChar_layers,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RefChar(lua_State* L) {
  int SWIG_arg = 0;
  struct refchar *result = 0 ;
  
  SWIG_check_num_args("refchar::refchar",0,0)
  result = (struct refchar *)calloc(1, sizeof(struct refchar));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RefChar(void *obj) {
struct refchar *arg1 = (struct refchar *) obj;
free((char *) arg1);
}
static swig_lua_method swig_refchar_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_refchar_attributes[] = {
    { "checked", _wrap_RefChar_checked_get, _wrap_RefChar_checked_set},
    { "selected", _wrap_RefChar_selected_get, _wrap_RefChar_selected_set},
    { "point_match", _wrap_RefChar_point_match_get, _wrap_RefChar_point_match_set},
    { "encoded", _wrap_RefChar_encoded_get, _wrap_RefChar_encoded_set},
    { "justtranslated", _wrap_RefChar_justtranslated_get, _wrap_RefChar_justtranslated_set},
    { "use_my_metrics", _wrap_RefChar_use_my_metrics_get, _wrap_RefChar_use_my_metrics_set},
    { "round_translation_to_grid", _wrap_RefChar_round_translation_to_grid_get, _wrap_RefChar_round_translation_to_grid_set},
    { "point_match_out_of_date", _wrap_RefChar_point_match_out_of_date_get, _wrap_RefChar_point_match_out_of_date_set},
    { "adobe_enc", _wrap_RefChar_adobe_enc_get, _wrap_RefChar_adobe_enc_set},
    { "orig_pos", _wrap_RefChar_orig_pos_get, _wrap_RefChar_orig_pos_set},
    { "unicode_enc", _wrap_RefChar_unicode_enc_get, _wrap_RefChar_unicode_enc_set},
    { "transform", _wrap_RefChar_transform_get, _wrap_RefChar_transform_set},
    { "layer_cnt", _wrap_RefChar_layer_cnt_get, _wrap_RefChar_layer_cnt_set},
    { "next", _wrap_RefChar_next_get, _wrap_RefChar_next_set},
    { "bb", _wrap_RefChar_bb_get, _wrap_RefChar_bb_set},
    { "sc", _wrap_RefChar_sc_get, _wrap_RefChar_sc_set},
    { "top", _wrap_RefChar_top_get, _wrap_RefChar_top_set},
    { "match_pt_base", _wrap_RefChar_match_pt_base_get, _wrap_RefChar_match_pt_base_set},
    { "match_pt_ref", _wrap_RefChar_match_pt_ref_get, _wrap_RefChar_match_pt_ref_set},
    { "layers", _wrap_RefChar_layers_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_refchar_bases[] = {0};
static const char *swig_refchar_base_names[] = {0};
static swig_lua_class _wrap_class_refchar = { "RefChar", &SWIGTYPE_p_refchar,_wrap_new_RefChar, swig_delete_RefChar, swig_refchar_methods, swig_refchar_attributes, swig_refchar_bases, swig_refchar_base_names };

static int _wrap_RefChar_layers_background_set(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("RefChar_layers::background",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::background",1,"RefChar_layers *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RefChar_layers::background",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_background_set",1,SWIGTYPE_p_RefChar_layers);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->background = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_background_get(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("RefChar_layers::background",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::background",1,"RefChar_layers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_background_get",1,SWIGTYPE_p_RefChar_layers);
  }
  
  result = (unsigned int) ((arg1)->background);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_order2_set(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("RefChar_layers::order2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::order2",1,"RefChar_layers *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RefChar_layers::order2",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_order2_set",1,SWIGTYPE_p_RefChar_layers);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->order2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_order2_get(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("RefChar_layers::order2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::order2",1,"RefChar_layers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_order2_get",1,SWIGTYPE_p_RefChar_layers);
  }
  
  result = (unsigned int) ((arg1)->order2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_anyflexes_set(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("RefChar_layers::anyflexes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::anyflexes",1,"RefChar_layers *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RefChar_layers::anyflexes",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_anyflexes_set",1,SWIGTYPE_p_RefChar_layers);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->anyflexes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_anyflexes_get(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("RefChar_layers::anyflexes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::anyflexes",1,"RefChar_layers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_anyflexes_get",1,SWIGTYPE_p_RefChar_layers);
  }
  
  result = (unsigned int) ((arg1)->anyflexes);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_splines_set(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("RefChar_layers::splines",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::splines",1,"RefChar_layers *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RefChar_layers::splines",2,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_splines_set",1,SWIGTYPE_p_RefChar_layers);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("RefChar_layers_splines_set",2,SWIGTYPE_p_splinepointlist);
  }
  
  if (arg1) (arg1)->splines = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_splines_get(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("RefChar_layers::splines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::splines",1,"RefChar_layers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_splines_get",1,SWIGTYPE_p_RefChar_layers);
  }
  
  result = (SplinePointList *) ((arg1)->splines);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_images_set(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  ImageList *arg2 = (ImageList *) 0 ;
  
  SWIG_check_num_args("RefChar_layers::images",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::images",1,"RefChar_layers *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RefChar_layers::images",2,"ImageList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_images_set",1,SWIGTYPE_p_RefChar_layers);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_imagelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("RefChar_layers_images_set",2,SWIGTYPE_p_imagelist);
  }
  
  if (arg1) (arg1)->images = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefChar_layers_images_get(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *arg1 = (RefChar_layers *) 0 ;
  ImageList *result = 0 ;
  
  SWIG_check_num_args("RefChar_layers::images",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefChar_layers::images",1,"RefChar_layers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_RefChar_layers,0))){
    SWIG_fail_ptr("RefChar_layers_images_get",1,SWIGTYPE_p_RefChar_layers);
  }
  
  result = (ImageList *) ((arg1)->images);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_imagelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_RefChar_layers(lua_State* L) {
  int SWIG_arg = 0;
  RefChar_layers *result = 0 ;
  
  SWIG_check_num_args("RefChar_layers::RefChar_layers",0,0)
  result = (RefChar_layers *)calloc(1, sizeof(RefChar_layers));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_RefChar_layers,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_RefChar_layers(void *obj) {
RefChar_layers *arg1 = (RefChar_layers *) obj;
free((char *) arg1);
}
static swig_lua_method swig_RefChar_layers_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_RefChar_layers_attributes[] = {
    { "background", _wrap_RefChar_layers_background_get, _wrap_RefChar_layers_background_set},
    { "order2", _wrap_RefChar_layers_order2_get, _wrap_RefChar_layers_order2_set},
    { "anyflexes", _wrap_RefChar_layers_anyflexes_get, _wrap_RefChar_layers_anyflexes_set},
    { "splines", _wrap_RefChar_layers_splines_get, _wrap_RefChar_layers_splines_set},
    { "images", _wrap_RefChar_layers_images_get, _wrap_RefChar_layers_images_set},
    {0,0,0}
};
static swig_lua_class *swig_RefChar_layers_bases[] = {0};
static const char *swig_RefChar_layers_base_names[] = {0};
static swig_lua_class _wrap_class_RefChar_layers = { "RefChar_layers", &SWIGTYPE_p_RefChar_layers,_wrap_new_RefChar_layers, swig_delete_RefChar_layers, swig_RefChar_layers_methods, swig_RefChar_layers_attributes, swig_RefChar_layers_bases, swig_RefChar_layers_base_names };

static int _wrap_HintInstance_begin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("hintinstance::begin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::begin",1,"struct hintinstance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hintinstance::begin",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_begin_set",1,SWIGTYPE_p_hintinstance);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->begin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_begin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  float result;
  
  SWIG_check_num_args("hintinstance::begin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::begin",1,"struct hintinstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_begin_get",1,SWIGTYPE_p_hintinstance);
  }
  
  result = (float) ((arg1)->begin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_end_set(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("hintinstance::end",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::end",1,"struct hintinstance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hintinstance::end",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_end_set",1,SWIGTYPE_p_hintinstance);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->end = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_end_get(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  float result;
  
  SWIG_check_num_args("hintinstance::end",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::end",1,"struct hintinstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_end_get",1,SWIGTYPE_p_hintinstance);
  }
  
  result = (float) ((arg1)->end);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_closed_set(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("hintinstance::closed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::closed",1,"struct hintinstance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hintinstance::closed",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_closed_set",1,SWIGTYPE_p_hintinstance);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->closed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_closed_get(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("hintinstance::closed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::closed",1,"struct hintinstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_closed_get",1,SWIGTYPE_p_hintinstance);
  }
  
  result = (unsigned int) ((arg1)->closed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_counternumber_set(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("hintinstance::counternumber",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::counternumber",1,"struct hintinstance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hintinstance::counternumber",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_counternumber_set",1,SWIGTYPE_p_hintinstance);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  if (arg1) (arg1)->counternumber = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_counternumber_get(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  short result;
  
  SWIG_check_num_args("hintinstance::counternumber",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::counternumber",1,"struct hintinstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_counternumber_get",1,SWIGTYPE_p_hintinstance);
  }
  
  result = (short) ((arg1)->counternumber);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  struct hintinstance *arg2 = (struct hintinstance *) 0 ;
  
  SWIG_check_num_args("hintinstance::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::next",1,"struct hintinstance *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("hintinstance::next",2,"struct hintinstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_next_set",1,SWIGTYPE_p_hintinstance);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hintinstance,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("HintInstance_next_set",2,SWIGTYPE_p_hintinstance);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintInstance_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *arg1 = (struct hintinstance *) 0 ;
  struct hintinstance *result = 0 ;
  
  SWIG_check_num_args("hintinstance::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hintinstance::next",1,"struct hintinstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HintInstance_next_get",1,SWIGTYPE_p_hintinstance);
  }
  
  result = (struct hintinstance *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hintinstance,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_HintInstance(lua_State* L) {
  int SWIG_arg = 0;
  struct hintinstance *result = 0 ;
  
  SWIG_check_num_args("hintinstance::hintinstance",0,0)
  result = (struct hintinstance *)calloc(1, sizeof(struct hintinstance));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hintinstance,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_HintInstance(void *obj) {
struct hintinstance *arg1 = (struct hintinstance *) obj;
free((char *) arg1);
}
static swig_lua_method swig_hintinstance_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_hintinstance_attributes[] = {
    { "begin", _wrap_HintInstance_begin_get, _wrap_HintInstance_begin_set},
    { "end", _wrap_HintInstance_end_get, _wrap_HintInstance_end_set},
    { "closed", _wrap_HintInstance_closed_get, _wrap_HintInstance_closed_set},
    { "counternumber", _wrap_HintInstance_counternumber_get, _wrap_HintInstance_counternumber_set},
    { "next", _wrap_HintInstance_next_get, _wrap_HintInstance_next_set},
    {0,0,0}
};
static swig_lua_class *swig_hintinstance_bases[] = {0};
static const char *swig_hintinstance_base_names[] = {0};
static swig_lua_class _wrap_class_hintinstance = { "HintInstance", &SWIGTYPE_p_hintinstance,_wrap_new_HintInstance, swig_delete_HintInstance, swig_hintinstance_methods, swig_hintinstance_attributes, swig_hintinstance_bases, swig_hintinstance_base_names };

static int _wrap_StemInfo_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  struct steminfo *arg2 = (struct steminfo *) 0 ;
  
  SWIG_check_num_args("steminfo::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::next",1,"struct steminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("steminfo::next",2,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_next_set",1,SWIGTYPE_p_steminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_steminfo,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("StemInfo_next_set",2,SWIGTYPE_p_steminfo);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  struct steminfo *result = 0 ;
  
  SWIG_check_num_args("steminfo::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::next",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_next_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (struct steminfo *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_steminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_hinttype_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::hinttype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::hinttype",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::hinttype",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_hinttype_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hinttype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_hinttype_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::hinttype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::hinttype",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_hinttype_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->hinttype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_ghost_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::ghost",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::ghost",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::ghost",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_ghost_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ghost = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_ghost_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::ghost",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::ghost",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_ghost_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->ghost);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_haspointleft_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::haspointleft",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::haspointleft",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::haspointleft",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_haspointleft_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->haspointleft = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_haspointleft_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::haspointleft",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::haspointleft",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_haspointleft_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->haspointleft);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_haspointright_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::haspointright",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::haspointright",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::haspointright",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_haspointright_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->haspointright = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_haspointright_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::haspointright",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::haspointright",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_haspointright_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->haspointright);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_hasconflicts_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::hasconflicts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::hasconflicts",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::hasconflicts",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_hasconflicts_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hasconflicts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_hasconflicts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::hasconflicts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::hasconflicts",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_hasconflicts_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->hasconflicts);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_used_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::used",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::used",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::used",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_used_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->used = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_used_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::used",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::used",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_used_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->used);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_tobeused_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::tobeused",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::tobeused",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::tobeused",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_tobeused_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->tobeused = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_tobeused_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::tobeused",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::tobeused",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_tobeused_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->tobeused);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_active_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::active",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::active",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::active",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_active_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->active = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_active_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::active",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::active",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_active_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->active);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_enddone_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::enddone",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::enddone",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::enddone",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_enddone_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->enddone = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_enddone_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::enddone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::enddone",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_enddone_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->enddone);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_startdone_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::startdone",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::startdone",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::startdone",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_startdone_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->startdone = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_startdone_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::startdone",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::startdone",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_startdone_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->startdone);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_reordered_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::reordered",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::reordered",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::reordered",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_reordered_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->reordered = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_reordered_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::reordered",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::reordered",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_reordered_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->reordered);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_pendingpt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::pendingpt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::pendingpt",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::pendingpt",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_pendingpt_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pendingpt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_pendingpt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::pendingpt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::pendingpt",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_pendingpt_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->pendingpt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_linearedges_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("steminfo::linearedges",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::linearedges",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::linearedges",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_linearedges_set",1,SWIGTYPE_p_steminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->linearedges = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_linearedges_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("steminfo::linearedges",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::linearedges",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_linearedges_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (unsigned int) ((arg1)->linearedges);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_hintnumber_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("steminfo::hintnumber",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::hintnumber",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::hintnumber",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_hintnumber_set",1,SWIGTYPE_p_steminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->hintnumber = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_hintnumber_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("steminfo::hintnumber",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::hintnumber",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_hintnumber_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (int16) ((arg1)->hintnumber);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_start_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("steminfo::start",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::start",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::start",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_start_set",1,SWIGTYPE_p_steminfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->start = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_start_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  float result;
  
  SWIG_check_num_args("steminfo::start",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::start",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_start_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (float) ((arg1)->start);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("steminfo::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::width",1,"struct steminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("steminfo::width",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_width_set",1,SWIGTYPE_p_steminfo);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  float result;
  
  SWIG_check_num_args("steminfo::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::width",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_width_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (float) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_where_set(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  HintInstance *arg2 = (HintInstance *) 0 ;
  
  SWIG_check_num_args("steminfo::where",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::where",1,"struct steminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("steminfo::where",2,"HintInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_where_set",1,SWIGTYPE_p_steminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hintinstance,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("StemInfo_where_set",2,SWIGTYPE_p_hintinstance);
  }
  
  if (arg1) (arg1)->where = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_where_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  HintInstance *result = 0 ;
  
  SWIG_check_num_args("steminfo::where",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::where",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_where_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (HintInstance *) ((arg1)->where);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hintinstance,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_u_get(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *arg1 = (struct steminfo *) 0 ;
  StemInfo_u *result = 0 ;
  
  SWIG_check_num_args("steminfo::u",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("steminfo::u",1,"struct steminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfo_u_get",1,SWIGTYPE_p_steminfo);
  }
  
  result = (StemInfo_u *)& ((arg1)->u);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_StemInfo_u,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_StemInfo(lua_State* L) {
  int SWIG_arg = 0;
  struct steminfo *result = 0 ;
  
  SWIG_check_num_args("steminfo::steminfo",0,0)
  result = (struct steminfo *)calloc(1, sizeof(struct steminfo));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_steminfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_StemInfo(void *obj) {
struct steminfo *arg1 = (struct steminfo *) obj;
free((char *) arg1);
}
static swig_lua_method swig_steminfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_steminfo_attributes[] = {
    { "next", _wrap_StemInfo_next_get, _wrap_StemInfo_next_set},
    { "hinttype", _wrap_StemInfo_hinttype_get, _wrap_StemInfo_hinttype_set},
    { "ghost", _wrap_StemInfo_ghost_get, _wrap_StemInfo_ghost_set},
    { "haspointleft", _wrap_StemInfo_haspointleft_get, _wrap_StemInfo_haspointleft_set},
    { "haspointright", _wrap_StemInfo_haspointright_get, _wrap_StemInfo_haspointright_set},
    { "hasconflicts", _wrap_StemInfo_hasconflicts_get, _wrap_StemInfo_hasconflicts_set},
    { "used", _wrap_StemInfo_used_get, _wrap_StemInfo_used_set},
    { "tobeused", _wrap_StemInfo_tobeused_get, _wrap_StemInfo_tobeused_set},
    { "active", _wrap_StemInfo_active_get, _wrap_StemInfo_active_set},
    { "enddone", _wrap_StemInfo_enddone_get, _wrap_StemInfo_enddone_set},
    { "startdone", _wrap_StemInfo_startdone_get, _wrap_StemInfo_startdone_set},
    { "reordered", _wrap_StemInfo_reordered_get, _wrap_StemInfo_reordered_set},
    { "pendingpt", _wrap_StemInfo_pendingpt_get, _wrap_StemInfo_pendingpt_set},
    { "linearedges", _wrap_StemInfo_linearedges_get, _wrap_StemInfo_linearedges_set},
    { "hintnumber", _wrap_StemInfo_hintnumber_get, _wrap_StemInfo_hintnumber_set},
    { "start", _wrap_StemInfo_start_get, _wrap_StemInfo_start_set},
    { "width", _wrap_StemInfo_width_get, _wrap_StemInfo_width_set},
    { "where", _wrap_StemInfo_where_get, _wrap_StemInfo_where_set},
    { "u", _wrap_StemInfo_u_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_steminfo_bases[] = {0};
static const char *swig_steminfo_base_names[] = {0};
static swig_lua_class _wrap_class_steminfo = { "StemInfo", &SWIGTYPE_p_steminfo,_wrap_new_StemInfo, swig_delete_StemInfo, swig_steminfo_methods, swig_steminfo_attributes, swig_steminfo_bases, swig_steminfo_base_names };

static int _wrap_StemInfo_u_mask_set(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo_u *arg1 = (StemInfo_u *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("StemInfo_u::mask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfo_u::mask",1,"StemInfo_u *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("StemInfo_u::mask",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_StemInfo_u,0))){
    SWIG_fail_ptr("StemInfo_u_mask_set",1,SWIGTYPE_p_StemInfo_u);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->mask = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_u_mask_get(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo_u *arg1 = (StemInfo_u *) 0 ;
  int result;
  
  SWIG_check_num_args("StemInfo_u::mask",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfo_u::mask",1,"StemInfo_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_StemInfo_u,0))){
    SWIG_fail_ptr("StemInfo_u_mask_get",1,SWIGTYPE_p_StemInfo_u);
  }
  
  result = (int) ((arg1)->mask);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_u_unblended_set(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo_u *arg1 = (StemInfo_u *) 0 ;
  _MMArray *arg2 = (_MMArray *) 0 ;
  
  SWIG_check_num_args("StemInfo_u::unblended",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfo_u::unblended",1,"StemInfo_u *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("StemInfo_u::unblended",2,"_MMArray *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_StemInfo_u,0))){
    SWIG_fail_ptr("StemInfo_u_unblended_set",1,SWIGTYPE_p_StemInfo_u);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_a_2__a_16__float,0))){
    SWIG_fail_ptr("StemInfo_u_unblended_set",2,SWIGTYPE_p_a_2__a_16__float);
  }
  
  if (arg1) (arg1)->unblended = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfo_u_unblended_get(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo_u *arg1 = (StemInfo_u *) 0 ;
  _MMArray *result = 0 ;
  
  SWIG_check_num_args("StemInfo_u::unblended",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfo_u::unblended",1,"StemInfo_u *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_StemInfo_u,0))){
    SWIG_fail_ptr("StemInfo_u_unblended_get",1,SWIGTYPE_p_StemInfo_u);
  }
  
  result = (_MMArray *) ((arg1)->unblended);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_a_2__a_16__float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_StemInfo_u(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo_u *result = 0 ;
  
  SWIG_check_num_args("StemInfo_u::StemInfo_u",0,0)
  result = (StemInfo_u *)calloc(1, sizeof(StemInfo_u));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_StemInfo_u,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_StemInfo_u(void *obj) {
StemInfo_u *arg1 = (StemInfo_u *) obj;
free((char *) arg1);
}
static swig_lua_method swig_StemInfo_u_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_StemInfo_u_attributes[] = {
    { "mask", _wrap_StemInfo_u_mask_get, _wrap_StemInfo_u_mask_set},
    { "unblended", _wrap_StemInfo_u_unblended_get, _wrap_StemInfo_u_unblended_set},
    {0,0,0}
};
static swig_lua_class *swig_StemInfo_u_bases[] = {0};
static const char *swig_StemInfo_u_base_names[] = {0};
static swig_lua_class _wrap_class_StemInfo_u = { "StemInfo_u", &SWIGTYPE_p_StemInfo_u,_wrap_new_StemInfo_u, swig_delete_StemInfo_u, swig_StemInfo_u_methods, swig_StemInfo_u_attributes, swig_StemInfo_u_bases, swig_StemInfo_u_base_names };

static int _wrap_DStemInfo_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  struct dsteminfo *arg2 = (struct dsteminfo *) 0 ;
  
  SWIG_check_num_args("dsteminfo::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::next",1,"struct dsteminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("dsteminfo::next",2,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_next_set",1,SWIGTYPE_p_dsteminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dsteminfo,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("DStemInfo_next_set",2,SWIGTYPE_p_dsteminfo);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  struct dsteminfo *result = 0 ;
  
  SWIG_check_num_args("dsteminfo::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::next",1,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_next_get",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (struct dsteminfo *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dsteminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_hinttype_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("dsteminfo::hinttype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::hinttype",1,"struct dsteminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dsteminfo::hinttype",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_hinttype_set",1,SWIGTYPE_p_dsteminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hinttype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_hinttype_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("dsteminfo::hinttype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::hinttype",1,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_hinttype_get",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (unsigned int) ((arg1)->hinttype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_used_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("dsteminfo::used",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::used",1,"struct dsteminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("dsteminfo::used",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_used_set",1,SWIGTYPE_p_dsteminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->used = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_used_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("dsteminfo::used",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::used",1,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_used_get",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (unsigned int) ((arg1)->used);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_left_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("dsteminfo::left",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::left",1,"struct dsteminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("dsteminfo::left",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_left_set",1,SWIGTYPE_p_dsteminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("DStemInfo_left_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->left = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_left_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("dsteminfo::left",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::left",1,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_left_get",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (BasePoint *)& ((arg1)->left);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_right_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("dsteminfo::right",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::right",1,"struct dsteminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("dsteminfo::right",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_right_set",1,SWIGTYPE_p_dsteminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("DStemInfo_right_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->right = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_right_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("dsteminfo::right",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::right",1,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_right_get",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (BasePoint *)& ((arg1)->right);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_unit_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("dsteminfo::unit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::unit",1,"struct dsteminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("dsteminfo::unit",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_unit_set",1,SWIGTYPE_p_dsteminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("DStemInfo_unit_set",2,SWIGTYPE_p_basepoint);
  }
  
  if (arg1) (arg1)->unit = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_unit_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  BasePoint *result = 0 ;
  
  SWIG_check_num_args("dsteminfo::unit",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::unit",1,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_unit_get",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (BasePoint *)& ((arg1)->unit);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_where_set(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  HintInstance *arg2 = (HintInstance *) 0 ;
  
  SWIG_check_num_args("dsteminfo::where",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::where",1,"struct dsteminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("dsteminfo::where",2,"HintInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_where_set",1,SWIGTYPE_p_dsteminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hintinstance,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("DStemInfo_where_set",2,SWIGTYPE_p_hintinstance);
  }
  
  if (arg1) (arg1)->where = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfo_where_get(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *arg1 = (struct dsteminfo *) 0 ;
  HintInstance *result = 0 ;
  
  SWIG_check_num_args("dsteminfo::where",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("dsteminfo::where",1,"struct dsteminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfo_where_get",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (HintInstance *) ((arg1)->where);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hintinstance,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_DStemInfo(lua_State* L) {
  int SWIG_arg = 0;
  struct dsteminfo *result = 0 ;
  
  SWIG_check_num_args("dsteminfo::dsteminfo",0,0)
  result = (struct dsteminfo *)calloc(1, sizeof(struct dsteminfo));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dsteminfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_DStemInfo(void *obj) {
struct dsteminfo *arg1 = (struct dsteminfo *) obj;
free((char *) arg1);
}
static swig_lua_method swig_dsteminfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_dsteminfo_attributes[] = {
    { "next", _wrap_DStemInfo_next_get, _wrap_DStemInfo_next_set},
    { "hinttype", _wrap_DStemInfo_hinttype_get, _wrap_DStemInfo_hinttype_set},
    { "used", _wrap_DStemInfo_used_get, _wrap_DStemInfo_used_set},
    { "left", _wrap_DStemInfo_left_get, _wrap_DStemInfo_left_set},
    { "right", _wrap_DStemInfo_right_get, _wrap_DStemInfo_right_set},
    { "unit", _wrap_DStemInfo_unit_get, _wrap_DStemInfo_unit_set},
    { "where", _wrap_DStemInfo_where_get, _wrap_DStemInfo_where_set},
    {0,0,0}
};
static swig_lua_class *swig_dsteminfo_bases[] = {0};
static const char *swig_dsteminfo_base_names[] = {0};
static swig_lua_class _wrap_class_dsteminfo = { "DStemInfo", &SWIGTYPE_p_dsteminfo,_wrap_new_DStemInfo, swig_delete_DStemInfo, swig_dsteminfo_methods, swig_dsteminfo_attributes, swig_dsteminfo_bases, swig_dsteminfo_base_names };

static int _wrap_MinimumDistance_sp1_set(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("minimumdistance::sp1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::sp1",1,"struct minimumdistance *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("minimumdistance::sp1",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_sp1_set",1,SWIGTYPE_p_minimumdistance);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MinimumDistance_sp1_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->sp1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_sp1_get(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("minimumdistance::sp1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::sp1",1,"struct minimumdistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_sp1_get",1,SWIGTYPE_p_minimumdistance);
  }
  
  result = (SplinePoint *) ((arg1)->sp1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_sp2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("minimumdistance::sp2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::sp2",1,"struct minimumdistance *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("minimumdistance::sp2",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_sp2_set",1,SWIGTYPE_p_minimumdistance);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MinimumDistance_sp2_set",2,SWIGTYPE_p_splinepoint);
  }
  
  if (arg1) (arg1)->sp2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_sp2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("minimumdistance::sp2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::sp2",1,"struct minimumdistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_sp2_get",1,SWIGTYPE_p_minimumdistance);
  }
  
  result = (SplinePoint *) ((arg1)->sp2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_x_set(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("minimumdistance::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::x",1,"struct minimumdistance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("minimumdistance::x",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_x_set",1,SWIGTYPE_p_minimumdistance);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_x_get(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("minimumdistance::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::x",1,"struct minimumdistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_x_get",1,SWIGTYPE_p_minimumdistance);
  }
  
  result = (unsigned int) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_done_set(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("minimumdistance::done",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::done",1,"struct minimumdistance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("minimumdistance::done",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_done_set",1,SWIGTYPE_p_minimumdistance);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->done = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_done_get(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("minimumdistance::done",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::done",1,"struct minimumdistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_done_get",1,SWIGTYPE_p_minimumdistance);
  }
  
  result = (unsigned int) ((arg1)->done);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  struct minimumdistance *arg2 = (struct minimumdistance *) 0 ;
  
  SWIG_check_num_args("minimumdistance::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::next",1,"struct minimumdistance *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("minimumdistance::next",2,"struct minimumdistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_next_set",1,SWIGTYPE_p_minimumdistance);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_minimumdistance,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MinimumDistance_next_set",2,SWIGTYPE_p_minimumdistance);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistance_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *arg1 = (struct minimumdistance *) 0 ;
  struct minimumdistance *result = 0 ;
  
  SWIG_check_num_args("minimumdistance::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("minimumdistance::next",1,"struct minimumdistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistance_next_get",1,SWIGTYPE_p_minimumdistance);
  }
  
  result = (struct minimumdistance *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_minimumdistance,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MinimumDistance(lua_State* L) {
  int SWIG_arg = 0;
  struct minimumdistance *result = 0 ;
  
  SWIG_check_num_args("minimumdistance::minimumdistance",0,0)
  result = (struct minimumdistance *)calloc(1, sizeof(struct minimumdistance));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_minimumdistance,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MinimumDistance(void *obj) {
struct minimumdistance *arg1 = (struct minimumdistance *) obj;
free((char *) arg1);
}
static swig_lua_method swig_minimumdistance_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_minimumdistance_attributes[] = {
    { "sp1", _wrap_MinimumDistance_sp1_get, _wrap_MinimumDistance_sp1_set},
    { "sp2", _wrap_MinimumDistance_sp2_get, _wrap_MinimumDistance_sp2_set},
    { "x", _wrap_MinimumDistance_x_get, _wrap_MinimumDistance_x_set},
    { "done", _wrap_MinimumDistance_done_get, _wrap_MinimumDistance_done_set},
    { "next", _wrap_MinimumDistance_next_get, _wrap_MinimumDistance_next_set},
    {0,0,0}
};
static swig_lua_class *swig_minimumdistance_bases[] = {0};
static const char *swig_minimumdistance_base_names[] = {0};
static swig_lua_class _wrap_class_minimumdistance = { "MinimumDistance", &SWIGTYPE_p_minimumdistance,_wrap_new_MinimumDistance, swig_delete_MinimumDistance, swig_minimumdistance_methods, swig_minimumdistance_attributes, swig_minimumdistance_bases, swig_minimumdistance_base_names };

static int _wrap_Layer_background_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("layer::background",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::background",1,"struct layer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layer::background",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_background_set",1,SWIGTYPE_p_layer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->background = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_background_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("layer::background",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::background",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_background_get",1,SWIGTYPE_p_layer);
  }
  
  result = (unsigned int) ((arg1)->background);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_order2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("layer::order2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::order2",1,"struct layer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layer::order2",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_order2_set",1,SWIGTYPE_p_layer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->order2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_order2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("layer::order2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::order2",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_order2_get",1,SWIGTYPE_p_layer);
  }
  
  result = (unsigned int) ((arg1)->order2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_anyflexes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("layer::anyflexes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::anyflexes",1,"struct layer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layer::anyflexes",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_anyflexes_set",1,SWIGTYPE_p_layer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->anyflexes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_anyflexes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("layer::anyflexes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::anyflexes",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_anyflexes_get",1,SWIGTYPE_p_layer);
  }
  
  result = (unsigned int) ((arg1)->anyflexes);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_splines_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("layer::splines",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::splines",1,"struct layer *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("layer::splines",2,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_splines_set",1,SWIGTYPE_p_layer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Layer_splines_set",2,SWIGTYPE_p_splinepointlist);
  }
  
  if (arg1) (arg1)->splines = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_splines_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("layer::splines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::splines",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_splines_get",1,SWIGTYPE_p_layer);
  }
  
  result = (SplinePointList *) ((arg1)->splines);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_images_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  ImageList *arg2 = (ImageList *) 0 ;
  
  SWIG_check_num_args("layer::images",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::images",1,"struct layer *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("layer::images",2,"ImageList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_images_set",1,SWIGTYPE_p_layer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_imagelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Layer_images_set",2,SWIGTYPE_p_imagelist);
  }
  
  if (arg1) (arg1)->images = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_images_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  ImageList *result = 0 ;
  
  SWIG_check_num_args("layer::images",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::images",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_images_get",1,SWIGTYPE_p_layer);
  }
  
  result = (ImageList *) ((arg1)->images);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_imagelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_refs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  RefChar *arg2 = (RefChar *) 0 ;
  
  SWIG_check_num_args("layer::refs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::refs",1,"struct layer *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("layer::refs",2,"RefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_refs_set",1,SWIGTYPE_p_layer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refchar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Layer_refs_set",2,SWIGTYPE_p_refchar);
  }
  
  if (arg1) (arg1)->refs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_refs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  RefChar *result = 0 ;
  
  SWIG_check_num_args("layer::refs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::refs",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_refs_get",1,SWIGTYPE_p_layer);
  }
  
  result = (RefChar *) ((arg1)->refs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_undoes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  Undoes *arg2 = (Undoes *) 0 ;
  
  SWIG_check_num_args("layer::undoes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::undoes",1,"struct layer *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("layer::undoes",2,"Undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_undoes_set",1,SWIGTYPE_p_layer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Layer_undoes_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->undoes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_undoes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("layer::undoes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::undoes",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_undoes_get",1,SWIGTYPE_p_layer);
  }
  
  result = (Undoes *) ((arg1)->undoes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_redoes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  Undoes *arg2 = (Undoes *) 0 ;
  
  SWIG_check_num_args("layer::redoes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::redoes",1,"struct layer *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("layer::redoes",2,"Undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_redoes_set",1,SWIGTYPE_p_layer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_undoes,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Layer_redoes_set",2,SWIGTYPE_p_undoes);
  }
  
  if (arg1) (arg1)->redoes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_redoes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("layer::redoes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::redoes",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_redoes_get",1,SWIGTYPE_p_layer);
  }
  
  result = (Undoes *) ((arg1)->redoes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_validation_state_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("layer::validation_state",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::validation_state",1,"struct layer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layer::validation_state",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_validation_state_set",1,SWIGTYPE_p_layer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->validation_state = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_validation_state_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("layer::validation_state",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::validation_state",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_validation_state_get",1,SWIGTYPE_p_layer);
  }
  
  result = (uint32) ((arg1)->validation_state);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_old_vs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("layer::old_vs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::old_vs",1,"struct layer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layer::old_vs",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_old_vs_set",1,SWIGTYPE_p_layer);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->old_vs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Layer_old_vs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *arg1 = (struct layer *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("layer::old_vs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layer::old_vs",1,"struct layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("Layer_old_vs_get",1,SWIGTYPE_p_layer);
  }
  
  result = (uint32) ((arg1)->old_vs);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Layer(lua_State* L) {
  int SWIG_arg = 0;
  struct layer *result = 0 ;
  
  SWIG_check_num_args("layer::layer",0,0)
  result = (struct layer *)calloc(1, sizeof(struct layer));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_layer,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Layer(void *obj) {
struct layer *arg1 = (struct layer *) obj;
free((char *) arg1);
}
static swig_lua_method swig_layer_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_layer_attributes[] = {
    { "background", _wrap_Layer_background_get, _wrap_Layer_background_set},
    { "order2", _wrap_Layer_order2_get, _wrap_Layer_order2_set},
    { "anyflexes", _wrap_Layer_anyflexes_get, _wrap_Layer_anyflexes_set},
    { "splines", _wrap_Layer_splines_get, _wrap_Layer_splines_set},
    { "images", _wrap_Layer_images_get, _wrap_Layer_images_set},
    { "refs", _wrap_Layer_refs_get, _wrap_Layer_refs_set},
    { "undoes", _wrap_Layer_undoes_get, _wrap_Layer_undoes_set},
    { "redoes", _wrap_Layer_redoes_get, _wrap_Layer_redoes_set},
    { "validation_state", _wrap_Layer_validation_state_get, _wrap_Layer_validation_state_set},
    { "old_vs", _wrap_Layer_old_vs_get, _wrap_Layer_old_vs_set},
    {0,0,0}
};
static swig_lua_class *swig_layer_bases[] = {0};
static const char *swig_layer_base_names[] = {0};
static swig_lua_class _wrap_class_layer = { "Layer", &SWIGTYPE_p_layer,_wrap_new_Layer, swig_delete_Layer, swig_layer_methods, swig_layer_attributes, swig_layer_bases, swig_layer_base_names };

static int _wrap_glyphvariants_variants_set(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("glyphvariants::variants",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants::variants",1,"struct glyphvariants *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("glyphvariants::variants",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("glyphvariants_variants_set",1,SWIGTYPE_p_glyphvariants);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->variants);
    if (arg2) {
      arg1->variants = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->variants, (const char *)arg2);
    } else {
      arg1->variants = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_variants_get(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("glyphvariants::variants",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants::variants",1,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("glyphvariants_variants_get",1,SWIGTYPE_p_glyphvariants);
  }
  
  result = (char *) ((arg1)->variants);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_italic_correction_set(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("glyphvariants::italic_correction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants::italic_correction",1,"struct glyphvariants *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("glyphvariants::italic_correction",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("glyphvariants_italic_correction_set",1,SWIGTYPE_p_glyphvariants);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->italic_correction = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_italic_correction_get(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  int16 result;
  
  SWIG_check_num_args("glyphvariants::italic_correction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants::italic_correction",1,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("glyphvariants_italic_correction_get",1,SWIGTYPE_p_glyphvariants);
  }
  
  result = (int16) ((arg1)->italic_correction);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_part_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("glyphvariants::part_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants::part_cnt",1,"struct glyphvariants *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("glyphvariants::part_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("glyphvariants_part_cnt_set",1,SWIGTYPE_p_glyphvariants);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->part_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_part_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  int result;
  
  SWIG_check_num_args("glyphvariants::part_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants::part_cnt",1,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("glyphvariants_part_cnt_get",1,SWIGTYPE_p_glyphvariants);
  }
  
  result = (int) ((arg1)->part_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  glyphvariants_parts *result = 0 ;
  
  SWIG_check_num_args("glyphvariants::parts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants::parts",1,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("glyphvariants_parts_get",1,SWIGTYPE_p_glyphvariants);
  }
  
  result = (glyphvariants_parts *) ((arg1)->parts);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glyphvariants_parts,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_glyphvariants(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *result = 0 ;
  
  SWIG_check_num_args("glyphvariants::glyphvariants",0,0)
  result = (struct glyphvariants *)calloc(1, sizeof(struct glyphvariants));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glyphvariants,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_glyphvariants(void *obj) {
struct glyphvariants *arg1 = (struct glyphvariants *) obj;
free((char *) arg1);
}
static swig_lua_method swig_glyphvariants_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_glyphvariants_attributes[] = {
    { "variants", _wrap_glyphvariants_variants_get, _wrap_glyphvariants_variants_set},
    { "italic_correction", _wrap_glyphvariants_italic_correction_get, _wrap_glyphvariants_italic_correction_set},
    { "part_cnt", _wrap_glyphvariants_part_cnt_get, _wrap_glyphvariants_part_cnt_set},
    { "parts", _wrap_glyphvariants_parts_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_glyphvariants_bases[] = {0};
static const char *swig_glyphvariants_base_names[] = {0};
static swig_lua_class _wrap_class_glyphvariants = { "glyphvariants", &SWIGTYPE_p_glyphvariants,_wrap_new_glyphvariants, swig_delete_glyphvariants, swig_glyphvariants_methods, swig_glyphvariants_attributes, swig_glyphvariants_bases, swig_glyphvariants_base_names };

static int _wrap_glyphvariants_parts_component_set(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("glyphvariants_parts::component",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::component",1,"glyphvariants_parts *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("glyphvariants_parts::component",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_component_set",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->component);
    if (arg2) {
      arg1->component = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->component, (const char *)arg2);
    } else {
      arg1->component = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_component_get(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("glyphvariants_parts::component",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::component",1,"glyphvariants_parts *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_component_get",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  result = (char *) ((arg1)->component);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_is_extender_set(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("glyphvariants_parts::is_extender",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::is_extender",1,"glyphvariants_parts *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("glyphvariants_parts::is_extender",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_is_extender_set",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_extender = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_is_extender_get(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("glyphvariants_parts::is_extender",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::is_extender",1,"glyphvariants_parts *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_is_extender_get",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  result = (unsigned int) ((arg1)->is_extender);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_startConnectorLength_set(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("glyphvariants_parts::startConnectorLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::startConnectorLength",1,"glyphvariants_parts *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("glyphvariants_parts::startConnectorLength",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_startConnectorLength_set",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->startConnectorLength = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_startConnectorLength_get(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("glyphvariants_parts::startConnectorLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::startConnectorLength",1,"glyphvariants_parts *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_startConnectorLength_get",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  result = (uint16) ((arg1)->startConnectorLength);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_endConnectorLength_set(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("glyphvariants_parts::endConnectorLength",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::endConnectorLength",1,"glyphvariants_parts *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("glyphvariants_parts::endConnectorLength",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_endConnectorLength_set",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->endConnectorLength = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_endConnectorLength_get(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("glyphvariants_parts::endConnectorLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::endConnectorLength",1,"glyphvariants_parts *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_endConnectorLength_get",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  result = (uint16) ((arg1)->endConnectorLength);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_fullAdvance_set(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("glyphvariants_parts::fullAdvance",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::fullAdvance",1,"glyphvariants_parts *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("glyphvariants_parts::fullAdvance",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_fullAdvance_set",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->fullAdvance = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_glyphvariants_parts_fullAdvance_get(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *arg1 = (glyphvariants_parts *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("glyphvariants_parts::fullAdvance",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("glyphvariants_parts::fullAdvance",1,"glyphvariants_parts *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants_parts,0))){
    SWIG_fail_ptr("glyphvariants_parts_fullAdvance_get",1,SWIGTYPE_p_glyphvariants_parts);
  }
  
  result = (uint16) ((arg1)->fullAdvance);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_glyphvariants_parts(lua_State* L) {
  int SWIG_arg = 0;
  glyphvariants_parts *result = 0 ;
  
  SWIG_check_num_args("glyphvariants_parts::glyphvariants_parts",0,0)
  result = (glyphvariants_parts *)calloc(1, sizeof(glyphvariants_parts));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glyphvariants_parts,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_glyphvariants_parts(void *obj) {
glyphvariants_parts *arg1 = (glyphvariants_parts *) obj;
free((char *) arg1);
}
static swig_lua_method swig_glyphvariants_parts_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_glyphvariants_parts_attributes[] = {
    { "component", _wrap_glyphvariants_parts_component_get, _wrap_glyphvariants_parts_component_set},
    { "is_extender", _wrap_glyphvariants_parts_is_extender_get, _wrap_glyphvariants_parts_is_extender_set},
    { "startConnectorLength", _wrap_glyphvariants_parts_startConnectorLength_get, _wrap_glyphvariants_parts_startConnectorLength_set},
    { "endConnectorLength", _wrap_glyphvariants_parts_endConnectorLength_get, _wrap_glyphvariants_parts_endConnectorLength_set},
    { "fullAdvance", _wrap_glyphvariants_parts_fullAdvance_get, _wrap_glyphvariants_parts_fullAdvance_set},
    {0,0,0}
};
static swig_lua_class *swig_glyphvariants_parts_bases[] = {0};
static const char *swig_glyphvariants_parts_base_names[] = {0};
static swig_lua_class _wrap_class_glyphvariants_parts = { "glyphvariants_parts", &SWIGTYPE_p_glyphvariants_parts,_wrap_new_glyphvariants_parts, swig_delete_glyphvariants_parts, swig_glyphvariants_parts_methods, swig_glyphvariants_parts_attributes, swig_glyphvariants_parts_bases, swig_glyphvariants_parts_base_names };

static int _wrap_mathkernvertex_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkernvertex *arg1 = (struct mathkernvertex *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("mathkernvertex::cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkernvertex::cnt",1,"struct mathkernvertex *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mathkernvertex::cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("mathkernvertex_cnt_set",1,SWIGTYPE_p_mathkernvertex);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkernvertex_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkernvertex *arg1 = (struct mathkernvertex *) 0 ;
  int result;
  
  SWIG_check_num_args("mathkernvertex::cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkernvertex::cnt",1,"struct mathkernvertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("mathkernvertex_cnt_get",1,SWIGTYPE_p_mathkernvertex);
  }
  
  result = (int) ((arg1)->cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkernvertex_mkd_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkernvertex *arg1 = (struct mathkernvertex *) 0 ;
  mathkernvertex_mkd *result = 0 ;
  
  SWIG_check_num_args("mathkernvertex::mkd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkernvertex::mkd",1,"struct mathkernvertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("mathkernvertex_mkd_get",1,SWIGTYPE_p_mathkernvertex);
  }
  
  result = (mathkernvertex_mkd *) ((arg1)->mkd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkernvertex_mkd,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_mathkernvertex(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkernvertex *result = 0 ;
  
  SWIG_check_num_args("mathkernvertex::mathkernvertex",0,0)
  result = (struct mathkernvertex *)calloc(1, sizeof(struct mathkernvertex));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkernvertex,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mathkernvertex(void *obj) {
struct mathkernvertex *arg1 = (struct mathkernvertex *) obj;
free((char *) arg1);
}
static swig_lua_method swig_mathkernvertex_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_mathkernvertex_attributes[] = {
    { "cnt", _wrap_mathkernvertex_cnt_get, _wrap_mathkernvertex_cnt_set},
    { "mkd", _wrap_mathkernvertex_mkd_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_mathkernvertex_bases[] = {0};
static const char *swig_mathkernvertex_base_names[] = {0};
static swig_lua_class _wrap_class_mathkernvertex = { "mathkernvertex", &SWIGTYPE_p_mathkernvertex,_wrap_new_mathkernvertex, swig_delete_mathkernvertex, swig_mathkernvertex_methods, swig_mathkernvertex_attributes, swig_mathkernvertex_bases, swig_mathkernvertex_base_names };

static int _wrap_mathkernvertex_mkd_height_set(lua_State* L) {
  int SWIG_arg = 0;
  mathkernvertex_mkd *arg1 = (mathkernvertex_mkd *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("mathkernvertex_mkd::height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkernvertex_mkd::height",1,"mathkernvertex_mkd *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mathkernvertex_mkd::height",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex_mkd,0))){
    SWIG_fail_ptr("mathkernvertex_mkd_height_set",1,SWIGTYPE_p_mathkernvertex_mkd);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkernvertex_mkd_height_get(lua_State* L) {
  int SWIG_arg = 0;
  mathkernvertex_mkd *arg1 = (mathkernvertex_mkd *) 0 ;
  int16 result;
  
  SWIG_check_num_args("mathkernvertex_mkd::height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkernvertex_mkd::height",1,"mathkernvertex_mkd *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex_mkd,0))){
    SWIG_fail_ptr("mathkernvertex_mkd_height_get",1,SWIGTYPE_p_mathkernvertex_mkd);
  }
  
  result = (int16) ((arg1)->height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkernvertex_mkd_kern_set(lua_State* L) {
  int SWIG_arg = 0;
  mathkernvertex_mkd *arg1 = (mathkernvertex_mkd *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("mathkernvertex_mkd::kern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkernvertex_mkd::kern",1,"mathkernvertex_mkd *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mathkernvertex_mkd::kern",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex_mkd,0))){
    SWIG_fail_ptr("mathkernvertex_mkd_kern_set",1,SWIGTYPE_p_mathkernvertex_mkd);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->kern = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkernvertex_mkd_kern_get(lua_State* L) {
  int SWIG_arg = 0;
  mathkernvertex_mkd *arg1 = (mathkernvertex_mkd *) 0 ;
  int16 result;
  
  SWIG_check_num_args("mathkernvertex_mkd::kern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkernvertex_mkd::kern",1,"mathkernvertex_mkd *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex_mkd,0))){
    SWIG_fail_ptr("mathkernvertex_mkd_kern_get",1,SWIGTYPE_p_mathkernvertex_mkd);
  }
  
  result = (int16) ((arg1)->kern);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_mathkernvertex_mkd(lua_State* L) {
  int SWIG_arg = 0;
  mathkernvertex_mkd *result = 0 ;
  
  SWIG_check_num_args("mathkernvertex_mkd::mathkernvertex_mkd",0,0)
  result = (mathkernvertex_mkd *)calloc(1, sizeof(mathkernvertex_mkd));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkernvertex_mkd,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mathkernvertex_mkd(void *obj) {
mathkernvertex_mkd *arg1 = (mathkernvertex_mkd *) obj;
free((char *) arg1);
}
static swig_lua_method swig_mathkernvertex_mkd_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_mathkernvertex_mkd_attributes[] = {
    { "height", _wrap_mathkernvertex_mkd_height_get, _wrap_mathkernvertex_mkd_height_set},
    { "kern", _wrap_mathkernvertex_mkd_kern_get, _wrap_mathkernvertex_mkd_kern_set},
    {0,0,0}
};
static swig_lua_class *swig_mathkernvertex_mkd_bases[] = {0};
static const char *swig_mathkernvertex_mkd_base_names[] = {0};
static swig_lua_class _wrap_class_mathkernvertex_mkd = { "mathkernvertex_mkd", &SWIGTYPE_p_mathkernvertex_mkd,_wrap_new_mathkernvertex_mkd, swig_delete_mathkernvertex_mkd, swig_mathkernvertex_mkd_methods, swig_mathkernvertex_mkd_attributes, swig_mathkernvertex_mkd_bases, swig_mathkernvertex_mkd_base_names };

static int _wrap_mathkern_top_right_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *arg2 = (struct mathkernvertex *) 0 ;
  
  SWIG_check_num_args("mathkern::top_right",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::top_right",1,"struct mathkern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mathkern::top_right",2,"struct mathkernvertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_top_right_set",1,SWIGTYPE_p_mathkern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("mathkern_top_right_set",2,SWIGTYPE_p_mathkernvertex);
  }
  
  if (arg1) (arg1)->top_right = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkern_top_right_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *result = 0 ;
  
  SWIG_check_num_args("mathkern::top_right",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::top_right",1,"struct mathkern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_top_right_get",1,SWIGTYPE_p_mathkern);
  }
  
  result = (struct mathkernvertex *)& ((arg1)->top_right);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkernvertex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkern_top_left_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *arg2 = (struct mathkernvertex *) 0 ;
  
  SWIG_check_num_args("mathkern::top_left",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::top_left",1,"struct mathkern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mathkern::top_left",2,"struct mathkernvertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_top_left_set",1,SWIGTYPE_p_mathkern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("mathkern_top_left_set",2,SWIGTYPE_p_mathkernvertex);
  }
  
  if (arg1) (arg1)->top_left = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkern_top_left_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *result = 0 ;
  
  SWIG_check_num_args("mathkern::top_left",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::top_left",1,"struct mathkern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_top_left_get",1,SWIGTYPE_p_mathkern);
  }
  
  result = (struct mathkernvertex *)& ((arg1)->top_left);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkernvertex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkern_bottom_right_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *arg2 = (struct mathkernvertex *) 0 ;
  
  SWIG_check_num_args("mathkern::bottom_right",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::bottom_right",1,"struct mathkern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mathkern::bottom_right",2,"struct mathkernvertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_bottom_right_set",1,SWIGTYPE_p_mathkern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("mathkern_bottom_right_set",2,SWIGTYPE_p_mathkernvertex);
  }
  
  if (arg1) (arg1)->bottom_right = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkern_bottom_right_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *result = 0 ;
  
  SWIG_check_num_args("mathkern::bottom_right",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::bottom_right",1,"struct mathkern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_bottom_right_get",1,SWIGTYPE_p_mathkern);
  }
  
  result = (struct mathkernvertex *)& ((arg1)->bottom_right);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkernvertex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkern_bottom_left_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *arg2 = (struct mathkernvertex *) 0 ;
  
  SWIG_check_num_args("mathkern::bottom_left",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::bottom_left",1,"struct mathkern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mathkern::bottom_left",2,"struct mathkernvertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_bottom_left_set",1,SWIGTYPE_p_mathkern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("mathkern_bottom_left_set",2,SWIGTYPE_p_mathkernvertex);
  }
  
  if (arg1) (arg1)->bottom_left = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mathkern_bottom_left_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkernvertex *result = 0 ;
  
  SWIG_check_num_args("mathkern::bottom_left",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mathkern::bottom_left",1,"struct mathkern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("mathkern_bottom_left_get",1,SWIGTYPE_p_mathkern);
  }
  
  result = (struct mathkernvertex *)& ((arg1)->bottom_left);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkernvertex,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_mathkern(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *result = 0 ;
  
  SWIG_check_num_args("mathkern::mathkern",0,0)
  result = (struct mathkern *)calloc(1, sizeof(struct mathkern));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkern,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_mathkern(void *obj) {
struct mathkern *arg1 = (struct mathkern *) obj;
free((char *) arg1);
}
static swig_lua_method swig_mathkern_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_mathkern_attributes[] = {
    { "top_right", _wrap_mathkern_top_right_get, _wrap_mathkern_top_right_set},
    { "top_left", _wrap_mathkern_top_left_get, _wrap_mathkern_top_left_set},
    { "bottom_right", _wrap_mathkern_bottom_right_get, _wrap_mathkern_bottom_right_set},
    { "bottom_left", _wrap_mathkern_bottom_left_get, _wrap_mathkern_bottom_left_set},
    {0,0,0}
};
static swig_lua_class *swig_mathkern_bases[] = {0};
static const char *swig_mathkern_base_names[] = {0};
static swig_lua_class _wrap_class_mathkern = { "mathkern", &SWIGTYPE_p_mathkern,_wrap_new_mathkern, swig_delete_mathkern, swig_mathkern_methods, swig_mathkern_attributes, swig_mathkern_bases, swig_mathkern_base_names };

static int _wrap_SplineChar_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinechar::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::name",1,"struct splinechar *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinechar::name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_name_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->name);
    if (arg2) {
      arg1->name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinechar::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::name",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_name_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_unicodeenc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinechar::unicodeenc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::unicodeenc",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::unicodeenc",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_unicodeenc_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unicodeenc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_unicodeenc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int result;
  
  SWIG_check_num_args("splinechar::unicodeenc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::unicodeenc",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_unicodeenc_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int) ((arg1)->unicodeenc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_orig_pos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinechar::orig_pos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::orig_pos",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::orig_pos",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_orig_pos_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->orig_pos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_orig_pos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int result;
  
  SWIG_check_num_args("splinechar::orig_pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::orig_pos",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_orig_pos_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int) ((arg1)->orig_pos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::width",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::width",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_width_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::width",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_width_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vwidth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::vwidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vwidth",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::vwidth",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vwidth_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->vwidth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vwidth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::vwidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vwidth",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vwidth_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->vwidth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_lsidebearing_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::lsidebearing",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::lsidebearing",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::lsidebearing",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_lsidebearing_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->lsidebearing = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_lsidebearing_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::lsidebearing",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::lsidebearing",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_lsidebearing_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->lsidebearing);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ttf_glyph_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinechar::ttf_glyph",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ttf_glyph",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::ttf_glyph",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ttf_glyph_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ttf_glyph = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ttf_glyph_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int result;
  
  SWIG_check_num_args("splinechar::ttf_glyph",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ttf_glyph",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ttf_glyph_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int) ((arg1)->ttf_glyph);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_layers_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  Layer *arg2 = (Layer *) 0 ;
  
  SWIG_check_num_args("splinechar::layers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::layers",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::layers",2,"Layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_layers_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_layer,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_layers_set",2,SWIGTYPE_p_layer);
  }
  
  if (arg1) (arg1)->layers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_layers_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  Layer *result = 0 ;
  
  SWIG_check_num_args("splinechar::layers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::layers",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_layers_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (Layer *) ((arg1)->layers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_layer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_layer_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinechar::layer_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::layer_cnt",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::layer_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_layer_cnt_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->layer_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_layer_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int result;
  
  SWIG_check_num_args("splinechar::layer_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::layer_cnt",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_layer_cnt_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int) ((arg1)->layer_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_hstem_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  StemInfo *arg2 = (StemInfo *) 0 ;
  
  SWIG_check_num_args("splinechar::hstem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::hstem",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::hstem",2,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_hstem_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_steminfo,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_hstem_set",2,SWIGTYPE_p_steminfo);
  }
  
  if (arg1) (arg1)->hstem = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_hstem_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  StemInfo *result = 0 ;
  
  SWIG_check_num_args("splinechar::hstem",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::hstem",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_hstem_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (StemInfo *) ((arg1)->hstem);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_steminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vstem_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  StemInfo *arg2 = (StemInfo *) 0 ;
  
  SWIG_check_num_args("splinechar::vstem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vstem",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::vstem",2,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vstem_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_steminfo,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_vstem_set",2,SWIGTYPE_p_steminfo);
  }
  
  if (arg1) (arg1)->vstem = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vstem_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  StemInfo *result = 0 ;
  
  SWIG_check_num_args("splinechar::vstem",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vstem",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vstem_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (StemInfo *) ((arg1)->vstem);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_steminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_dstem_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  DStemInfo *arg2 = (DStemInfo *) 0 ;
  
  SWIG_check_num_args("splinechar::dstem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::dstem",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::dstem",2,"DStemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_dstem_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dsteminfo,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_dstem_set",2,SWIGTYPE_p_dsteminfo);
  }
  
  if (arg1) (arg1)->dstem = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_dstem_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  DStemInfo *result = 0 ;
  
  SWIG_check_num_args("splinechar::dstem",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::dstem",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_dstem_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (DStemInfo *) ((arg1)->dstem);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dsteminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_md_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  MinimumDistance *arg2 = (MinimumDistance *) 0 ;
  
  SWIG_check_num_args("splinechar::md",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::md",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::md",2,"MinimumDistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_md_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_minimumdistance,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_md_set",2,SWIGTYPE_p_minimumdistance);
  }
  
  if (arg1) (arg1)->md = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_md_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  MinimumDistance *result = 0 ;
  
  SWIG_check_num_args("splinechar::md",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::md",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_md_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (MinimumDistance *) ((arg1)->md);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_minimumdistance,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_views_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct charviewbase *arg2 = (struct charviewbase *) 0 ;
  
  SWIG_check_num_args("splinechar::views",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::views",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::views",2,"struct charviewbase *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_views_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_charviewbase,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_views_set",2,SWIGTYPE_p_charviewbase);
  }
  
  if (arg1) (arg1)->views = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_views_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct charviewbase *result = 0 ;
  
  SWIG_check_num_args("splinechar::views",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::views",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_views_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (struct charviewbase *) ((arg1)->views);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_charviewbase,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_charinfo_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct charinfo *arg2 = (struct charinfo *) 0 ;
  
  SWIG_check_num_args("splinechar::charinfo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::charinfo",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::charinfo",2,"struct charinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_charinfo_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_charinfo,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_charinfo_set",2,SWIGTYPE_p_charinfo);
  }
  
  if (arg1) (arg1)->charinfo = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_charinfo_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct charinfo *result = 0 ;
  
  SWIG_check_num_args("splinechar::charinfo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::charinfo",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_charinfo_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (struct charinfo *) ((arg1)->charinfo);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_charinfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_parent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct splinefont *arg2 = (struct splinefont *) 0 ;
  
  SWIG_check_num_args("splinechar::parent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::parent",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::parent",2,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_parent_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_parent_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->parent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_parent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct splinefont *result = 0 ;
  
  SWIG_check_num_args("splinechar::parent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::parent",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_parent_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (struct splinefont *) ((arg1)->parent);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changed_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::changed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changed",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::changed",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changed_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changed_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::changed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changed",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changed_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->changed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changedsincelasthinted_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::changedsincelasthinted",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changedsincelasthinted",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::changedsincelasthinted",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changedsincelasthinted_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changedsincelasthinted = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changedsincelasthinted_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::changedsincelasthinted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changedsincelasthinted",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changedsincelasthinted_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->changedsincelasthinted);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_manualhints_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::manualhints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::manualhints",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::manualhints",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_manualhints_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->manualhints = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_manualhints_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::manualhints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::manualhints",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_manualhints_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->manualhints);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ticked",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ticked_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ticked",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ticked_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changed_since_autosave_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::changed_since_autosave",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changed_since_autosave",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::changed_since_autosave",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changed_since_autosave_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed_since_autosave = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changed_since_autosave_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::changed_since_autosave",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changed_since_autosave",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changed_since_autosave_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->changed_since_autosave);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_widthset_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::widthset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::widthset",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::widthset",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_widthset_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->widthset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_widthset_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::widthset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::widthset",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_widthset_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->widthset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vconflicts_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::vconflicts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vconflicts",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::vconflicts",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vconflicts_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->vconflicts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vconflicts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::vconflicts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vconflicts",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vconflicts_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->vconflicts);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_hconflicts_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::hconflicts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::hconflicts",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::hconflicts",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_hconflicts_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hconflicts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_hconflicts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::hconflicts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::hconflicts",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_hconflicts_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->hconflicts);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_searcherdummy_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::searcherdummy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::searcherdummy",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::searcherdummy",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_searcherdummy_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->searcherdummy = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_searcherdummy_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::searcherdummy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::searcherdummy",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_searcherdummy_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->searcherdummy);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changed_since_search_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::changed_since_search",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changed_since_search",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::changed_since_search",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changed_since_search_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed_since_search = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_changed_since_search_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::changed_since_search",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::changed_since_search",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_changed_since_search_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->changed_since_search);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_wasopen_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::wasopen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::wasopen",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::wasopen",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_wasopen_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->wasopen = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_wasopen_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::wasopen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::wasopen",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_wasopen_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->wasopen);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_namechanged_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::namechanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::namechanged",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::namechanged",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_namechanged_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->namechanged = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_namechanged_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::namechanged",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::namechanged",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_namechanged_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->namechanged);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_blended_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::blended",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::blended",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::blended",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_blended_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->blended = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_blended_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::blended",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::blended",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_blended_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->blended);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ticked2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::ticked2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ticked2",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::ticked2",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ticked2_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ticked2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::ticked2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ticked2",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ticked2_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->ticked2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_glyph_class_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::glyph_class",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::glyph_class",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::glyph_class",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_glyph_class_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->glyph_class = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_glyph_class_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::glyph_class",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::glyph_class",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_glyph_class_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->glyph_class);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_numberpointsbackards_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::numberpointsbackards",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::numberpointsbackards",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::numberpointsbackards",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_numberpointsbackards_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->numberpointsbackards = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_numberpointsbackards_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::numberpointsbackards",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::numberpointsbackards",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_numberpointsbackards_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->numberpointsbackards);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_instructions_out_of_date_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::instructions_out_of_date",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::instructions_out_of_date",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::instructions_out_of_date",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_instructions_out_of_date_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->instructions_out_of_date = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_instructions_out_of_date_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::instructions_out_of_date",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::instructions_out_of_date",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_instructions_out_of_date_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->instructions_out_of_date);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_complained_about_ptnums_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::complained_about_ptnums",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::complained_about_ptnums",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::complained_about_ptnums",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_complained_about_ptnums_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->complained_about_ptnums = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_complained_about_ptnums_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::complained_about_ptnums",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::complained_about_ptnums",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_complained_about_ptnums_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->complained_about_ptnums);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vs_open_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::vs_open",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vs_open",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::vs_open",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vs_open_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->vs_open = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vs_open_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::vs_open",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vs_open",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vs_open_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->vs_open);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_unlink_rm_ovrlp_save_undo_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::unlink_rm_ovrlp_save_undo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::unlink_rm_ovrlp_save_undo",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::unlink_rm_ovrlp_save_undo",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_unlink_rm_ovrlp_save_undo_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unlink_rm_ovrlp_save_undo = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_unlink_rm_ovrlp_save_undo_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::unlink_rm_ovrlp_save_undo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::unlink_rm_ovrlp_save_undo",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_unlink_rm_ovrlp_save_undo_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->unlink_rm_ovrlp_save_undo);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_inspiro_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::inspiro",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::inspiro",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::inspiro",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_inspiro_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->inspiro = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_inspiro_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::inspiro",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::inspiro",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_inspiro_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->inspiro);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_lig_caret_cnt_fixed_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::lig_caret_cnt_fixed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::lig_caret_cnt_fixed",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::lig_caret_cnt_fixed",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_lig_caret_cnt_fixed_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lig_caret_cnt_fixed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_lig_caret_cnt_fixed_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::lig_caret_cnt_fixed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::lig_caret_cnt_fixed",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_lig_caret_cnt_fixed_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->lig_caret_cnt_fixed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_kerns_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  KernPair *arg2 = (KernPair *) 0 ;
  
  SWIG_check_num_args("splinechar::kerns",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::kerns",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::kerns",2,"KernPair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_kerns_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernpair,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_kerns_set",2,SWIGTYPE_p_kernpair);
  }
  
  if (arg1) (arg1)->kerns = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_kerns_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  KernPair *result = 0 ;
  
  SWIG_check_num_args("splinechar::kerns",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::kerns",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_kerns_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (KernPair *) ((arg1)->kerns);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernpair,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vkerns_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  KernPair *arg2 = (KernPair *) 0 ;
  
  SWIG_check_num_args("splinechar::vkerns",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vkerns",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::vkerns",2,"KernPair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vkerns_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernpair,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_vkerns_set",2,SWIGTYPE_p_kernpair);
  }
  
  if (arg1) (arg1)->vkerns = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vkerns_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  KernPair *result = 0 ;
  
  SWIG_check_num_args("splinechar::vkerns",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vkerns",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vkerns_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (KernPair *) ((arg1)->vkerns);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernpair,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_possub_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  PST *arg2 = (PST *) 0 ;
  
  SWIG_check_num_args("splinechar::possub",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::possub",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::possub",2,"PST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_possub_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_pst,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_possub_set",2,SWIGTYPE_p_generic_pst);
  }
  
  if (arg1) (arg1)->possub = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_possub_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  PST *result = 0 ;
  
  SWIG_check_num_args("splinechar::possub",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::possub",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_possub_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (PST *) ((arg1)->possub);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_pst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ligofme_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  LigList *arg2 = (LigList *) 0 ;
  
  SWIG_check_num_args("splinechar::ligofme",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ligofme",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::ligofme",2,"LigList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ligofme_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_liglist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_ligofme_set",2,SWIGTYPE_p_liglist);
  }
  
  if (arg1) (arg1)->ligofme = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ligofme_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  LigList *result = 0 ;
  
  SWIG_check_num_args("splinechar::ligofme",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ligofme",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ligofme_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (LigList *) ((arg1)->ligofme);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_liglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_comment_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinechar::comment",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::comment",1,"struct splinechar *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinechar::comment",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_comment_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->comment);
    if (arg2) {
      arg1->comment = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->comment, (const char *)arg2);
    } else {
      arg1->comment = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_comment_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinechar::comment",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::comment",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_comment_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (char *) ((arg1)->comment);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_color_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("splinechar::color",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::color",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::color",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_color_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->color = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_color_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("splinechar::color",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::color",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_color_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (uint32) ((arg1)->color);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_anchor_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  AnchorPoint *arg2 = (AnchorPoint *) 0 ;
  
  SWIG_check_num_args("splinechar::anchor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::anchor",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::anchor",2,"AnchorPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_anchor_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorpoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_anchor_set",2,SWIGTYPE_p_anchorpoint);
  }
  
  if (arg1) (arg1)->anchor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_anchor_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  AnchorPoint *result = 0 ;
  
  SWIG_check_num_args("splinechar::anchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::anchor",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_anchor_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (AnchorPoint *) ((arg1)->anchor);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ttf_instrs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("splinechar::ttf_instrs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ttf_instrs",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::ttf_instrs",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ttf_instrs_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_ttf_instrs_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->ttf_instrs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ttf_instrs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("splinechar::ttf_instrs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ttf_instrs",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ttf_instrs_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (uint8 *) ((arg1)->ttf_instrs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ttf_instrs_len_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::ttf_instrs_len",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ttf_instrs_len",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::ttf_instrs_len",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ttf_instrs_len_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ttf_instrs_len = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_ttf_instrs_len_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::ttf_instrs_len",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::ttf_instrs_len",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_ttf_instrs_len_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->ttf_instrs_len);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_countermask_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::countermask_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::countermask_cnt",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::countermask_cnt",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_countermask_cnt_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->countermask_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_countermask_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::countermask_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::countermask_cnt",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_countermask_cnt_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->countermask_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_countermasks_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  HintMask *arg2 = (HintMask *) 0 ;
  
  SWIG_check_num_args("splinechar::countermasks",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::countermasks",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::countermasks",2,"HintMask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_countermasks_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_a_96_8__unsigned_char,0))){
    SWIG_fail_ptr("SplineChar_countermasks_set",2,SWIGTYPE_p_a_96_8__unsigned_char);
  }
  
  if (arg1) (arg1)->countermasks = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_countermasks_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  HintMask *result = 0 ;
  
  SWIG_check_num_args("splinechar::countermasks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::countermasks",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_countermasks_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (HintMask *) ((arg1)->countermasks);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_a_96_8__unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_tex_height_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::tex_height",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::tex_height",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::tex_height",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_tex_height_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->tex_height = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_tex_height_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::tex_height",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::tex_height",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_tex_height_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->tex_height);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_tex_depth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::tex_depth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::tex_depth",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::tex_depth",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_tex_depth_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->tex_depth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_tex_depth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::tex_depth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::tex_depth",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_tex_depth_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->tex_depth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_is_extended_shape_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinechar::is_extended_shape",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::is_extended_shape",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::is_extended_shape",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_is_extended_shape_set",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_extended_shape = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_is_extended_shape_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinechar::is_extended_shape",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::is_extended_shape",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_is_extended_shape_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (unsigned int) ((arg1)->is_extended_shape);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_italic_correction_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::italic_correction",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::italic_correction",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::italic_correction",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_italic_correction_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->italic_correction = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_italic_correction_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::italic_correction",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::italic_correction",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_italic_correction_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->italic_correction);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_top_accent_horiz_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinechar::top_accent_horiz",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::top_accent_horiz",1,"struct splinechar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinechar::top_accent_horiz",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_top_accent_horiz_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->top_accent_horiz = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_top_accent_horiz_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinechar::top_accent_horiz",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::top_accent_horiz",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_top_accent_horiz_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int16) ((arg1)->top_accent_horiz);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vert_variants_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct glyphvariants *arg2 = (struct glyphvariants *) 0 ;
  
  SWIG_check_num_args("splinechar::vert_variants",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vert_variants",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::vert_variants",2,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vert_variants_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glyphvariants,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_vert_variants_set",2,SWIGTYPE_p_glyphvariants);
  }
  
  if (arg1) (arg1)->vert_variants = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_vert_variants_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct glyphvariants *result = 0 ;
  
  SWIG_check_num_args("splinechar::vert_variants",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::vert_variants",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_vert_variants_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (struct glyphvariants *) ((arg1)->vert_variants);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glyphvariants,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_horiz_variants_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct glyphvariants *arg2 = (struct glyphvariants *) 0 ;
  
  SWIG_check_num_args("splinechar::horiz_variants",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::horiz_variants",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::horiz_variants",2,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_horiz_variants_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glyphvariants,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_horiz_variants_set",2,SWIGTYPE_p_glyphvariants);
  }
  
  if (arg1) (arg1)->horiz_variants = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_horiz_variants_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct glyphvariants *result = 0 ;
  
  SWIG_check_num_args("splinechar::horiz_variants",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::horiz_variants",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_horiz_variants_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (struct glyphvariants *) ((arg1)->horiz_variants);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glyphvariants,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_mathkern_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct mathkern *arg2 = (struct mathkern *) 0 ;
  
  SWIG_check_num_args("splinechar::mathkern",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::mathkern",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::mathkern",2,"struct mathkern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_mathkern_set",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_mathkern,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_mathkern_set",2,SWIGTYPE_p_mathkern);
  }
  
  if (arg1) (arg1)->mathkern = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_mathkern_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  struct mathkern *result = 0 ;
  
  SWIG_check_num_args("splinechar::mathkern",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::mathkern",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_mathkern_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (struct mathkern *) ((arg1)->mathkern);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkern,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_python_sc_object_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("splinechar::python_sc_object",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::python_sc_object",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::python_sc_object",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_python_sc_object_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"SplineChar_python_sc_object_set");
  if (arg1) (arg1)->python_sc_object = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_python_sc_object_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("splinechar::python_sc_object",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::python_sc_object",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_python_sc_object_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (void *) ((arg1)->python_sc_object);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_python_temporary_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("splinechar::python_temporary",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::python_temporary",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::python_temporary",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_python_temporary_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"SplineChar_python_temporary_set");
  if (arg1) (arg1)->python_temporary = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_python_temporary_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("splinechar::python_temporary",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::python_temporary",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_python_temporary_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (void *) ((arg1)->python_temporary);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_python_persistent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("splinechar::python_persistent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::python_persistent",1,"struct splinechar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinechar::python_persistent",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_python_persistent_set",1,SWIGTYPE_p_splinechar);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"SplineChar_python_persistent_set");
  if (arg1) (arg1)->python_persistent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_python_persistent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("splinechar::python_persistent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::python_persistent",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_python_persistent_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (void *) ((arg1)->python_persistent);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_dependents_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  SplineChar_dependents *result = 0 ;
  
  SWIG_check_num_args("splinechar::dependents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::dependents",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_dependents_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (SplineChar_dependents *) ((arg1)->dependents);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineChar_dependents,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *arg1 = (struct splinechar *) 0 ;
  SplineChar_altuni *result = 0 ;
  
  SWIG_check_num_args("splinechar::altuni",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinechar::altuni",1,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineChar_altuni_get",1,SWIGTYPE_p_splinechar);
  }
  
  result = (SplineChar_altuni *) ((arg1)->altuni);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineChar_altuni,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineChar(lua_State* L) {
  int SWIG_arg = 0;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("splinechar::splinechar",0,0)
  result = (struct splinechar *)calloc(1, sizeof(struct splinechar));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineChar(void *obj) {
struct splinechar *arg1 = (struct splinechar *) obj;
free((char *) arg1);
}
static swig_lua_method swig_splinechar_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_splinechar_attributes[] = {
    { "name", _wrap_SplineChar_name_get, _wrap_SplineChar_name_set},
    { "unicodeenc", _wrap_SplineChar_unicodeenc_get, _wrap_SplineChar_unicodeenc_set},
    { "orig_pos", _wrap_SplineChar_orig_pos_get, _wrap_SplineChar_orig_pos_set},
    { "width", _wrap_SplineChar_width_get, _wrap_SplineChar_width_set},
    { "vwidth", _wrap_SplineChar_vwidth_get, _wrap_SplineChar_vwidth_set},
    { "lsidebearing", _wrap_SplineChar_lsidebearing_get, _wrap_SplineChar_lsidebearing_set},
    { "ttf_glyph", _wrap_SplineChar_ttf_glyph_get, _wrap_SplineChar_ttf_glyph_set},
    { "layers", _wrap_SplineChar_layers_get, _wrap_SplineChar_layers_set},
    { "layer_cnt", _wrap_SplineChar_layer_cnt_get, _wrap_SplineChar_layer_cnt_set},
    { "hstem", _wrap_SplineChar_hstem_get, _wrap_SplineChar_hstem_set},
    { "vstem", _wrap_SplineChar_vstem_get, _wrap_SplineChar_vstem_set},
    { "dstem", _wrap_SplineChar_dstem_get, _wrap_SplineChar_dstem_set},
    { "md", _wrap_SplineChar_md_get, _wrap_SplineChar_md_set},
    { "views", _wrap_SplineChar_views_get, _wrap_SplineChar_views_set},
    { "charinfo", _wrap_SplineChar_charinfo_get, _wrap_SplineChar_charinfo_set},
    { "parent", _wrap_SplineChar_parent_get, _wrap_SplineChar_parent_set},
    { "changed", _wrap_SplineChar_changed_get, _wrap_SplineChar_changed_set},
    { "changedsincelasthinted", _wrap_SplineChar_changedsincelasthinted_get, _wrap_SplineChar_changedsincelasthinted_set},
    { "manualhints", _wrap_SplineChar_manualhints_get, _wrap_SplineChar_manualhints_set},
    { "ticked", _wrap_SplineChar_ticked_get, _wrap_SplineChar_ticked_set},
    { "changed_since_autosave", _wrap_SplineChar_changed_since_autosave_get, _wrap_SplineChar_changed_since_autosave_set},
    { "widthset", _wrap_SplineChar_widthset_get, _wrap_SplineChar_widthset_set},
    { "vconflicts", _wrap_SplineChar_vconflicts_get, _wrap_SplineChar_vconflicts_set},
    { "hconflicts", _wrap_SplineChar_hconflicts_get, _wrap_SplineChar_hconflicts_set},
    { "searcherdummy", _wrap_SplineChar_searcherdummy_get, _wrap_SplineChar_searcherdummy_set},
    { "changed_since_search", _wrap_SplineChar_changed_since_search_get, _wrap_SplineChar_changed_since_search_set},
    { "wasopen", _wrap_SplineChar_wasopen_get, _wrap_SplineChar_wasopen_set},
    { "namechanged", _wrap_SplineChar_namechanged_get, _wrap_SplineChar_namechanged_set},
    { "blended", _wrap_SplineChar_blended_get, _wrap_SplineChar_blended_set},
    { "ticked2", _wrap_SplineChar_ticked2_get, _wrap_SplineChar_ticked2_set},
    { "glyph_class", _wrap_SplineChar_glyph_class_get, _wrap_SplineChar_glyph_class_set},
    { "numberpointsbackards", _wrap_SplineChar_numberpointsbackards_get, _wrap_SplineChar_numberpointsbackards_set},
    { "instructions_out_of_date", _wrap_SplineChar_instructions_out_of_date_get, _wrap_SplineChar_instructions_out_of_date_set},
    { "complained_about_ptnums", _wrap_SplineChar_complained_about_ptnums_get, _wrap_SplineChar_complained_about_ptnums_set},
    { "vs_open", _wrap_SplineChar_vs_open_get, _wrap_SplineChar_vs_open_set},
    { "unlink_rm_ovrlp_save_undo", _wrap_SplineChar_unlink_rm_ovrlp_save_undo_get, _wrap_SplineChar_unlink_rm_ovrlp_save_undo_set},
    { "inspiro", _wrap_SplineChar_inspiro_get, _wrap_SplineChar_inspiro_set},
    { "lig_caret_cnt_fixed", _wrap_SplineChar_lig_caret_cnt_fixed_get, _wrap_SplineChar_lig_caret_cnt_fixed_set},
    { "kerns", _wrap_SplineChar_kerns_get, _wrap_SplineChar_kerns_set},
    { "vkerns", _wrap_SplineChar_vkerns_get, _wrap_SplineChar_vkerns_set},
    { "possub", _wrap_SplineChar_possub_get, _wrap_SplineChar_possub_set},
    { "ligofme", _wrap_SplineChar_ligofme_get, _wrap_SplineChar_ligofme_set},
    { "comment", _wrap_SplineChar_comment_get, _wrap_SplineChar_comment_set},
    { "color", _wrap_SplineChar_color_get, _wrap_SplineChar_color_set},
    { "anchor", _wrap_SplineChar_anchor_get, _wrap_SplineChar_anchor_set},
    { "ttf_instrs", _wrap_SplineChar_ttf_instrs_get, _wrap_SplineChar_ttf_instrs_set},
    { "ttf_instrs_len", _wrap_SplineChar_ttf_instrs_len_get, _wrap_SplineChar_ttf_instrs_len_set},
    { "countermask_cnt", _wrap_SplineChar_countermask_cnt_get, _wrap_SplineChar_countermask_cnt_set},
    { "countermasks", _wrap_SplineChar_countermasks_get, _wrap_SplineChar_countermasks_set},
    { "tex_height", _wrap_SplineChar_tex_height_get, _wrap_SplineChar_tex_height_set},
    { "tex_depth", _wrap_SplineChar_tex_depth_get, _wrap_SplineChar_tex_depth_set},
    { "is_extended_shape", _wrap_SplineChar_is_extended_shape_get, _wrap_SplineChar_is_extended_shape_set},
    { "italic_correction", _wrap_SplineChar_italic_correction_get, _wrap_SplineChar_italic_correction_set},
    { "top_accent_horiz", _wrap_SplineChar_top_accent_horiz_get, _wrap_SplineChar_top_accent_horiz_set},
    { "vert_variants", _wrap_SplineChar_vert_variants_get, _wrap_SplineChar_vert_variants_set},
    { "horiz_variants", _wrap_SplineChar_horiz_variants_get, _wrap_SplineChar_horiz_variants_set},
    { "mathkern", _wrap_SplineChar_mathkern_get, _wrap_SplineChar_mathkern_set},
    { "python_sc_object", _wrap_SplineChar_python_sc_object_get, _wrap_SplineChar_python_sc_object_set},
    { "python_temporary", _wrap_SplineChar_python_temporary_get, _wrap_SplineChar_python_temporary_set},
    { "python_persistent", _wrap_SplineChar_python_persistent_get, _wrap_SplineChar_python_persistent_set},
    { "dependents", _wrap_SplineChar_dependents_get, SWIG_Lua_set_immutable},
    { "altuni", _wrap_SplineChar_altuni_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_splinechar_bases[] = {0};
static const char *swig_splinechar_base_names[] = {0};
static swig_lua_class _wrap_class_splinechar = { "SplineChar", &SWIGTYPE_p_splinechar,_wrap_new_SplineChar, swig_delete_SplineChar, swig_splinechar_methods, swig_splinechar_attributes, swig_splinechar_bases, swig_splinechar_base_names };

static int _wrap_SplineChar_altuni_next_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  struct altuni *arg2 = (struct altuni *) 0 ;
  
  SWIG_check_num_args("SplineChar_altuni::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::next",1,"SplineChar_altuni *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineChar_altuni::next",2,"struct altuni *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_next_set",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_altuni,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_altuni_next_set",2,SWIGTYPE_p_altuni);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_next_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  struct altuni *result = 0 ;
  
  SWIG_check_num_args("SplineChar_altuni::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::next",1,"SplineChar_altuni *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_next_get",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  result = (struct altuni *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_altuni,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_unienc_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SplineChar_altuni::unienc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::unienc",1,"SplineChar_altuni *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineChar_altuni::unienc",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_unienc_set",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->unienc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_unienc_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineChar_altuni::unienc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::unienc",1,"SplineChar_altuni *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_unienc_get",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  result = (int) ((arg1)->unienc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_vs_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SplineChar_altuni::vs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::vs",1,"SplineChar_altuni *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineChar_altuni::vs",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_vs_set",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->vs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_vs_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineChar_altuni::vs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::vs",1,"SplineChar_altuni *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_vs_get",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  result = (int) ((arg1)->vs);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_fid_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SplineChar_altuni::fid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::fid",1,"SplineChar_altuni *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineChar_altuni::fid",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_fid_set",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->fid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_altuni_fid_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *arg1 = (SplineChar_altuni *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineChar_altuni::fid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_altuni::fid",1,"SplineChar_altuni *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_altuni,0))){
    SWIG_fail_ptr("SplineChar_altuni_fid_get",1,SWIGTYPE_p_SplineChar_altuni);
  }
  
  result = (int) ((arg1)->fid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineChar_altuni(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_altuni *result = 0 ;
  
  SWIG_check_num_args("SplineChar_altuni::SplineChar_altuni",0,0)
  result = (SplineChar_altuni *)calloc(1, sizeof(SplineChar_altuni));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineChar_altuni,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineChar_altuni(void *obj) {
SplineChar_altuni *arg1 = (SplineChar_altuni *) obj;
free((char *) arg1);
}
static swig_lua_method swig_SplineChar_altuni_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_SplineChar_altuni_attributes[] = {
    { "next", _wrap_SplineChar_altuni_next_get, _wrap_SplineChar_altuni_next_set},
    { "unienc", _wrap_SplineChar_altuni_unienc_get, _wrap_SplineChar_altuni_unienc_set},
    { "vs", _wrap_SplineChar_altuni_vs_get, _wrap_SplineChar_altuni_vs_set},
    { "fid", _wrap_SplineChar_altuni_fid_get, _wrap_SplineChar_altuni_fid_set},
    {0,0,0}
};
static swig_lua_class *swig_SplineChar_altuni_bases[] = {0};
static const char *swig_SplineChar_altuni_base_names[] = {0};
static swig_lua_class _wrap_class_SplineChar_altuni = { "SplineChar_altuni", &SWIGTYPE_p_SplineChar_altuni,_wrap_new_SplineChar_altuni, swig_delete_SplineChar_altuni, swig_SplineChar_altuni_methods, swig_SplineChar_altuni_attributes, swig_SplineChar_altuni_bases, swig_SplineChar_altuni_base_names };

static int _wrap_SplineChar_dependents_sc_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_dependents *arg1 = (SplineChar_dependents *) 0 ;
  struct splinechar *arg2 = (struct splinechar *) 0 ;
  
  SWIG_check_num_args("SplineChar_dependents::sc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_dependents::sc",1,"SplineChar_dependents *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineChar_dependents::sc",2,"struct splinechar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_dependents,0))){
    SWIG_fail_ptr("SplineChar_dependents_sc_set",1,SWIGTYPE_p_SplineChar_dependents);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_dependents_sc_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->sc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_dependents_sc_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_dependents *arg1 = (SplineChar_dependents *) 0 ;
  struct splinechar *result = 0 ;
  
  SWIG_check_num_args("SplineChar_dependents::sc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_dependents::sc",1,"SplineChar_dependents *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_dependents,0))){
    SWIG_fail_ptr("SplineChar_dependents_sc_get",1,SWIGTYPE_p_SplineChar_dependents);
  }
  
  result = (struct splinechar *) ((arg1)->sc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_dependents_next_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_dependents *arg1 = (SplineChar_dependents *) 0 ;
  struct splinecharlist *arg2 = (struct splinecharlist *) 0 ;
  
  SWIG_check_num_args("SplineChar_dependents::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_dependents::next",1,"SplineChar_dependents *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineChar_dependents::next",2,"struct splinecharlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_dependents,0))){
    SWIG_fail_ptr("SplineChar_dependents_next_set",1,SWIGTYPE_p_SplineChar_dependents);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinecharlist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineChar_dependents_next_set",2,SWIGTYPE_p_splinecharlist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineChar_dependents_next_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_dependents *arg1 = (SplineChar_dependents *) 0 ;
  struct splinecharlist *result = 0 ;
  
  SWIG_check_num_args("SplineChar_dependents::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineChar_dependents::next",1,"SplineChar_dependents *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineChar_dependents,0))){
    SWIG_fail_ptr("SplineChar_dependents_next_get",1,SWIGTYPE_p_SplineChar_dependents);
  }
  
  result = (struct splinecharlist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinecharlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineChar_dependents(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar_dependents *result = 0 ;
  
  SWIG_check_num_args("SplineChar_dependents::SplineChar_dependents",0,0)
  result = (SplineChar_dependents *)calloc(1, sizeof(SplineChar_dependents));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineChar_dependents,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineChar_dependents(void *obj) {
SplineChar_dependents *arg1 = (SplineChar_dependents *) obj;
free((char *) arg1);
}
static swig_lua_method swig_SplineChar_dependents_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_SplineChar_dependents_attributes[] = {
    { "sc", _wrap_SplineChar_dependents_sc_get, _wrap_SplineChar_dependents_sc_set},
    { "next", _wrap_SplineChar_dependents_next_get, _wrap_SplineChar_dependents_next_set},
    {0,0,0}
};
static swig_lua_class *swig_SplineChar_dependents_bases[] = {0};
static const char *swig_SplineChar_dependents_base_names[] = {0};
static swig_lua_class _wrap_class_SplineChar_dependents = { "SplineChar_dependents", &SWIGTYPE_p_SplineChar_dependents,_wrap_new_SplineChar_dependents, swig_delete_SplineChar_dependents, swig_SplineChar_dependents_methods, swig_SplineChar_dependents_attributes, swig_SplineChar_dependents_bases, swig_SplineChar_dependents_base_names };

static int _wrap_ttflangname_lang_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("ttflangname::lang",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::lang",1,"struct ttflangname *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ttflangname::lang",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_lang_set",1,SWIGTYPE_p_ttflangname);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lang = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttflangname_lang_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  int result;
  
  SWIG_check_num_args("ttflangname::lang",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::lang",1,"struct ttflangname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_lang_get",1,SWIGTYPE_p_ttflangname);
  }
  
  result = (int) ((arg1)->lang);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttflangname_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  char **arg2 ;
  
  SWIG_check_num_args("ttflangname::names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::names",1,"struct ttflangname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ttflangname::names",2,"char *[ttf_namemax]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_names_set",1,SWIGTYPE_p_ttflangname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("ttflangname_names_set",2,SWIGTYPE_p_p_char);
  }
  
  {
    size_t ii;
    char * *b = (char * *) arg1->names;
    for (ii = 0; ii < (size_t)ttf_namemax; ii++) b[ii] = *((char * *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttflangname_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("ttflangname::names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::names",1,"struct ttflangname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_names_get",1,SWIGTYPE_p_ttflangname);
  }
  
  result = (char **)(char **) ((arg1)->names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttflangname_frommac_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  int *arg2 ;
  
  SWIG_check_num_args("ttflangname::frommac",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::frommac",1,"struct ttflangname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ttflangname::frommac",2,"int [(ttf_namemax+31)/32]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_frommac_set",1,SWIGTYPE_p_ttflangname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("ttflangname_frommac_set",2,SWIGTYPE_p_int);
  }
  
  {
    size_t ii;
    int *b = (int *) arg1->frommac;
    for (ii = 0; ii < (size_t)(ttf_namemax+31)/32; ii++) b[ii] = *((int *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttflangname_frommac_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  int *result = 0 ;
  
  SWIG_check_num_args("ttflangname::frommac",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::frommac",1,"struct ttflangname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_frommac_get",1,SWIGTYPE_p_ttflangname);
  }
  
  result = (int *)(int *) ((arg1)->frommac);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttflangname_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  struct ttflangname *arg2 = (struct ttflangname *) 0 ;
  
  SWIG_check_num_args("ttflangname::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::next",1,"struct ttflangname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ttflangname::next",2,"struct ttflangname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_next_set",1,SWIGTYPE_p_ttflangname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ttflangname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("ttflangname_next_set",2,SWIGTYPE_p_ttflangname);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttflangname_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  struct ttflangname *result = 0 ;
  
  SWIG_check_num_args("ttflangname::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttflangname::next",1,"struct ttflangname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("ttflangname_next_get",1,SWIGTYPE_p_ttflangname);
  }
  
  result = (struct ttflangname *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ttflangname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_ttflangname(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *result = 0 ;
  
  SWIG_check_num_args("ttflangname::ttflangname",0,0)
  result = (struct ttflangname *)calloc(1, sizeof(struct ttflangname));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ttflangname,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_ttflangname(void *obj) {
struct ttflangname *arg1 = (struct ttflangname *) obj;
free((char *) arg1);
}
static swig_lua_method swig_ttflangname_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_ttflangname_attributes[] = {
    { "lang", _wrap_ttflangname_lang_get, _wrap_ttflangname_lang_set},
    { "names", _wrap_ttflangname_names_get, _wrap_ttflangname_names_set},
    { "frommac", _wrap_ttflangname_frommac_get, _wrap_ttflangname_frommac_set},
    { "next", _wrap_ttflangname_next_get, _wrap_ttflangname_next_set},
    {0,0,0}
};
static swig_lua_class *swig_ttflangname_bases[] = {0};
static const char *swig_ttflangname_base_names[] = {0};
static swig_lua_class _wrap_class_ttflangname = { "ttflangname", &SWIGTYPE_p_ttflangname,_wrap_new_ttflangname, swig_delete_ttflangname, swig_ttflangname_methods, swig_ttflangname_attributes, swig_ttflangname_bases, swig_ttflangname_base_names };

static int _wrap_MATH_ScriptPercentScaleDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::ScriptPercentScaleDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::ScriptPercentScaleDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::ScriptPercentScaleDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_ScriptPercentScaleDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ScriptPercentScaleDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_ScriptPercentScaleDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::ScriptPercentScaleDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::ScriptPercentScaleDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_ScriptPercentScaleDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->ScriptPercentScaleDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_ScriptScriptPercentScaleDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::ScriptScriptPercentScaleDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::ScriptScriptPercentScaleDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::ScriptScriptPercentScaleDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_ScriptScriptPercentScaleDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ScriptScriptPercentScaleDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_ScriptScriptPercentScaleDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::ScriptScriptPercentScaleDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::ScriptScriptPercentScaleDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_ScriptScriptPercentScaleDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->ScriptScriptPercentScaleDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_DelimitedSubFormulaMinHeight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("MATH::DelimitedSubFormulaMinHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::DelimitedSubFormulaMinHeight",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::DelimitedSubFormulaMinHeight",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_DelimitedSubFormulaMinHeight_set",1,SWIGTYPE_p_MATH);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->DelimitedSubFormulaMinHeight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_DelimitedSubFormulaMinHeight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("MATH::DelimitedSubFormulaMinHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::DelimitedSubFormulaMinHeight",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_DelimitedSubFormulaMinHeight_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (uint16) ((arg1)->DelimitedSubFormulaMinHeight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_DisplayOperatorMinHeight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("MATH::DisplayOperatorMinHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::DisplayOperatorMinHeight",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::DisplayOperatorMinHeight",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_DisplayOperatorMinHeight_set",1,SWIGTYPE_p_MATH);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->DisplayOperatorMinHeight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_DisplayOperatorMinHeight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("MATH::DisplayOperatorMinHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::DisplayOperatorMinHeight",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_DisplayOperatorMinHeight_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (uint16) ((arg1)->DisplayOperatorMinHeight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_MathLeading_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::MathLeading",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::MathLeading",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::MathLeading",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_MathLeading_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->MathLeading = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_MathLeading_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::MathLeading",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::MathLeading",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_MathLeading_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->MathLeading);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_AxisHeight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::AxisHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::AxisHeight",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::AxisHeight",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_AxisHeight_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->AxisHeight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_AxisHeight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::AxisHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::AxisHeight",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_AxisHeight_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->AxisHeight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_AccentBaseHeight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::AccentBaseHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::AccentBaseHeight",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::AccentBaseHeight",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_AccentBaseHeight_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->AccentBaseHeight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_AccentBaseHeight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::AccentBaseHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::AccentBaseHeight",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_AccentBaseHeight_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->AccentBaseHeight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FlattenedAccentBaseHeight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FlattenedAccentBaseHeight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FlattenedAccentBaseHeight",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FlattenedAccentBaseHeight",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FlattenedAccentBaseHeight_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FlattenedAccentBaseHeight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FlattenedAccentBaseHeight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FlattenedAccentBaseHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FlattenedAccentBaseHeight",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FlattenedAccentBaseHeight_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FlattenedAccentBaseHeight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubscriptShiftDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SubscriptShiftDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubscriptShiftDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SubscriptShiftDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubscriptShiftDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SubscriptShiftDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubscriptShiftDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SubscriptShiftDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubscriptShiftDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubscriptShiftDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SubscriptShiftDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubscriptTopMax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SubscriptTopMax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubscriptTopMax",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SubscriptTopMax",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubscriptTopMax_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SubscriptTopMax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubscriptTopMax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SubscriptTopMax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubscriptTopMax",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubscriptTopMax_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SubscriptTopMax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubscriptBaselineDropMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SubscriptBaselineDropMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubscriptBaselineDropMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SubscriptBaselineDropMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubscriptBaselineDropMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SubscriptBaselineDropMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubscriptBaselineDropMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SubscriptBaselineDropMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubscriptBaselineDropMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubscriptBaselineDropMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SubscriptBaselineDropMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptShiftUp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SuperscriptShiftUp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptShiftUp",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SuperscriptShiftUp",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptShiftUp_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SuperscriptShiftUp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptShiftUp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SuperscriptShiftUp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptShiftUp",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptShiftUp_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SuperscriptShiftUp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptShiftUpCramped_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SuperscriptShiftUpCramped",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptShiftUpCramped",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SuperscriptShiftUpCramped",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptShiftUpCramped_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SuperscriptShiftUpCramped = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptShiftUpCramped_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SuperscriptShiftUpCramped",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptShiftUpCramped",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptShiftUpCramped_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SuperscriptShiftUpCramped);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptBottomMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SuperscriptBottomMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptBottomMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SuperscriptBottomMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptBottomMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SuperscriptBottomMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptBottomMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SuperscriptBottomMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptBottomMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptBottomMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SuperscriptBottomMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptBaselineDropMax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SuperscriptBaselineDropMax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptBaselineDropMax",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SuperscriptBaselineDropMax",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptBaselineDropMax_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SuperscriptBaselineDropMax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptBaselineDropMax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SuperscriptBaselineDropMax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptBaselineDropMax",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptBaselineDropMax_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SuperscriptBaselineDropMax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubSuperscriptGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SubSuperscriptGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubSuperscriptGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SubSuperscriptGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubSuperscriptGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SubSuperscriptGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SubSuperscriptGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SubSuperscriptGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SubSuperscriptGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SubSuperscriptGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SubSuperscriptGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptBottomMaxWithSubscript_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SuperscriptBottomMaxWithSubscript",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptBottomMaxWithSubscript",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SuperscriptBottomMaxWithSubscript",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptBottomMaxWithSubscript_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SuperscriptBottomMaxWithSubscript = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SuperscriptBottomMaxWithSubscript_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SuperscriptBottomMaxWithSubscript",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SuperscriptBottomMaxWithSubscript",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SuperscriptBottomMaxWithSubscript_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SuperscriptBottomMaxWithSubscript);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SpaceAfterScript_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SpaceAfterScript",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SpaceAfterScript",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SpaceAfterScript",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SpaceAfterScript_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SpaceAfterScript = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SpaceAfterScript_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SpaceAfterScript",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SpaceAfterScript",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SpaceAfterScript_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SpaceAfterScript);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UpperLimitGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::UpperLimitGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UpperLimitGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::UpperLimitGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UpperLimitGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->UpperLimitGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UpperLimitGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::UpperLimitGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UpperLimitGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UpperLimitGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->UpperLimitGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UpperLimitBaselineRiseMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::UpperLimitBaselineRiseMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UpperLimitBaselineRiseMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::UpperLimitBaselineRiseMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UpperLimitBaselineRiseMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->UpperLimitBaselineRiseMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UpperLimitBaselineRiseMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::UpperLimitBaselineRiseMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UpperLimitBaselineRiseMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UpperLimitBaselineRiseMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->UpperLimitBaselineRiseMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_LowerLimitGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::LowerLimitGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::LowerLimitGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::LowerLimitGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_LowerLimitGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->LowerLimitGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_LowerLimitGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::LowerLimitGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::LowerLimitGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_LowerLimitGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->LowerLimitGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_LowerLimitBaselineDropMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::LowerLimitBaselineDropMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::LowerLimitBaselineDropMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::LowerLimitBaselineDropMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_LowerLimitBaselineDropMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->LowerLimitBaselineDropMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_LowerLimitBaselineDropMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::LowerLimitBaselineDropMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::LowerLimitBaselineDropMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_LowerLimitBaselineDropMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->LowerLimitBaselineDropMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackTopShiftUp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StackTopShiftUp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackTopShiftUp",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StackTopShiftUp",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackTopShiftUp_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StackTopShiftUp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackTopShiftUp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StackTopShiftUp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackTopShiftUp",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackTopShiftUp_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StackTopShiftUp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackTopDisplayStyleShiftUp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StackTopDisplayStyleShiftUp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackTopDisplayStyleShiftUp",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StackTopDisplayStyleShiftUp",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackTopDisplayStyleShiftUp_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StackTopDisplayStyleShiftUp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackTopDisplayStyleShiftUp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StackTopDisplayStyleShiftUp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackTopDisplayStyleShiftUp",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackTopDisplayStyleShiftUp_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StackTopDisplayStyleShiftUp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackBottomShiftDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StackBottomShiftDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackBottomShiftDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StackBottomShiftDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackBottomShiftDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StackBottomShiftDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackBottomShiftDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StackBottomShiftDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackBottomShiftDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackBottomShiftDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StackBottomShiftDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackBottomDisplayStyleShiftDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StackBottomDisplayStyleShiftDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackBottomDisplayStyleShiftDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StackBottomDisplayStyleShiftDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackBottomDisplayStyleShiftDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StackBottomDisplayStyleShiftDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackBottomDisplayStyleShiftDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StackBottomDisplayStyleShiftDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackBottomDisplayStyleShiftDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackBottomDisplayStyleShiftDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StackBottomDisplayStyleShiftDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StackGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StackGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StackGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StackGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StackGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackDisplayStyleGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StackDisplayStyleGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackDisplayStyleGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StackDisplayStyleGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackDisplayStyleGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StackDisplayStyleGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StackDisplayStyleGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StackDisplayStyleGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StackDisplayStyleGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StackDisplayStyleGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StackDisplayStyleGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackTopShiftUp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StretchStackTopShiftUp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackTopShiftUp",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StretchStackTopShiftUp",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackTopShiftUp_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StretchStackTopShiftUp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackTopShiftUp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StretchStackTopShiftUp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackTopShiftUp",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackTopShiftUp_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StretchStackTopShiftUp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackBottomShiftDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StretchStackBottomShiftDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackBottomShiftDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StretchStackBottomShiftDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackBottomShiftDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StretchStackBottomShiftDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackBottomShiftDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StretchStackBottomShiftDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackBottomShiftDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackBottomShiftDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StretchStackBottomShiftDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackGapAboveMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StretchStackGapAboveMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackGapAboveMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StretchStackGapAboveMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackGapAboveMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StretchStackGapAboveMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackGapAboveMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StretchStackGapAboveMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackGapAboveMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackGapAboveMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StretchStackGapAboveMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackGapBelowMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::StretchStackGapBelowMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackGapBelowMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::StretchStackGapBelowMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackGapBelowMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->StretchStackGapBelowMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_StretchStackGapBelowMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::StretchStackGapBelowMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::StretchStackGapBelowMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_StretchStackGapBelowMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->StretchStackGapBelowMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorShiftUp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionNumeratorShiftUp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorShiftUp",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionNumeratorShiftUp",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorShiftUp_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionNumeratorShiftUp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorShiftUp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionNumeratorShiftUp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorShiftUp",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorShiftUp_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionNumeratorShiftUp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorDisplayStyleShiftUp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionNumeratorDisplayStyleShiftUp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorDisplayStyleShiftUp",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionNumeratorDisplayStyleShiftUp",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorDisplayStyleShiftUp_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionNumeratorDisplayStyleShiftUp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorDisplayStyleShiftUp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionNumeratorDisplayStyleShiftUp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorDisplayStyleShiftUp",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorDisplayStyleShiftUp_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionNumeratorDisplayStyleShiftUp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorShiftDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionDenominatorShiftDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorShiftDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionDenominatorShiftDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorShiftDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionDenominatorShiftDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorShiftDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionDenominatorShiftDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorShiftDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorShiftDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionDenominatorShiftDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorDisplayStyleShiftDown_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionDenominatorDisplayStyleShiftDown",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorDisplayStyleShiftDown",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionDenominatorDisplayStyleShiftDown",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorDisplayStyleShiftDown_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionDenominatorDisplayStyleShiftDown = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorDisplayStyleShiftDown_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionDenominatorDisplayStyleShiftDown",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorDisplayStyleShiftDown",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorDisplayStyleShiftDown_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionDenominatorDisplayStyleShiftDown);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionNumeratorGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionNumeratorGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionNumeratorGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionNumeratorGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionNumeratorGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorDisplayStyleGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionNumeratorDisplayStyleGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorDisplayStyleGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionNumeratorDisplayStyleGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorDisplayStyleGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionNumeratorDisplayStyleGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionNumeratorDisplayStyleGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionNumeratorDisplayStyleGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionNumeratorDisplayStyleGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionNumeratorDisplayStyleGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionNumeratorDisplayStyleGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionRuleThickness_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionRuleThickness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionRuleThickness",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionRuleThickness",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionRuleThickness_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionRuleThickness = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionRuleThickness_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionRuleThickness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionRuleThickness",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionRuleThickness_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionRuleThickness);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionDenominatorGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionDenominatorGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionDenominatorGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionDenominatorGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionDenominatorGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorDisplayStyleGapMin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::FractionDenominatorDisplayStyleGapMin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorDisplayStyleGapMin",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::FractionDenominatorDisplayStyleGapMin",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorDisplayStyleGapMin_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->FractionDenominatorDisplayStyleGapMin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_FractionDenominatorDisplayStyleGapMin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::FractionDenominatorDisplayStyleGapMin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::FractionDenominatorDisplayStyleGapMin",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_FractionDenominatorDisplayStyleGapMin_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->FractionDenominatorDisplayStyleGapMin);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SkewedFractionHorizontalGap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SkewedFractionHorizontalGap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SkewedFractionHorizontalGap",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SkewedFractionHorizontalGap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SkewedFractionHorizontalGap_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SkewedFractionHorizontalGap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SkewedFractionHorizontalGap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SkewedFractionHorizontalGap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SkewedFractionHorizontalGap",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SkewedFractionHorizontalGap_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SkewedFractionHorizontalGap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SkewedFractionVerticalGap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::SkewedFractionVerticalGap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SkewedFractionVerticalGap",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::SkewedFractionVerticalGap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SkewedFractionVerticalGap_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->SkewedFractionVerticalGap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_SkewedFractionVerticalGap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::SkewedFractionVerticalGap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::SkewedFractionVerticalGap",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_SkewedFractionVerticalGap_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->SkewedFractionVerticalGap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_OverbarVerticalGap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::OverbarVerticalGap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::OverbarVerticalGap",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::OverbarVerticalGap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_OverbarVerticalGap_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->OverbarVerticalGap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_OverbarVerticalGap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::OverbarVerticalGap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::OverbarVerticalGap",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_OverbarVerticalGap_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->OverbarVerticalGap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_OverbarRuleThickness_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::OverbarRuleThickness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::OverbarRuleThickness",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::OverbarRuleThickness",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_OverbarRuleThickness_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->OverbarRuleThickness = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_OverbarRuleThickness_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::OverbarRuleThickness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::OverbarRuleThickness",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_OverbarRuleThickness_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->OverbarRuleThickness);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_OverbarExtraAscender_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::OverbarExtraAscender",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::OverbarExtraAscender",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::OverbarExtraAscender",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_OverbarExtraAscender_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->OverbarExtraAscender = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_OverbarExtraAscender_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::OverbarExtraAscender",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::OverbarExtraAscender",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_OverbarExtraAscender_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->OverbarExtraAscender);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UnderbarVerticalGap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::UnderbarVerticalGap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UnderbarVerticalGap",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::UnderbarVerticalGap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UnderbarVerticalGap_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->UnderbarVerticalGap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UnderbarVerticalGap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::UnderbarVerticalGap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UnderbarVerticalGap",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UnderbarVerticalGap_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->UnderbarVerticalGap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UnderbarRuleThickness_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::UnderbarRuleThickness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UnderbarRuleThickness",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::UnderbarRuleThickness",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UnderbarRuleThickness_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->UnderbarRuleThickness = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UnderbarRuleThickness_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::UnderbarRuleThickness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UnderbarRuleThickness",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UnderbarRuleThickness_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->UnderbarRuleThickness);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UnderbarExtraDescender_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::UnderbarExtraDescender",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UnderbarExtraDescender",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::UnderbarExtraDescender",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UnderbarExtraDescender_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->UnderbarExtraDescender = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_UnderbarExtraDescender_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::UnderbarExtraDescender",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::UnderbarExtraDescender",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_UnderbarExtraDescender_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->UnderbarExtraDescender);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalVerticalGap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::RadicalVerticalGap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalVerticalGap",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::RadicalVerticalGap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalVerticalGap_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->RadicalVerticalGap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalVerticalGap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::RadicalVerticalGap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalVerticalGap",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalVerticalGap_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->RadicalVerticalGap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalDisplayStyleVerticalGap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::RadicalDisplayStyleVerticalGap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalDisplayStyleVerticalGap",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::RadicalDisplayStyleVerticalGap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalDisplayStyleVerticalGap_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->RadicalDisplayStyleVerticalGap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalDisplayStyleVerticalGap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::RadicalDisplayStyleVerticalGap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalDisplayStyleVerticalGap",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalDisplayStyleVerticalGap_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->RadicalDisplayStyleVerticalGap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalRuleThickness_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::RadicalRuleThickness",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalRuleThickness",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::RadicalRuleThickness",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalRuleThickness_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->RadicalRuleThickness = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalRuleThickness_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::RadicalRuleThickness",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalRuleThickness",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalRuleThickness_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->RadicalRuleThickness);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalExtraAscender_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::RadicalExtraAscender",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalExtraAscender",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::RadicalExtraAscender",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalExtraAscender_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->RadicalExtraAscender = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalExtraAscender_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::RadicalExtraAscender",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalExtraAscender",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalExtraAscender_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->RadicalExtraAscender);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalKernBeforeDegree_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::RadicalKernBeforeDegree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalKernBeforeDegree",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::RadicalKernBeforeDegree",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalKernBeforeDegree_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->RadicalKernBeforeDegree = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalKernBeforeDegree_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::RadicalKernBeforeDegree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalKernBeforeDegree",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalKernBeforeDegree_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->RadicalKernBeforeDegree);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalKernAfterDegree_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("MATH::RadicalKernAfterDegree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalKernAfterDegree",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::RadicalKernAfterDegree",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalKernAfterDegree_set",1,SWIGTYPE_p_MATH);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->RadicalKernAfterDegree = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalKernAfterDegree_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  int16 result;
  
  SWIG_check_num_args("MATH::RadicalKernAfterDegree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalKernAfterDegree",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalKernAfterDegree_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (int16) ((arg1)->RadicalKernAfterDegree);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalDegreeBottomRaisePercent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("MATH::RadicalDegreeBottomRaisePercent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalDegreeBottomRaisePercent",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::RadicalDegreeBottomRaisePercent",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalDegreeBottomRaisePercent_set",1,SWIGTYPE_p_MATH);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->RadicalDegreeBottomRaisePercent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_RadicalDegreeBottomRaisePercent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("MATH::RadicalDegreeBottomRaisePercent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::RadicalDegreeBottomRaisePercent",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_RadicalDegreeBottomRaisePercent_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (uint16) ((arg1)->RadicalDegreeBottomRaisePercent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_MinConnectorOverlap_set(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("MATH::MinConnectorOverlap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::MinConnectorOverlap",1,"struct MATH *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MATH::MinConnectorOverlap",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_MinConnectorOverlap_set",1,SWIGTYPE_p_MATH);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->MinConnectorOverlap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATH_MinConnectorOverlap_get(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("MATH::MinConnectorOverlap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATH::MinConnectorOverlap",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATH_MinConnectorOverlap_get",1,SWIGTYPE_p_MATH);
  }
  
  result = (uint16) ((arg1)->MinConnectorOverlap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MATH(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *result = 0 ;
  
  SWIG_check_num_args("MATH::MATH",0,0)
  result = (struct MATH *)calloc(1, sizeof(struct MATH));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MATH,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MATH(void *obj) {
struct MATH *arg1 = (struct MATH *) obj;
free((char *) arg1);
}
static swig_lua_method swig_MATH_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_MATH_attributes[] = {
    { "ScriptPercentScaleDown", _wrap_MATH_ScriptPercentScaleDown_get, _wrap_MATH_ScriptPercentScaleDown_set},
    { "ScriptScriptPercentScaleDown", _wrap_MATH_ScriptScriptPercentScaleDown_get, _wrap_MATH_ScriptScriptPercentScaleDown_set},
    { "DelimitedSubFormulaMinHeight", _wrap_MATH_DelimitedSubFormulaMinHeight_get, _wrap_MATH_DelimitedSubFormulaMinHeight_set},
    { "DisplayOperatorMinHeight", _wrap_MATH_DisplayOperatorMinHeight_get, _wrap_MATH_DisplayOperatorMinHeight_set},
    { "MathLeading", _wrap_MATH_MathLeading_get, _wrap_MATH_MathLeading_set},
    { "AxisHeight", _wrap_MATH_AxisHeight_get, _wrap_MATH_AxisHeight_set},
    { "AccentBaseHeight", _wrap_MATH_AccentBaseHeight_get, _wrap_MATH_AccentBaseHeight_set},
    { "FlattenedAccentBaseHeight", _wrap_MATH_FlattenedAccentBaseHeight_get, _wrap_MATH_FlattenedAccentBaseHeight_set},
    { "SubscriptShiftDown", _wrap_MATH_SubscriptShiftDown_get, _wrap_MATH_SubscriptShiftDown_set},
    { "SubscriptTopMax", _wrap_MATH_SubscriptTopMax_get, _wrap_MATH_SubscriptTopMax_set},
    { "SubscriptBaselineDropMin", _wrap_MATH_SubscriptBaselineDropMin_get, _wrap_MATH_SubscriptBaselineDropMin_set},
    { "SuperscriptShiftUp", _wrap_MATH_SuperscriptShiftUp_get, _wrap_MATH_SuperscriptShiftUp_set},
    { "SuperscriptShiftUpCramped", _wrap_MATH_SuperscriptShiftUpCramped_get, _wrap_MATH_SuperscriptShiftUpCramped_set},
    { "SuperscriptBottomMin", _wrap_MATH_SuperscriptBottomMin_get, _wrap_MATH_SuperscriptBottomMin_set},
    { "SuperscriptBaselineDropMax", _wrap_MATH_SuperscriptBaselineDropMax_get, _wrap_MATH_SuperscriptBaselineDropMax_set},
    { "SubSuperscriptGapMin", _wrap_MATH_SubSuperscriptGapMin_get, _wrap_MATH_SubSuperscriptGapMin_set},
    { "SuperscriptBottomMaxWithSubscript", _wrap_MATH_SuperscriptBottomMaxWithSubscript_get, _wrap_MATH_SuperscriptBottomMaxWithSubscript_set},
    { "SpaceAfterScript", _wrap_MATH_SpaceAfterScript_get, _wrap_MATH_SpaceAfterScript_set},
    { "UpperLimitGapMin", _wrap_MATH_UpperLimitGapMin_get, _wrap_MATH_UpperLimitGapMin_set},
    { "UpperLimitBaselineRiseMin", _wrap_MATH_UpperLimitBaselineRiseMin_get, _wrap_MATH_UpperLimitBaselineRiseMin_set},
    { "LowerLimitGapMin", _wrap_MATH_LowerLimitGapMin_get, _wrap_MATH_LowerLimitGapMin_set},
    { "LowerLimitBaselineDropMin", _wrap_MATH_LowerLimitBaselineDropMin_get, _wrap_MATH_LowerLimitBaselineDropMin_set},
    { "StackTopShiftUp", _wrap_MATH_StackTopShiftUp_get, _wrap_MATH_StackTopShiftUp_set},
    { "StackTopDisplayStyleShiftUp", _wrap_MATH_StackTopDisplayStyleShiftUp_get, _wrap_MATH_StackTopDisplayStyleShiftUp_set},
    { "StackBottomShiftDown", _wrap_MATH_StackBottomShiftDown_get, _wrap_MATH_StackBottomShiftDown_set},
    { "StackBottomDisplayStyleShiftDown", _wrap_MATH_StackBottomDisplayStyleShiftDown_get, _wrap_MATH_StackBottomDisplayStyleShiftDown_set},
    { "StackGapMin", _wrap_MATH_StackGapMin_get, _wrap_MATH_StackGapMin_set},
    { "StackDisplayStyleGapMin", _wrap_MATH_StackDisplayStyleGapMin_get, _wrap_MATH_StackDisplayStyleGapMin_set},
    { "StretchStackTopShiftUp", _wrap_MATH_StretchStackTopShiftUp_get, _wrap_MATH_StretchStackTopShiftUp_set},
    { "StretchStackBottomShiftDown", _wrap_MATH_StretchStackBottomShiftDown_get, _wrap_MATH_StretchStackBottomShiftDown_set},
    { "StretchStackGapAboveMin", _wrap_MATH_StretchStackGapAboveMin_get, _wrap_MATH_StretchStackGapAboveMin_set},
    { "StretchStackGapBelowMin", _wrap_MATH_StretchStackGapBelowMin_get, _wrap_MATH_StretchStackGapBelowMin_set},
    { "FractionNumeratorShiftUp", _wrap_MATH_FractionNumeratorShiftUp_get, _wrap_MATH_FractionNumeratorShiftUp_set},
    { "FractionNumeratorDisplayStyleShiftUp", _wrap_MATH_FractionNumeratorDisplayStyleShiftUp_get, _wrap_MATH_FractionNumeratorDisplayStyleShiftUp_set},
    { "FractionDenominatorShiftDown", _wrap_MATH_FractionDenominatorShiftDown_get, _wrap_MATH_FractionDenominatorShiftDown_set},
    { "FractionDenominatorDisplayStyleShiftDown", _wrap_MATH_FractionDenominatorDisplayStyleShiftDown_get, _wrap_MATH_FractionDenominatorDisplayStyleShiftDown_set},
    { "FractionNumeratorGapMin", _wrap_MATH_FractionNumeratorGapMin_get, _wrap_MATH_FractionNumeratorGapMin_set},
    { "FractionNumeratorDisplayStyleGapMin", _wrap_MATH_FractionNumeratorDisplayStyleGapMin_get, _wrap_MATH_FractionNumeratorDisplayStyleGapMin_set},
    { "FractionRuleThickness", _wrap_MATH_FractionRuleThickness_get, _wrap_MATH_FractionRuleThickness_set},
    { "FractionDenominatorGapMin", _wrap_MATH_FractionDenominatorGapMin_get, _wrap_MATH_FractionDenominatorGapMin_set},
    { "FractionDenominatorDisplayStyleGapMin", _wrap_MATH_FractionDenominatorDisplayStyleGapMin_get, _wrap_MATH_FractionDenominatorDisplayStyleGapMin_set},
    { "SkewedFractionHorizontalGap", _wrap_MATH_SkewedFractionHorizontalGap_get, _wrap_MATH_SkewedFractionHorizontalGap_set},
    { "SkewedFractionVerticalGap", _wrap_MATH_SkewedFractionVerticalGap_get, _wrap_MATH_SkewedFractionVerticalGap_set},
    { "OverbarVerticalGap", _wrap_MATH_OverbarVerticalGap_get, _wrap_MATH_OverbarVerticalGap_set},
    { "OverbarRuleThickness", _wrap_MATH_OverbarRuleThickness_get, _wrap_MATH_OverbarRuleThickness_set},
    { "OverbarExtraAscender", _wrap_MATH_OverbarExtraAscender_get, _wrap_MATH_OverbarExtraAscender_set},
    { "UnderbarVerticalGap", _wrap_MATH_UnderbarVerticalGap_get, _wrap_MATH_UnderbarVerticalGap_set},
    { "UnderbarRuleThickness", _wrap_MATH_UnderbarRuleThickness_get, _wrap_MATH_UnderbarRuleThickness_set},
    { "UnderbarExtraDescender", _wrap_MATH_UnderbarExtraDescender_get, _wrap_MATH_UnderbarExtraDescender_set},
    { "RadicalVerticalGap", _wrap_MATH_RadicalVerticalGap_get, _wrap_MATH_RadicalVerticalGap_set},
    { "RadicalDisplayStyleVerticalGap", _wrap_MATH_RadicalDisplayStyleVerticalGap_get, _wrap_MATH_RadicalDisplayStyleVerticalGap_set},
    { "RadicalRuleThickness", _wrap_MATH_RadicalRuleThickness_get, _wrap_MATH_RadicalRuleThickness_set},
    { "RadicalExtraAscender", _wrap_MATH_RadicalExtraAscender_get, _wrap_MATH_RadicalExtraAscender_set},
    { "RadicalKernBeforeDegree", _wrap_MATH_RadicalKernBeforeDegree_get, _wrap_MATH_RadicalKernBeforeDegree_set},
    { "RadicalKernAfterDegree", _wrap_MATH_RadicalKernAfterDegree_get, _wrap_MATH_RadicalKernAfterDegree_set},
    { "RadicalDegreeBottomRaisePercent", _wrap_MATH_RadicalDegreeBottomRaisePercent_get, _wrap_MATH_RadicalDegreeBottomRaisePercent_set},
    { "MinConnectorOverlap", _wrap_MATH_MinConnectorOverlap_get, _wrap_MATH_MinConnectorOverlap_set},
    {0,0,0}
};
static swig_lua_class *swig_MATH_bases[] = {0};
static const char *swig_MATH_base_names[] = {0};
static swig_lua_class _wrap_class_MATH = { "MATH", &SWIGTYPE_p_MATH,_wrap_new_MATH, swig_delete_MATH, swig_MATH_methods, swig_MATH_attributes, swig_MATH_bases, swig_MATH_base_names };

static int _wrap_LayerInfo_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("layerinfo::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::name",1,"struct layerinfo *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("layerinfo::name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_name_set",1,SWIGTYPE_p_layerinfo);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->name);
    if (arg2) {
      arg1->name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfo_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("layerinfo::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::name",1,"struct layerinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_name_get",1,SWIGTYPE_p_layerinfo);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfo_background_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("layerinfo::background",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::background",1,"struct layerinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layerinfo::background",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_background_set",1,SWIGTYPE_p_layerinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->background = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfo_background_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("layerinfo::background",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::background",1,"struct layerinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_background_get",1,SWIGTYPE_p_layerinfo);
  }
  
  result = (unsigned int) ((arg1)->background);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfo_order2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("layerinfo::order2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::order2",1,"struct layerinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layerinfo::order2",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_order2_set",1,SWIGTYPE_p_layerinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->order2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfo_order2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("layerinfo::order2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::order2",1,"struct layerinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_order2_get",1,SWIGTYPE_p_layerinfo);
  }
  
  result = (unsigned int) ((arg1)->order2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfo_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("layerinfo::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::ticked",1,"struct layerinfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("layerinfo::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_ticked_set",1,SWIGTYPE_p_layerinfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfo_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *arg1 = (struct layerinfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("layerinfo::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("layerinfo::ticked",1,"struct layerinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfo_ticked_get",1,SWIGTYPE_p_layerinfo);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LayerInfo(lua_State* L) {
  int SWIG_arg = 0;
  struct layerinfo *result = 0 ;
  
  SWIG_check_num_args("layerinfo::layerinfo",0,0)
  result = (struct layerinfo *)calloc(1, sizeof(struct layerinfo));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_layerinfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_LayerInfo(void *obj) {
struct layerinfo *arg1 = (struct layerinfo *) obj;
free((char *) arg1);
}
static swig_lua_method swig_layerinfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_layerinfo_attributes[] = {
    { "name", _wrap_LayerInfo_name_get, _wrap_LayerInfo_name_set},
    { "background", _wrap_LayerInfo_background_get, _wrap_LayerInfo_background_set},
    { "order2", _wrap_LayerInfo_order2_get, _wrap_LayerInfo_order2_set},
    { "ticked", _wrap_LayerInfo_ticked_get, _wrap_LayerInfo_ticked_set},
    {0,0,0}
};
static swig_lua_class *swig_layerinfo_bases[] = {0};
static const char *swig_layerinfo_base_names[] = {0};
static swig_lua_class _wrap_class_layerinfo = { "LayerInfo", &SWIGTYPE_p_layerinfo,_wrap_new_LayerInfo, swig_delete_LayerInfo, swig_layerinfo_methods, swig_layerinfo_attributes, swig_layerinfo_bases, swig_layerinfo_base_names };

static int _wrap_baselangextent_lang_set(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("baselangextent::lang",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::lang",1,"struct baselangextent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("baselangextent::lang",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_lang_set",1,SWIGTYPE_p_baselangextent);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->lang = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_lang_get(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("baselangextent::lang",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::lang",1,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_lang_get",1,SWIGTYPE_p_baselangextent);
  }
  
  result = (uint32) ((arg1)->lang);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  struct baselangextent *arg2 = (struct baselangextent *) 0 ;
  
  SWIG_check_num_args("baselangextent::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::next",1,"struct baselangextent *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("baselangextent::next",2,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_next_set",1,SWIGTYPE_p_baselangextent);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_baselangextent,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("baselangextent_next_set",2,SWIGTYPE_p_baselangextent);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  struct baselangextent *result = 0 ;
  
  SWIG_check_num_args("baselangextent::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::next",1,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_next_get",1,SWIGTYPE_p_baselangextent);
  }
  
  result = (struct baselangextent *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_baselangextent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_ascent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("baselangextent::ascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::ascent",1,"struct baselangextent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("baselangextent::ascent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_ascent_set",1,SWIGTYPE_p_baselangextent);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_ascent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  int16 result;
  
  SWIG_check_num_args("baselangextent::ascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::ascent",1,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_ascent_get",1,SWIGTYPE_p_baselangextent);
  }
  
  result = (int16) ((arg1)->ascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_descent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("baselangextent::descent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::descent",1,"struct baselangextent *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("baselangextent::descent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_descent_set",1,SWIGTYPE_p_baselangextent);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->descent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_descent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  int16 result;
  
  SWIG_check_num_args("baselangextent::descent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::descent",1,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_descent_get",1,SWIGTYPE_p_baselangextent);
  }
  
  result = (int16) ((arg1)->descent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_features_set(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  struct baselangextent *arg2 = (struct baselangextent *) 0 ;
  
  SWIG_check_num_args("baselangextent::features",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::features",1,"struct baselangextent *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("baselangextent::features",2,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_features_set",1,SWIGTYPE_p_baselangextent);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_baselangextent,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("baselangextent_features_set",2,SWIGTYPE_p_baselangextent);
  }
  
  if (arg1) (arg1)->features = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_baselangextent_features_get(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  struct baselangextent *result = 0 ;
  
  SWIG_check_num_args("baselangextent::features",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("baselangextent::features",1,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("baselangextent_features_get",1,SWIGTYPE_p_baselangextent);
  }
  
  result = (struct baselangextent *) ((arg1)->features);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_baselangextent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_baselangextent(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *result = 0 ;
  
  SWIG_check_num_args("baselangextent::baselangextent",0,0)
  result = (struct baselangextent *)calloc(1, sizeof(struct baselangextent));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_baselangextent,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_baselangextent(void *obj) {
struct baselangextent *arg1 = (struct baselangextent *) obj;
free((char *) arg1);
}
static swig_lua_method swig_baselangextent_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_baselangextent_attributes[] = {
    { "lang", _wrap_baselangextent_lang_get, _wrap_baselangextent_lang_set},
    { "next", _wrap_baselangextent_next_get, _wrap_baselangextent_next_set},
    { "ascent", _wrap_baselangextent_ascent_get, _wrap_baselangextent_ascent_set},
    { "descent", _wrap_baselangextent_descent_get, _wrap_baselangextent_descent_set},
    { "features", _wrap_baselangextent_features_get, _wrap_baselangextent_features_set},
    {0,0,0}
};
static swig_lua_class *swig_baselangextent_bases[] = {0};
static const char *swig_baselangextent_base_names[] = {0};
static swig_lua_class _wrap_class_baselangextent = { "baselangextent", &SWIGTYPE_p_baselangextent,_wrap_new_baselangextent, swig_delete_baselangextent, swig_baselangextent_methods, swig_baselangextent_attributes, swig_baselangextent_bases, swig_baselangextent_base_names };

static int _wrap_basescript_script_set(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("basescript::script",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::script",1,"struct basescript *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("basescript::script",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_script_set",1,SWIGTYPE_p_basescript);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->script = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_script_get(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("basescript::script",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::script",1,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_script_get",1,SWIGTYPE_p_basescript);
  }
  
  result = (uint32) ((arg1)->script);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  struct basescript *arg2 = (struct basescript *) 0 ;
  
  SWIG_check_num_args("basescript::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::next",1,"struct basescript *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("basescript::next",2,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_next_set",1,SWIGTYPE_p_basescript);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basescript,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("basescript_next_set",2,SWIGTYPE_p_basescript);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  struct basescript *result = 0 ;
  
  SWIG_check_num_args("basescript::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::next",1,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_next_get",1,SWIGTYPE_p_basescript);
  }
  
  result = (struct basescript *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basescript,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_def_baseline_set(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("basescript::def_baseline",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::def_baseline",1,"struct basescript *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("basescript::def_baseline",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_def_baseline_set",1,SWIGTYPE_p_basescript);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->def_baseline = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_def_baseline_get(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  int result;
  
  SWIG_check_num_args("basescript::def_baseline",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::def_baseline",1,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_def_baseline_get",1,SWIGTYPE_p_basescript);
  }
  
  result = (int) ((arg1)->def_baseline);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_baseline_pos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  int16 *arg2 = (int16 *) 0 ;
  
  SWIG_check_num_args("basescript::baseline_pos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::baseline_pos",1,"struct basescript *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("basescript::baseline_pos",2,"int16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_baseline_pos_set",1,SWIGTYPE_p_basescript);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_short,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("basescript_baseline_pos_set",2,SWIGTYPE_p_short);
  }
  
  if (arg1) (arg1)->baseline_pos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_baseline_pos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  int16 *result = 0 ;
  
  SWIG_check_num_args("basescript::baseline_pos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::baseline_pos",1,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_baseline_pos_get",1,SWIGTYPE_p_basescript);
  }
  
  result = (int16 *) ((arg1)->baseline_pos);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_short,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_langs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  struct baselangextent *arg2 = (struct baselangextent *) 0 ;
  
  SWIG_check_num_args("basescript::langs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::langs",1,"struct basescript *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("basescript::langs",2,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_langs_set",1,SWIGTYPE_p_basescript);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_baselangextent,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("basescript_langs_set",2,SWIGTYPE_p_baselangextent);
  }
  
  if (arg1) (arg1)->langs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_basescript_langs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  struct baselangextent *result = 0 ;
  
  SWIG_check_num_args("basescript::langs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("basescript::langs",1,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("basescript_langs_get",1,SWIGTYPE_p_basescript);
  }
  
  result = (struct baselangextent *) ((arg1)->langs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_baselangextent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_basescript(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *result = 0 ;
  
  SWIG_check_num_args("basescript::basescript",0,0)
  result = (struct basescript *)calloc(1, sizeof(struct basescript));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basescript,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_basescript(void *obj) {
struct basescript *arg1 = (struct basescript *) obj;
free((char *) arg1);
}
static swig_lua_method swig_basescript_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_basescript_attributes[] = {
    { "script", _wrap_basescript_script_get, _wrap_basescript_script_set},
    { "next", _wrap_basescript_next_get, _wrap_basescript_next_set},
    { "def_baseline", _wrap_basescript_def_baseline_get, _wrap_basescript_def_baseline_set},
    { "baseline_pos", _wrap_basescript_baseline_pos_get, _wrap_basescript_baseline_pos_set},
    { "langs", _wrap_basescript_langs_get, _wrap_basescript_langs_set},
    {0,0,0}
};
static swig_lua_class *swig_basescript_bases[] = {0};
static const char *swig_basescript_base_names[] = {0};
static swig_lua_class _wrap_class_basescript = { "basescript", &SWIGTYPE_p_basescript,_wrap_new_basescript, swig_delete_basescript, swig_basescript_methods, swig_basescript_attributes, swig_basescript_bases, swig_basescript_base_names };

static int _wrap_Base_baseline_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *arg1 = (struct Base *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("Base::baseline_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Base::baseline_cnt",1,"struct Base *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Base::baseline_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Base,0))){
    SWIG_fail_ptr("Base_baseline_cnt_set",1,SWIGTYPE_p_Base);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->baseline_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Base_baseline_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *arg1 = (struct Base *) 0 ;
  int result;
  
  SWIG_check_num_args("Base::baseline_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Base::baseline_cnt",1,"struct Base *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Base,0))){
    SWIG_fail_ptr("Base_baseline_cnt_get",1,SWIGTYPE_p_Base);
  }
  
  result = (int) ((arg1)->baseline_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Base_baseline_tags_set(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *arg1 = (struct Base *) 0 ;
  uint32 *arg2 = (uint32 *) 0 ;
  
  SWIG_check_num_args("Base::baseline_tags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Base::baseline_tags",1,"struct Base *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Base::baseline_tags",2,"uint32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Base,0))){
    SWIG_fail_ptr("Base_baseline_tags_set",1,SWIGTYPE_p_Base);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Base_baseline_tags_set",2,SWIGTYPE_p_unsigned_int);
  }
  
  if (arg1) (arg1)->baseline_tags = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Base_baseline_tags_get(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *arg1 = (struct Base *) 0 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("Base::baseline_tags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Base::baseline_tags",1,"struct Base *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Base,0))){
    SWIG_fail_ptr("Base_baseline_tags_get",1,SWIGTYPE_p_Base);
  }
  
  result = (uint32 *) ((arg1)->baseline_tags);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Base_scripts_set(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *arg1 = (struct Base *) 0 ;
  struct basescript *arg2 = (struct basescript *) 0 ;
  
  SWIG_check_num_args("Base::scripts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Base::scripts",1,"struct Base *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Base::scripts",2,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Base,0))){
    SWIG_fail_ptr("Base_scripts_set",1,SWIGTYPE_p_Base);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basescript,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("Base_scripts_set",2,SWIGTYPE_p_basescript);
  }
  
  if (arg1) (arg1)->scripts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Base_scripts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *arg1 = (struct Base *) 0 ;
  struct basescript *result = 0 ;
  
  SWIG_check_num_args("Base::scripts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Base::scripts",1,"struct Base *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Base,0))){
    SWIG_fail_ptr("Base_scripts_get",1,SWIGTYPE_p_Base);
  }
  
  result = (struct basescript *) ((arg1)->scripts);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_basescript,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Base(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *result = 0 ;
  
  SWIG_check_num_args("Base::Base",0,0)
  result = (struct Base *)calloc(1, sizeof(struct Base));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Base,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Base(void *obj) {
struct Base *arg1 = (struct Base *) obj;
free((char *) arg1);
}
static swig_lua_method swig_Base_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_Base_attributes[] = {
    { "baseline_cnt", _wrap_Base_baseline_cnt_get, _wrap_Base_baseline_cnt_set},
    { "baseline_tags", _wrap_Base_baseline_tags_get, _wrap_Base_baseline_tags_set},
    { "scripts", _wrap_Base_scripts_get, _wrap_Base_scripts_set},
    {0,0,0}
};
static swig_lua_class *swig_Base_bases[] = {0};
static const char *swig_Base_base_names[] = {0};
static swig_lua_class _wrap_class_Base = { "Base", &SWIGTYPE_p_Base,_wrap_new_Base, swig_delete_Base, swig_Base_methods, swig_Base_attributes, swig_Base_bases, swig_Base_base_names };

static int _wrap_TeXData_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct tex_data *arg1 = (struct tex_data *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("tex_data::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tex_data::type",1,"struct tex_data *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("tex_data::type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tex_data,0))){
    SWIG_fail_ptr("TeXData_type_set",1,SWIGTYPE_p_tex_data);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1 && sizeof(int) == sizeof((arg1)->type)) *(int*)(void*)&((arg1)->type) = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TeXData_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct tex_data *arg1 = (struct tex_data *) 0 ;
  int result;
  
  SWIG_check_num_args("tex_data::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tex_data::type",1,"struct tex_data *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tex_data,0))){
    SWIG_fail_ptr("TeXData_type_get",1,SWIGTYPE_p_tex_data);
  }
  
  result = (int) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TeXData_params_set(lua_State* L) {
  int SWIG_arg = 0;
  struct tex_data *arg1 = (struct tex_data *) 0 ;
  int32 *arg2 ;
  
  SWIG_check_num_args("tex_data::params",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tex_data::params",1,"struct tex_data *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("tex_data::params",2,"int32 [22]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tex_data,0))){
    SWIG_fail_ptr("TeXData_params_set",1,SWIGTYPE_p_tex_data);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("TeXData_params_set",2,SWIGTYPE_p_int);
  }
  
  {
    size_t ii;
    int32 *b = (int32 *) arg1->params;
    for (ii = 0; ii < (size_t)22; ii++) b[ii] = *((int32 *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TeXData_params_get(lua_State* L) {
  int SWIG_arg = 0;
  struct tex_data *arg1 = (struct tex_data *) 0 ;
  int32 *result = 0 ;
  
  SWIG_check_num_args("tex_data::params",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("tex_data::params",1,"struct tex_data *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_tex_data,0))){
    SWIG_fail_ptr("TeXData_params_get",1,SWIGTYPE_p_tex_data);
  }
  
  result = (int32 *)(int32 *) ((arg1)->params);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_TeXData(lua_State* L) {
  int SWIG_arg = 0;
  struct tex_data *result = 0 ;
  
  SWIG_check_num_args("tex_data::tex_data",0,0)
  result = (struct tex_data *)calloc(1, sizeof(struct tex_data));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tex_data,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_TeXData(void *obj) {
struct tex_data *arg1 = (struct tex_data *) obj;
free((char *) arg1);
}
static swig_lua_method swig_tex_data_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_tex_data_attributes[] = {
    { "type", _wrap_TeXData_type_get, _wrap_TeXData_type_set},
    { "params", _wrap_TeXData_params_get, _wrap_TeXData_params_set},
    {0,0,0}
};
static swig_lua_class *swig_tex_data_bases[] = {0};
static const char *swig_tex_data_base_names[] = {0};
static swig_lua_class _wrap_class_tex_data = { "TeXData", &SWIGTYPE_p_tex_data,_wrap_new_TeXData, swig_delete_TeXData, swig_tex_data_methods, swig_tex_data_attributes, swig_tex_data_bases, swig_tex_data_base_names };

static int _wrap_SplineFont_fontname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::fontname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontname",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::fontname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontname_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->fontname);
    if (arg2) {
      arg1->fontname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->fontname, (const char *)arg2);
    } else {
      arg1->fontname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::fontname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontname",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontname_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->fontname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fullname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::fullname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fullname",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::fullname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fullname_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->fullname);
    if (arg2) {
      arg1->fullname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->fullname, (const char *)arg2);
    } else {
      arg1->fullname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fullname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::fullname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fullname",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fullname_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->fullname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_familyname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::familyname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::familyname",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::familyname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_familyname_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->familyname);
    if (arg2) {
      arg1->familyname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->familyname, (const char *)arg2);
    } else {
      arg1->familyname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_familyname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::familyname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::familyname",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_familyname_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->familyname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_weight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::weight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::weight",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::weight",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_weight_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->weight);
    if (arg2) {
      arg1->weight = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->weight, (const char *)arg2);
    } else {
      arg1->weight = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_weight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::weight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::weight",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_weight_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->weight);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_copyright_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::copyright",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::copyright",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::copyright",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_copyright_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->copyright);
    if (arg2) {
      arg1->copyright = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->copyright, (const char *)arg2);
    } else {
      arg1->copyright = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_copyright_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::copyright",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::copyright",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_copyright_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->copyright);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_filename_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::filename",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::filename",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::filename",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_filename_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->filename);
    if (arg2) {
      arg1->filename = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->filename, (const char *)arg2);
    } else {
      arg1->filename = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_filename_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::filename",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::filename",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_filename_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->filename);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_defbasefilename_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::defbasefilename",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::defbasefilename",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::defbasefilename",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_defbasefilename_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->defbasefilename);
    if (arg2) {
      arg1->defbasefilename = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->defbasefilename, (const char *)arg2);
    } else {
      arg1->defbasefilename = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_defbasefilename_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::defbasefilename",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::defbasefilename",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_defbasefilename_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->defbasefilename);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_version_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::version",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::version",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::version",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_version_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->version);
    if (arg2) {
      arg1->version = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->version, (const char *)arg2);
    } else {
      arg1->version = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_version_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::version",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::version",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_version_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->version);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_italicangle_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::italicangle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::italicangle",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::italicangle",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_italicangle_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->italicangle = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_italicangle_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::italicangle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::italicangle",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_italicangle_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->italicangle);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_upos_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::upos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::upos",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::upos",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_upos_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->upos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_upos_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::upos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::upos",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_upos_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->upos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_uwidth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::uwidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::uwidth",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::uwidth",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_uwidth_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->uwidth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_uwidth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::uwidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::uwidth",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_uwidth_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->uwidth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ascent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::ascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ascent",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::ascent",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ascent_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ascent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::ascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ascent",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ascent_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->ascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_descent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::descent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::descent",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::descent",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_descent_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->descent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_descent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::descent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::descent",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_descent_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->descent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_uniqueid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::uniqueid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::uniqueid",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::uniqueid",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_uniqueid_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->uniqueid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_uniqueid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::uniqueid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::uniqueid",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_uniqueid_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->uniqueid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::glyphcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphcnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::glyphcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphcnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->glyphcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::glyphcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphcnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphcnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->glyphcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::glyphmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphmax",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::glyphmax",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphmax_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->glyphmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::glyphmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphmax",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphmax_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->glyphmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  SplineChar **arg2 = (SplineChar **) 0 ;
  
  SWIG_check_num_args("splinefont::glyphs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphs",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::glyphs",2,"SplineChar **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphs_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_splinechar,0))){
    SWIG_fail_ptr("SplineFont_glyphs_set",2,SWIGTYPE_p_p_splinechar);
  }
  
  if (arg1) (arg1)->glyphs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  SplineChar **result = 0 ;
  
  SWIG_check_num_args("splinefont::glyphs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphs",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphs_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (SplineChar **) ((arg1)->glyphs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_changed_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::changed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::changed",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::changed",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_changed_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_changed_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::changed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::changed",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_changed_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->changed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_changed_since_autosave_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::changed_since_autosave",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::changed_since_autosave",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::changed_since_autosave",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_changed_since_autosave_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed_since_autosave = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_changed_since_autosave_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::changed_since_autosave",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::changed_since_autosave",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_changed_since_autosave_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->changed_since_autosave);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_changed_since_xuidchanged_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::changed_since_xuidchanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::changed_since_xuidchanged",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::changed_since_xuidchanged",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_changed_since_xuidchanged_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed_since_xuidchanged = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_changed_since_xuidchanged_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::changed_since_xuidchanged",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::changed_since_xuidchanged",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_changed_since_xuidchanged_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->changed_since_xuidchanged);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_antialias_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::display_antialias",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_antialias",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::display_antialias",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_antialias_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->display_antialias = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_antialias_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::display_antialias",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_antialias",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_antialias_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->display_antialias);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_bbsized_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::display_bbsized",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_bbsized",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::display_bbsized",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_bbsized_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->display_bbsized = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_bbsized_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::display_bbsized",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_bbsized",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_bbsized_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->display_bbsized);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_dotlesswarn_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::dotlesswarn",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::dotlesswarn",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::dotlesswarn",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_dotlesswarn_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->dotlesswarn = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_dotlesswarn_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::dotlesswarn",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::dotlesswarn",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_dotlesswarn_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->dotlesswarn);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_onlybitmaps_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::onlybitmaps",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::onlybitmaps",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::onlybitmaps",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_onlybitmaps_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->onlybitmaps = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_onlybitmaps_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::onlybitmaps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::onlybitmaps",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_onlybitmaps_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->onlybitmaps);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_serifcheck_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::serifcheck",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::serifcheck",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::serifcheck",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_serifcheck_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->serifcheck = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_serifcheck_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::serifcheck",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::serifcheck",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_serifcheck_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->serifcheck);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_issans_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::issans",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::issans",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::issans",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_issans_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->issans = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_issans_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::issans",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::issans",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_issans_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->issans);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_isserif_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::isserif",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::isserif",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::isserif",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_isserif_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->isserif = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_isserif_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::isserif",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::isserif",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_isserif_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->isserif);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_hasvmetrics_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::hasvmetrics",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::hasvmetrics",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::hasvmetrics",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_hasvmetrics_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hasvmetrics = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_hasvmetrics_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::hasvmetrics",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::hasvmetrics",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_hasvmetrics_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->hasvmetrics);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_loading_cid_map_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::loading_cid_map",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::loading_cid_map",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::loading_cid_map",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_loading_cid_map_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->loading_cid_map = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_loading_cid_map_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::loading_cid_map",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::loading_cid_map",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_loading_cid_map_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->loading_cid_map);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_dupnamewarn_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::dupnamewarn",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::dupnamewarn",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::dupnamewarn",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_dupnamewarn_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->dupnamewarn = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_dupnamewarn_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::dupnamewarn",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::dupnamewarn",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_dupnamewarn_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->dupnamewarn);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_encodingchanged_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::encodingchanged",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::encodingchanged",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::encodingchanged",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_encodingchanged_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->encodingchanged = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_encodingchanged_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::encodingchanged",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::encodingchanged",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_encodingchanged_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->encodingchanged);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_multilayer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::multilayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::multilayer",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::multilayer",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_multilayer_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->multilayer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_multilayer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::multilayer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::multilayer",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_multilayer_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->multilayer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_strokedfont_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::strokedfont",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::strokedfont",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::strokedfont",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_strokedfont_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->strokedfont = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_strokedfont_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::strokedfont",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::strokedfont",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_strokedfont_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->strokedfont);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_new_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::new",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::new",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::new",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_new_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->new = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_new_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::new",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::new",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_new_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->new);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_compacted_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::compacted",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::compacted",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::compacted",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_compacted_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->compacted = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_compacted_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::compacted",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::compacted",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_compacted_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->compacted);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_backedup_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::backedup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::backedup",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::backedup",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_backedup_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->backedup = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_backedup_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::backedup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::backedup",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_backedup_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->backedup);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_use_typo_metrics_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::use_typo_metrics",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::use_typo_metrics",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::use_typo_metrics",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_use_typo_metrics_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->use_typo_metrics = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_use_typo_metrics_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::use_typo_metrics",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::use_typo_metrics",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_use_typo_metrics_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->use_typo_metrics);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_weight_width_slope_only_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::weight_width_slope_only",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::weight_width_slope_only",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::weight_width_slope_only",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_weight_width_slope_only_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->weight_width_slope_only = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_weight_width_slope_only_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::weight_width_slope_only",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::weight_width_slope_only",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_weight_width_slope_only_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->weight_width_slope_only);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_save_to_dir_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::save_to_dir",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::save_to_dir",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::save_to_dir",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_save_to_dir_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->save_to_dir = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_save_to_dir_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::save_to_dir",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::save_to_dir",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_save_to_dir_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->save_to_dir);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_head_optimized_for_cleartype_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::head_optimized_for_cleartype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::head_optimized_for_cleartype",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::head_optimized_for_cleartype",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_head_optimized_for_cleartype_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->head_optimized_for_cleartype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_head_optimized_for_cleartype_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::head_optimized_for_cleartype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::head_optimized_for_cleartype",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_head_optimized_for_cleartype_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->head_optimized_for_cleartype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ticked",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ticked_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ticked",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ticked_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_internal_temp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::internal_temp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::internal_temp",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::internal_temp",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_internal_temp_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->internal_temp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_internal_temp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::internal_temp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::internal_temp",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_internal_temp_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->internal_temp);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_complained_about_spiros_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::complained_about_spiros",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::complained_about_spiros",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::complained_about_spiros",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_complained_about_spiros_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->complained_about_spiros = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_complained_about_spiros_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::complained_about_spiros",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::complained_about_spiros",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_complained_about_spiros_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->complained_about_spiros);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_use_xuid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::use_xuid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::use_xuid",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::use_xuid",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_use_xuid_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->use_xuid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_use_xuid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::use_xuid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::use_xuid",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_use_xuid_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->use_xuid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_use_uniqueid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("splinefont::use_uniqueid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::use_uniqueid",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::use_uniqueid",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_use_uniqueid_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->use_uniqueid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_use_uniqueid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("splinefont::use_uniqueid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::use_uniqueid",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_use_uniqueid_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (unsigned int) ((arg1)->use_uniqueid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fv_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct fontviewbase *arg2 = (struct fontviewbase *) 0 ;
  
  SWIG_check_num_args("splinefont::fv",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fv",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::fv",2,"struct fontviewbase *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fv_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_fontviewbase,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_fv_set",2,SWIGTYPE_p_fontviewbase);
  }
  
  if (arg1) (arg1)->fv = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fv_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct fontviewbase *result = 0 ;
  
  SWIG_check_num_args("splinefont::fv",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fv",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fv_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct fontviewbase *) ((arg1)->fv);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_fontviewbase,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_metrics_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct metricsview *arg2 = (struct metricsview *) 0 ;
  
  SWIG_check_num_args("splinefont::metrics",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::metrics",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::metrics",2,"struct metricsview *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_metrics_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_metricsview,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_metrics_set",2,SWIGTYPE_p_metricsview);
  }
  
  if (arg1) (arg1)->metrics = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_metrics_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct metricsview *result = 0 ;
  
  SWIG_check_num_args("splinefont::metrics",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::metrics",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_metrics_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct metricsview *) ((arg1)->metrics);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_metricsview,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_uni_interp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  enum uni_interp arg2 ;
  
  SWIG_check_num_args("splinefont::uni_interp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::uni_interp",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::uni_interp",2,"enum uni_interp");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_uni_interp_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (enum uni_interp)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->uni_interp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_uni_interp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  enum uni_interp result;
  
  SWIG_check_num_args("splinefont::uni_interp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::uni_interp",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_uni_interp_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (enum uni_interp) ((arg1)->uni_interp);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_for_new_glyphs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  NameList *arg2 = (NameList *) 0 ;
  
  SWIG_check_num_args("splinefont::for_new_glyphs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::for_new_glyphs",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::for_new_glyphs",2,"NameList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_for_new_glyphs_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_namelist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_for_new_glyphs_set",2,SWIGTYPE_p_namelist);
  }
  
  if (arg1) (arg1)->for_new_glyphs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_for_new_glyphs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  NameList *result = 0 ;
  
  SWIG_check_num_args("splinefont::for_new_glyphs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::for_new_glyphs",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_for_new_glyphs_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (NameList *) ((arg1)->for_new_glyphs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_namelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_map_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  
  SWIG_check_num_args("splinefont::map",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::map",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::map",2,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_map_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_map_set",2,SWIGTYPE_p_encmap);
  }
  
  if (arg1) (arg1)->map = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_map_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  EncMap *result = 0 ;
  
  SWIG_check_num_args("splinefont::map",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::map",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_map_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (EncMap *) ((arg1)->map);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_grid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  Layer *arg2 = (Layer *) 0 ;
  
  SWIG_check_num_args("splinefont::grid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::grid",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::grid",2,"Layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_grid_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("SplineFont_grid_set",2,SWIGTYPE_p_layer);
  }
  
  if (arg1) (arg1)->grid = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_grid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  Layer *result = 0 ;
  
  SWIG_check_num_args("splinefont::grid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::grid",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_grid_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (Layer *)& ((arg1)->grid);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_layer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_bitmaps_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  BDFFont *arg2 = (BDFFont *) 0 ;
  
  SWIG_check_num_args("splinefont::bitmaps",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::bitmaps",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::bitmaps",2,"BDFFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_bitmaps_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_bitmaps_set",2,SWIGTYPE_p_bdffont);
  }
  
  if (arg1) (arg1)->bitmaps = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_bitmaps_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("splinefont::bitmaps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::bitmaps",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_bitmaps_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (BDFFont *) ((arg1)->bitmaps);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_origname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::origname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::origname",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::origname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_origname_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->origname);
    if (arg2) {
      arg1->origname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->origname, (const char *)arg2);
    } else {
      arg1->origname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_origname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::origname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::origname",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_origname_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->origname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_autosavename_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::autosavename",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::autosavename",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::autosavename",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_autosavename_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->autosavename);
    if (arg2) {
      arg1->autosavename = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->autosavename, (const char *)arg2);
    } else {
      arg1->autosavename = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_autosavename_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::autosavename",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::autosavename",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_autosavename_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->autosavename);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_size_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::display_size",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_size",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::display_size",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_size_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->display_size = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_size_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::display_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_size",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_size_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->display_size);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_private_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct psdict *arg2 = (struct psdict *) 0 ;
  
  SWIG_check_num_args("splinefont::private",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::private",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::private",2,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_private_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_psdict,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_private_set",2,SWIGTYPE_p_psdict);
  }
  
  if (arg1) (arg1)->private = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_private_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct psdict *result = 0 ;
  
  SWIG_check_num_args("splinefont::private",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::private",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_private_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct psdict *) ((arg1)->private);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_psdict,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_xuid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::xuid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::xuid",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::xuid",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_xuid_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->xuid);
    if (arg2) {
      arg1->xuid = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->xuid, (const char *)arg2);
    } else {
      arg1->xuid = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_xuid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::xuid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::xuid",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_xuid_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->xuid);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct ttflangname *arg2 = (struct ttflangname *) 0 ;
  
  SWIG_check_num_args("splinefont::names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::names",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::names",2,"struct ttflangname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_names_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ttflangname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_names_set",2,SWIGTYPE_p_ttflangname);
  }
  
  if (arg1) (arg1)->names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct ttflangname *result = 0 ;
  
  SWIG_check_num_args("splinefont::names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::names",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_names_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct ttflangname *) ((arg1)->names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ttflangname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cidregistry_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::cidregistry",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cidregistry",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::cidregistry",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cidregistry_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->cidregistry);
    if (arg2) {
      arg1->cidregistry = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->cidregistry, (const char *)arg2);
    } else {
      arg1->cidregistry = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cidregistry_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::cidregistry",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cidregistry",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cidregistry_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->cidregistry);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ordering_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::ordering",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ordering",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::ordering",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ordering_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->ordering);
    if (arg2) {
      arg1->ordering = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->ordering, (const char *)arg2);
    } else {
      arg1->ordering = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ordering_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::ordering",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ordering",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ordering_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->ordering);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_supplement_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::supplement",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::supplement",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::supplement",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_supplement_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->supplement = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_supplement_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::supplement",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::supplement",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_supplement_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->supplement);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_subfontcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::subfontcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::subfontcnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::subfontcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_subfontcnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->subfontcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_subfontcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::subfontcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::subfontcnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_subfontcnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->subfontcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_subfonts_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct splinefont **arg2 = (struct splinefont **) 0 ;
  
  SWIG_check_num_args("splinefont::subfonts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::subfonts",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::subfonts",2,"struct splinefont **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_subfonts_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_subfonts_set",2,SWIGTYPE_p_p_splinefont);
  }
  
  if (arg1) (arg1)->subfonts = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_subfonts_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct splinefont **result = 0 ;
  
  SWIG_check_num_args("splinefont::subfonts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::subfonts",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_subfonts_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct splinefont **) ((arg1)->subfonts);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cidmaster_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct splinefont *arg2 = (struct splinefont *) 0 ;
  
  SWIG_check_num_args("splinefont::cidmaster",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cidmaster",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::cidmaster",2,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cidmaster_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_cidmaster_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->cidmaster = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cidmaster_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct splinefont *result = 0 ;
  
  SWIG_check_num_args("splinefont::cidmaster",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cidmaster",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cidmaster_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct splinefont *) ((arg1)->cidmaster);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cidversion_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::cidversion",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cidversion",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::cidversion",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cidversion_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->cidversion = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cidversion_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::cidversion",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cidversion",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cidversion_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->cidversion);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_comments_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::comments",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::comments",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::comments",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_comments_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->comments);
    if (arg2) {
      arg1->comments = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->comments, (const char *)arg2);
    } else {
      arg1->comments = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_comments_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::comments",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::comments",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_comments_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->comments);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontlog_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::fontlog",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontlog",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::fontlog",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontlog_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->fontlog);
    if (arg2) {
      arg1->fontlog = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->fontlog, (const char *)arg2);
    } else {
      arg1->fontlog = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontlog_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::fontlog",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontlog",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontlog_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->fontlog);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_tempuniqueid_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::tempuniqueid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::tempuniqueid",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::tempuniqueid",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_tempuniqueid_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->tempuniqueid = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_tempuniqueid_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::tempuniqueid",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::tempuniqueid",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_tempuniqueid_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->tempuniqueid);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_top_enc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::top_enc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::top_enc",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::top_enc",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_top_enc_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->top_enc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_top_enc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::top_enc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::top_enc",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_top_enc_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->top_enc);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_desired_row_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinefont::desired_row_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::desired_row_cnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::desired_row_cnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_desired_row_cnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->desired_row_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_desired_row_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinefont::desired_row_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::desired_row_cnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_desired_row_cnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (uint16) ((arg1)->desired_row_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_desired_col_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinefont::desired_col_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::desired_col_cnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::desired_col_cnt",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_desired_col_cnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->desired_col_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_desired_col_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinefont::desired_col_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::desired_col_cnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_desired_col_cnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (uint16) ((arg1)->desired_col_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphnames_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct glyphnamehash *arg2 = (struct glyphnamehash *) 0 ;
  
  SWIG_check_num_args("splinefont::glyphnames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphnames",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::glyphnames",2,"struct glyphnamehash *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphnames_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_glyphnamehash,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_glyphnames_set",2,SWIGTYPE_p_glyphnamehash);
  }
  
  if (arg1) (arg1)->glyphnames = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_glyphnames_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct glyphnamehash *result = 0 ;
  
  SWIG_check_num_args("splinefont::glyphnames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::glyphnames",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_glyphnames_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct glyphnamehash *) ((arg1)->glyphnames);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glyphnamehash,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cvt_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("splinefont::cvt_names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cvt_names",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::cvt_names",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cvt_names_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("SplineFont_cvt_names_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->cvt_names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cvt_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("splinefont::cvt_names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cvt_names",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cvt_names_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char **) ((arg1)->cvt_names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_instr_dlgs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct instrdata *arg2 = (struct instrdata *) 0 ;
  
  SWIG_check_num_args("splinefont::instr_dlgs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::instr_dlgs",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::instr_dlgs",2,"struct instrdata *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_instr_dlgs_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_instrdata,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_instr_dlgs_set",2,SWIGTYPE_p_instrdata);
  }
  
  if (arg1) (arg1)->instr_dlgs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_instr_dlgs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct instrdata *result = 0 ;
  
  SWIG_check_num_args("splinefont::instr_dlgs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::instr_dlgs",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_instr_dlgs_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct instrdata *) ((arg1)->instr_dlgs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_instrdata,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cvt_dlg_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct shortview *arg2 = (struct shortview *) 0 ;
  
  SWIG_check_num_args("splinefont::cvt_dlg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cvt_dlg",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::cvt_dlg",2,"struct shortview *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cvt_dlg_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_shortview,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_cvt_dlg_set",2,SWIGTYPE_p_shortview);
  }
  
  if (arg1) (arg1)->cvt_dlg = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_cvt_dlg_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct shortview *result = 0 ;
  
  SWIG_check_num_args("splinefont::cvt_dlg",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::cvt_dlg",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_cvt_dlg_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct shortview *) ((arg1)->cvt_dlg);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_shortview,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_kcld_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct kernclasslistdlg *arg2 = (struct kernclasslistdlg *) 0 ;
  
  SWIG_check_num_args("splinefont::kcld",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::kcld",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::kcld",2,"struct kernclasslistdlg *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_kcld_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclasslistdlg,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_kcld_set",2,SWIGTYPE_p_kernclasslistdlg);
  }
  
  if (arg1) (arg1)->kcld = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_kcld_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct kernclasslistdlg *result = 0 ;
  
  SWIG_check_num_args("splinefont::kcld",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::kcld",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_kcld_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct kernclasslistdlg *) ((arg1)->kcld);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclasslistdlg,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_vkcld_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct kernclasslistdlg *arg2 = (struct kernclasslistdlg *) 0 ;
  
  SWIG_check_num_args("splinefont::vkcld",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::vkcld",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::vkcld",2,"struct kernclasslistdlg *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_vkcld_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclasslistdlg,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_vkcld_set",2,SWIGTYPE_p_kernclasslistdlg);
  }
  
  if (arg1) (arg1)->vkcld = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_vkcld_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct kernclasslistdlg *result = 0 ;
  
  SWIG_check_num_args("splinefont::vkcld",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::vkcld",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_vkcld_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct kernclasslistdlg *) ((arg1)->vkcld);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclasslistdlg,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_kcd_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct kernclassdlg *arg2 = (struct kernclassdlg *) 0 ;
  
  SWIG_check_num_args("splinefont::kcd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::kcd",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::kcd",2,"struct kernclassdlg *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_kcd_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclassdlg,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_kcd_set",2,SWIGTYPE_p_kernclassdlg);
  }
  
  if (arg1) (arg1)->kcd = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_kcd_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct kernclassdlg *result = 0 ;
  
  SWIG_check_num_args("splinefont::kcd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::kcd",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_kcd_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct kernclassdlg *) ((arg1)->kcd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclassdlg,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_texdata_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct tex_data *arg2 = (struct tex_data *) 0 ;
  
  SWIG_check_num_args("splinefont::texdata",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::texdata",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::texdata",2,"struct tex_data *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_texdata_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_tex_data,0))){
    SWIG_fail_ptr("SplineFont_texdata_set",2,SWIGTYPE_p_tex_data);
  }
  
  if (arg1) (arg1)->texdata = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_texdata_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct tex_data *result = 0 ;
  
  SWIG_check_num_args("splinefont::texdata",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::texdata",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_texdata_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct tex_data *)& ((arg1)->texdata);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_tex_data,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gsub_lookups_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("splinefont::gsub_lookups",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gsub_lookups",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::gsub_lookups",2,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gsub_lookups_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_gsub_lookups_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->gsub_lookups = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gsub_lookups_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  OTLookup *result = 0 ;
  
  SWIG_check_num_args("splinefont::gsub_lookups",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gsub_lookups",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gsub_lookups_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (OTLookup *) ((arg1)->gsub_lookups);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gpos_lookups_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("splinefont::gpos_lookups",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gpos_lookups",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::gpos_lookups",2,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gpos_lookups_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_gpos_lookups_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->gpos_lookups = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gpos_lookups_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  OTLookup *result = 0 ;
  
  SWIG_check_num_args("splinefont::gpos_lookups",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gpos_lookups",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gpos_lookups_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (OTLookup *) ((arg1)->gpos_lookups);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_anchor_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  
  SWIG_check_num_args("splinefont::anchor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::anchor",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::anchor",2,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_anchor_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_anchor_set",2,SWIGTYPE_p_anchorclass);
  }
  
  if (arg1) (arg1)->anchor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_anchor_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("splinefont::anchor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::anchor",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_anchor_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (AnchorClass *) ((arg1)->anchor);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_kerns_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  KernClass *arg2 = (KernClass *) 0 ;
  
  SWIG_check_num_args("splinefont::kerns",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::kerns",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::kerns",2,"KernClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_kerns_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_kerns_set",2,SWIGTYPE_p_kernclass);
  }
  
  if (arg1) (arg1)->kerns = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_kerns_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  KernClass *result = 0 ;
  
  SWIG_check_num_args("splinefont::kerns",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::kerns",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_kerns_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (KernClass *) ((arg1)->kerns);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_vkerns_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  KernClass *arg2 = (KernClass *) 0 ;
  
  SWIG_check_num_args("splinefont::vkerns",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::vkerns",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::vkerns",2,"KernClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_vkerns_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_kernclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_vkerns_set",2,SWIGTYPE_p_kernclass);
  }
  
  if (arg1) (arg1)->vkerns = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_vkerns_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  KernClass *result = 0 ;
  
  SWIG_check_num_args("splinefont::vkerns",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::vkerns",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_vkerns_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (KernClass *) ((arg1)->vkerns);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_possub_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  FPST *arg2 = (FPST *) 0 ;
  
  SWIG_check_num_args("splinefont::possub",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::possub",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::possub",2,"FPST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_possub_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_fpst,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_possub_set",2,SWIGTYPE_p_generic_fpst);
  }
  
  if (arg1) (arg1)->possub = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_possub_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  FPST *result = 0 ;
  
  SWIG_check_num_args("splinefont::possub",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::possub",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_possub_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (FPST *) ((arg1)->possub);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_fpst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_sm_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  ASM *arg2 = (ASM *) 0 ;
  
  SWIG_check_num_args("splinefont::sm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::sm",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::sm",2,"ASM *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_sm_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_asm,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_sm_set",2,SWIGTYPE_p_generic_asm);
  }
  
  if (arg1) (arg1)->sm = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_sm_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  ASM *result = 0 ;
  
  SWIG_check_num_args("splinefont::sm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::sm",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_sm_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (ASM *) ((arg1)->sm);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_asm,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_features_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  MacFeat *arg2 = (MacFeat *) 0 ;
  
  SWIG_check_num_args("splinefont::features",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::features",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::features",2,"MacFeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_features_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macfeat,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_features_set",2,SWIGTYPE_p_macfeat);
  }
  
  if (arg1) (arg1)->features = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_features_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  MacFeat *result = 0 ;
  
  SWIG_check_num_args("splinefont::features",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::features",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_features_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (MacFeat *) ((arg1)->features);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macfeat,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_chosenname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::chosenname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::chosenname",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::chosenname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_chosenname_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->chosenname);
    if (arg2) {
      arg1->chosenname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->chosenname, (const char *)arg2);
    } else {
      arg1->chosenname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_chosenname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::chosenname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::chosenname",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_chosenname_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->chosenname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mm_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct mmset *arg2 = (struct mmset *) 0 ;
  
  SWIG_check_num_args("splinefont::mm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mm",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::mm",2,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mm_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_mmset,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_mm_set",2,SWIGTYPE_p_mmset);
  }
  
  if (arg1) (arg1)->mm = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mm_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct mmset *result = 0 ;
  
  SWIG_check_num_args("splinefont::mm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mm",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mm_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct mmset *) ((arg1)->mm);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mmset,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_macstyle_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("splinefont::macstyle",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::macstyle",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::macstyle",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_macstyle_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->macstyle = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_macstyle_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int16 result;
  
  SWIG_check_num_args("splinefont::macstyle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::macstyle",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_macstyle_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int16) ((arg1)->macstyle);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fondname_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::fondname",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fondname",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::fondname",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fondname_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->fondname);
    if (arg2) {
      arg1->fondname = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->fondname, (const char *)arg2);
    } else {
      arg1->fondname = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fondname_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::fondname",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fondname",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fondname_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->fondname);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_design_size_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinefont::design_size",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::design_size",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::design_size",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_design_size_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->design_size = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_design_size_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinefont::design_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::design_size",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_design_size_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (uint16) ((arg1)->design_size);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontstyle_id_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinefont::fontstyle_id",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontstyle_id",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::fontstyle_id",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontstyle_id_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->fontstyle_id = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontstyle_id_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinefont::fontstyle_id",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontstyle_id",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontstyle_id_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (uint16) ((arg1)->fontstyle_id);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontstyle_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct otfname *arg2 = (struct otfname *) 0 ;
  
  SWIG_check_num_args("splinefont::fontstyle_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontstyle_name",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::fontstyle_name",2,"struct otfname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontstyle_name_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otfname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_fontstyle_name_set",2,SWIGTYPE_p_otfname);
  }
  
  if (arg1) (arg1)->fontstyle_name = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontstyle_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct otfname *result = 0 ;
  
  SWIG_check_num_args("splinefont::fontstyle_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontstyle_name",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontstyle_name_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct otfname *) ((arg1)->fontstyle_name);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otfname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_design_range_bottom_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinefont::design_range_bottom",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::design_range_bottom",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::design_range_bottom",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_design_range_bottom_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->design_range_bottom = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_design_range_bottom_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinefont::design_range_bottom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::design_range_bottom",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_design_range_bottom_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (uint16) ((arg1)->design_range_bottom);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_design_range_top_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("splinefont::design_range_top",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::design_range_top",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::design_range_top",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_design_range_top_set",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->design_range_top = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_design_range_top_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("splinefont::design_range_top",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::design_range_top",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_design_range_top_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (uint16) ((arg1)->design_range_top);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_feat_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct otffeatname *arg2 = (struct otffeatname *) 0 ;
  
  SWIG_check_num_args("splinefont::feat_names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::feat_names",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::feat_names",2,"struct otffeatname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_feat_names_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otffeatname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_feat_names_set",2,SWIGTYPE_p_otffeatname);
  }
  
  if (arg1) (arg1)->feat_names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_feat_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct otffeatname *result = 0 ;
  
  SWIG_check_num_args("splinefont::feat_names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::feat_names",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_feat_names_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct otffeatname *) ((arg1)->feat_names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otffeatname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_strokewidth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::strokewidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::strokewidth",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::strokewidth",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_strokewidth_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->strokewidth = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_strokewidth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::strokewidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::strokewidth",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_strokewidth_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->strokewidth);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_class_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::mark_class_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_class_cnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::mark_class_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_class_cnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->mark_class_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_class_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::mark_class_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_class_cnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_class_cnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->mark_class_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_classes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("splinefont::mark_classes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_classes",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::mark_classes",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_classes_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("SplineFont_mark_classes_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->mark_classes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_classes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("splinefont::mark_classes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_classes",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_classes_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char **) ((arg1)->mark_classes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_class_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("splinefont::mark_class_names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_class_names",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::mark_class_names",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_class_names_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("SplineFont_mark_class_names_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->mark_class_names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_class_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("splinefont::mark_class_names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_class_names",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_class_names_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char **) ((arg1)->mark_class_names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_set_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::mark_set_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_set_cnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::mark_set_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_set_cnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->mark_set_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_set_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::mark_set_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_set_cnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_set_cnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->mark_set_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_sets_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("splinefont::mark_sets",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_sets",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::mark_sets",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_sets_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("SplineFont_mark_sets_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->mark_sets = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_sets_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("splinefont::mark_sets",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_sets",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_sets_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char **) ((arg1)->mark_sets);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_set_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("splinefont::mark_set_names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_set_names",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::mark_set_names",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_set_names_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("SplineFont_mark_set_names_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->mark_set_names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_mark_set_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("splinefont::mark_set_names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::mark_set_names",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_mark_set_names_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char **) ((arg1)->mark_set_names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_creationtime_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  long arg2 ;
  
  SWIG_check_num_args("splinefont::creationtime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::creationtime",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::creationtime",2,"long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_creationtime_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (long)lua_tonumber(L, 2);
  if (arg1) (arg1)->creationtime = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_creationtime_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  long result;
  
  SWIG_check_num_args("splinefont::creationtime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::creationtime",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_creationtime_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (long) ((arg1)->creationtime);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_modificationtime_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  long arg2 ;
  
  SWIG_check_num_args("splinefont::modificationtime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::modificationtime",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::modificationtime",2,"long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_modificationtime_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (long)lua_tonumber(L, 2);
  if (arg1) (arg1)->modificationtime = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_modificationtime_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  long result;
  
  SWIG_check_num_args("splinefont::modificationtime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::modificationtime",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_modificationtime_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (long) ((arg1)->modificationtime);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_os2_version_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("splinefont::os2_version",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::os2_version",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::os2_version",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_os2_version_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_version = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_os2_version_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short result;
  
  SWIG_check_num_args("splinefont::os2_version",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::os2_version",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_os2_version_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (short) ((arg1)->os2_version);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_compression_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("splinefont::compression",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::compression",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::compression",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_compression_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  if (arg1) (arg1)->compression = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_compression_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short result;
  
  SWIG_check_num_args("splinefont::compression",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::compression",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_compression_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (short) ((arg1)->compression);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_version_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("splinefont::gasp_version",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gasp_version",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::gasp_version",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gasp_version_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  if (arg1) (arg1)->gasp_version = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_version_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short result;
  
  SWIG_check_num_args("splinefont::gasp_version",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gasp_version",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gasp_version_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (short) ((arg1)->gasp_version);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short arg2 ;
  
  SWIG_check_num_args("splinefont::gasp_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gasp_cnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::gasp_cnt",2,"short");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gasp_cnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (short)lua_tonumber(L, 2);
  if (arg1) (arg1)->gasp_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  short result;
  
  SWIG_check_num_args("splinefont::gasp_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gasp_cnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gasp_cnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (short) ((arg1)->gasp_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_MATH_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct MATH *arg2 = (struct MATH *) 0 ;
  
  SWIG_check_num_args("splinefont::MATH",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::MATH",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::MATH",2,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_MATH_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_MATH,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_MATH_set",2,SWIGTYPE_p_MATH);
  }
  
  if (arg1) (arg1)->MATH = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_MATH_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct MATH *result = 0 ;
  
  SWIG_check_num_args("splinefont::MATH",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::MATH",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_MATH_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct MATH *) ((arg1)->MATH);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MATH,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_sfd_version_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::sfd_version",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::sfd_version",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::sfd_version",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_sfd_version_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->sfd_version = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_sfd_version_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::sfd_version",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::sfd_version",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_sfd_version_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->sfd_version);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontinfo_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct gfi_data *arg2 = (struct gfi_data *) 0 ;
  
  SWIG_check_num_args("splinefont::fontinfo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontinfo",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::fontinfo",2,"struct gfi_data *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontinfo_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gfi_data,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_fontinfo_set",2,SWIGTYPE_p_gfi_data);
  }
  
  if (arg1) (arg1)->fontinfo = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_fontinfo_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct gfi_data *result = 0 ;
  
  SWIG_check_num_args("splinefont::fontinfo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::fontinfo",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_fontinfo_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct gfi_data *) ((arg1)->fontinfo);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gfi_data,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_valwin_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct val_data *arg2 = (struct val_data *) 0 ;
  
  SWIG_check_num_args("splinefont::valwin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::valwin",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::valwin",2,"struct val_data *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_valwin_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_val_data,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_valwin_set",2,SWIGTYPE_p_val_data);
  }
  
  if (arg1) (arg1)->valwin = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_valwin_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct val_data *result = 0 ;
  
  SWIG_check_num_args("splinefont::valwin",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::valwin",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_valwin_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct val_data *) ((arg1)->valwin);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_val_data,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_python_temporary_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("splinefont::python_temporary",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::python_temporary",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::python_temporary",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_python_temporary_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"SplineFont_python_temporary_set");
  if (arg1) (arg1)->python_temporary = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_python_temporary_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("splinefont::python_temporary",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::python_temporary",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_python_temporary_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (void *) ((arg1)->python_temporary);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_python_persistent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  void *arg2 = (void *) 0 ;
  
  SWIG_check_num_args("splinefont::python_persistent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::python_persistent",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::python_persistent",2,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_python_persistent_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"SplineFont_python_persistent_set");
  if (arg1) (arg1)->python_persistent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_python_persistent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("splinefont::python_persistent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::python_persistent",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_python_persistent_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (void *) ((arg1)->python_persistent);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_loadvalidation_state_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  enum loadvalidation_state arg2 ;
  
  SWIG_check_num_args("splinefont::loadvalidation_state",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::loadvalidation_state",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::loadvalidation_state",2,"enum loadvalidation_state");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_loadvalidation_state_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (enum loadvalidation_state)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->loadvalidation_state = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_loadvalidation_state_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  enum loadvalidation_state result;
  
  SWIG_check_num_args("splinefont::loadvalidation_state",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::loadvalidation_state",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_loadvalidation_state_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (enum loadvalidation_state) ((arg1)->loadvalidation_state);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_layers_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  LayerInfo *arg2 = (LayerInfo *) 0 ;
  
  SWIG_check_num_args("splinefont::layers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::layers",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::layers",2,"LayerInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_layers_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_layerinfo,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_layers_set",2,SWIGTYPE_p_layerinfo);
  }
  
  if (arg1) (arg1)->layers = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_layers_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  LayerInfo *result = 0 ;
  
  SWIG_check_num_args("splinefont::layers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::layers",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_layers_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (LayerInfo *) ((arg1)->layers);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_layerinfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_layer_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::layer_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::layer_cnt",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::layer_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_layer_cnt_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->layer_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_layer_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::layer_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::layer_cnt",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_layer_cnt_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->layer_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_layer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::display_layer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_layer",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::display_layer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_layer_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->display_layer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_display_layer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::display_layer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::display_layer",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_display_layer_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->display_layer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_horiz_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct Base *arg2 = (struct Base *) 0 ;
  
  SWIG_check_num_args("splinefont::horiz_base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::horiz_base",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::horiz_base",2,"struct Base *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_horiz_base_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Base,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_horiz_base_set",2,SWIGTYPE_p_Base);
  }
  
  if (arg1) (arg1)->horiz_base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_horiz_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct Base *result = 0 ;
  
  SWIG_check_num_args("splinefont::horiz_base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::horiz_base",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_horiz_base_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct Base *) ((arg1)->horiz_base);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Base,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_vert_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct Base *arg2 = (struct Base *) 0 ;
  
  SWIG_check_num_args("splinefont::vert_base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::vert_base",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::vert_base",2,"struct Base *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_vert_base_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_Base,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_vert_base_set",2,SWIGTYPE_p_Base);
  }
  
  if (arg1) (arg1)->vert_base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_vert_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  struct Base *result = 0 ;
  
  SWIG_check_num_args("splinefont::vert_base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::vert_base",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_vert_base_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct Base *) ((arg1)->vert_base);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_Base,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_justify_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  Justify *arg2 = (Justify *) 0 ;
  
  SWIG_check_num_args("splinefont::justify",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::justify",1,"struct splinefont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("splinefont::justify",2,"Justify *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_justify_set",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_jstf_script,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_justify_set",2,SWIGTYPE_p_jstf_script);
  }
  
  if (arg1) (arg1)->justify = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_justify_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  Justify *result = 0 ;
  
  SWIG_check_num_args("splinefont::justify",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::justify",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_justify_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (Justify *) ((arg1)->justify);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_script,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_extrema_bound_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::extrema_bound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::extrema_bound",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::extrema_bound",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_extrema_bound_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->extrema_bound = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_extrema_bound_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::extrema_bound",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::extrema_bound",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_extrema_bound_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->extrema_bound);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_width_separation_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::width_separation",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::width_separation",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::width_separation",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_width_separation_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->width_separation = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_width_separation_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::width_separation",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::width_separation",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_width_separation_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->width_separation);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_sfntRevision_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::sfntRevision",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::sfntRevision",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::sfntRevision",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_sfntRevision_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->sfntRevision = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_sfntRevision_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::sfntRevision",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::sfntRevision",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_sfntRevision_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->sfntRevision);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_woffMajor_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::woffMajor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::woffMajor",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::woffMajor",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_woffMajor_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->woffMajor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_woffMajor_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::woffMajor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::woffMajor",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_woffMajor_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->woffMajor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_woffMinor_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("splinefont::woffMinor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::woffMinor",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::woffMinor",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_woffMinor_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->woffMinor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_woffMinor_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  int result;
  
  SWIG_check_num_args("splinefont::woffMinor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::woffMinor",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_woffMinor_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int) ((arg1)->woffMinor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_woffMetadata_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("splinefont::woffMetadata",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::woffMetadata",1,"struct splinefont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("splinefont::woffMetadata",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_woffMetadata_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->woffMetadata);
    if (arg2) {
      arg1->woffMetadata = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->woffMetadata, (const char *)arg2);
    } else {
      arg1->woffMetadata = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_woffMetadata_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("splinefont::woffMetadata",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::woffMetadata",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_woffMetadata_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *) ((arg1)->woffMetadata);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ufo_ascent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::ufo_ascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ufo_ascent",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::ufo_ascent",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ufo_ascent_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->ufo_ascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ufo_ascent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::ufo_ascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ufo_ascent",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ufo_ascent_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->ufo_ascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ufo_descent_set(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("splinefont::ufo_descent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ufo_descent",1,"struct splinefont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("splinefont::ufo_descent",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ufo_descent_set",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->ufo_descent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ufo_descent_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  float result;
  
  SWIG_check_num_args("splinefont::ufo_descent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ufo_descent",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ufo_descent_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float) ((arg1)->ufo_descent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  SplineFont_pfminfo *result = 0 ;
  
  SWIG_check_num_args("splinefont::pfminfo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::pfminfo",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (SplineFont_pfminfo *)& ((arg1)->pfminfo);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_pfminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  SplineFont_ttf_tables *result = 0 ;
  
  SWIG_check_num_args("splinefont::ttf_tables",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ttf_tables",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (SplineFont_ttf_tables *) ((arg1)->ttf_tables);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_ttf_tables,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  SplineFont_ttf_tab_saved *result = 0 ;
  
  SWIG_check_num_args("splinefont::ttf_tab_saved",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::ttf_tab_saved",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (SplineFont_ttf_tab_saved *) ((arg1)->ttf_tab_saved);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_ttf_tab_saved,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *arg1 = (struct splinefont *) 0 ;
  SplineFont_gasp *result = 0 ;
  
  SWIG_check_num_args("splinefont::gasp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("splinefont::gasp",1,"struct splinefont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont_gasp_get",1,SWIGTYPE_p_splinefont);
  }
  
  result = (SplineFont_gasp *) ((arg1)->gasp);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_gasp,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineFont(lua_State* L) {
  int SWIG_arg = 0;
  struct splinefont *result = 0 ;
  
  SWIG_check_num_args("splinefont::splinefont",0,0)
  result = (struct splinefont *)calloc(1, sizeof(struct splinefont));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineFont(void *obj) {
struct splinefont *arg1 = (struct splinefont *) obj;
free((char *) arg1);
}
static swig_lua_method swig_splinefont_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_splinefont_attributes[] = {
    { "fontname", _wrap_SplineFont_fontname_get, _wrap_SplineFont_fontname_set},
    { "fullname", _wrap_SplineFont_fullname_get, _wrap_SplineFont_fullname_set},
    { "familyname", _wrap_SplineFont_familyname_get, _wrap_SplineFont_familyname_set},
    { "weight", _wrap_SplineFont_weight_get, _wrap_SplineFont_weight_set},
    { "copyright", _wrap_SplineFont_copyright_get, _wrap_SplineFont_copyright_set},
    { "filename", _wrap_SplineFont_filename_get, _wrap_SplineFont_filename_set},
    { "defbasefilename", _wrap_SplineFont_defbasefilename_get, _wrap_SplineFont_defbasefilename_set},
    { "version", _wrap_SplineFont_version_get, _wrap_SplineFont_version_set},
    { "italicangle", _wrap_SplineFont_italicangle_get, _wrap_SplineFont_italicangle_set},
    { "upos", _wrap_SplineFont_upos_get, _wrap_SplineFont_upos_set},
    { "uwidth", _wrap_SplineFont_uwidth_get, _wrap_SplineFont_uwidth_set},
    { "ascent", _wrap_SplineFont_ascent_get, _wrap_SplineFont_ascent_set},
    { "descent", _wrap_SplineFont_descent_get, _wrap_SplineFont_descent_set},
    { "uniqueid", _wrap_SplineFont_uniqueid_get, _wrap_SplineFont_uniqueid_set},
    { "glyphcnt", _wrap_SplineFont_glyphcnt_get, _wrap_SplineFont_glyphcnt_set},
    { "glyphmax", _wrap_SplineFont_glyphmax_get, _wrap_SplineFont_glyphmax_set},
    { "glyphs", _wrap_SplineFont_glyphs_get, _wrap_SplineFont_glyphs_set},
    { "changed", _wrap_SplineFont_changed_get, _wrap_SplineFont_changed_set},
    { "changed_since_autosave", _wrap_SplineFont_changed_since_autosave_get, _wrap_SplineFont_changed_since_autosave_set},
    { "changed_since_xuidchanged", _wrap_SplineFont_changed_since_xuidchanged_get, _wrap_SplineFont_changed_since_xuidchanged_set},
    { "display_antialias", _wrap_SplineFont_display_antialias_get, _wrap_SplineFont_display_antialias_set},
    { "display_bbsized", _wrap_SplineFont_display_bbsized_get, _wrap_SplineFont_display_bbsized_set},
    { "dotlesswarn", _wrap_SplineFont_dotlesswarn_get, _wrap_SplineFont_dotlesswarn_set},
    { "onlybitmaps", _wrap_SplineFont_onlybitmaps_get, _wrap_SplineFont_onlybitmaps_set},
    { "serifcheck", _wrap_SplineFont_serifcheck_get, _wrap_SplineFont_serifcheck_set},
    { "issans", _wrap_SplineFont_issans_get, _wrap_SplineFont_issans_set},
    { "isserif", _wrap_SplineFont_isserif_get, _wrap_SplineFont_isserif_set},
    { "hasvmetrics", _wrap_SplineFont_hasvmetrics_get, _wrap_SplineFont_hasvmetrics_set},
    { "loading_cid_map", _wrap_SplineFont_loading_cid_map_get, _wrap_SplineFont_loading_cid_map_set},
    { "dupnamewarn", _wrap_SplineFont_dupnamewarn_get, _wrap_SplineFont_dupnamewarn_set},
    { "encodingchanged", _wrap_SplineFont_encodingchanged_get, _wrap_SplineFont_encodingchanged_set},
    { "multilayer", _wrap_SplineFont_multilayer_get, _wrap_SplineFont_multilayer_set},
    { "strokedfont", _wrap_SplineFont_strokedfont_get, _wrap_SplineFont_strokedfont_set},
    { "new", _wrap_SplineFont_new_get, _wrap_SplineFont_new_set},
    { "compacted", _wrap_SplineFont_compacted_get, _wrap_SplineFont_compacted_set},
    { "backedup", _wrap_SplineFont_backedup_get, _wrap_SplineFont_backedup_set},
    { "use_typo_metrics", _wrap_SplineFont_use_typo_metrics_get, _wrap_SplineFont_use_typo_metrics_set},
    { "weight_width_slope_only", _wrap_SplineFont_weight_width_slope_only_get, _wrap_SplineFont_weight_width_slope_only_set},
    { "save_to_dir", _wrap_SplineFont_save_to_dir_get, _wrap_SplineFont_save_to_dir_set},
    { "head_optimized_for_cleartype", _wrap_SplineFont_head_optimized_for_cleartype_get, _wrap_SplineFont_head_optimized_for_cleartype_set},
    { "ticked", _wrap_SplineFont_ticked_get, _wrap_SplineFont_ticked_set},
    { "internal_temp", _wrap_SplineFont_internal_temp_get, _wrap_SplineFont_internal_temp_set},
    { "complained_about_spiros", _wrap_SplineFont_complained_about_spiros_get, _wrap_SplineFont_complained_about_spiros_set},
    { "use_xuid", _wrap_SplineFont_use_xuid_get, _wrap_SplineFont_use_xuid_set},
    { "use_uniqueid", _wrap_SplineFont_use_uniqueid_get, _wrap_SplineFont_use_uniqueid_set},
    { "fv", _wrap_SplineFont_fv_get, _wrap_SplineFont_fv_set},
    { "metrics", _wrap_SplineFont_metrics_get, _wrap_SplineFont_metrics_set},
    { "uni_interp", _wrap_SplineFont_uni_interp_get, _wrap_SplineFont_uni_interp_set},
    { "for_new_glyphs", _wrap_SplineFont_for_new_glyphs_get, _wrap_SplineFont_for_new_glyphs_set},
    { "map", _wrap_SplineFont_map_get, _wrap_SplineFont_map_set},
    { "grid", _wrap_SplineFont_grid_get, _wrap_SplineFont_grid_set},
    { "bitmaps", _wrap_SplineFont_bitmaps_get, _wrap_SplineFont_bitmaps_set},
    { "origname", _wrap_SplineFont_origname_get, _wrap_SplineFont_origname_set},
    { "autosavename", _wrap_SplineFont_autosavename_get, _wrap_SplineFont_autosavename_set},
    { "display_size", _wrap_SplineFont_display_size_get, _wrap_SplineFont_display_size_set},
    { "private", _wrap_SplineFont_private_get, _wrap_SplineFont_private_set},
    { "xuid", _wrap_SplineFont_xuid_get, _wrap_SplineFont_xuid_set},
    { "names", _wrap_SplineFont_names_get, _wrap_SplineFont_names_set},
    { "cidregistry", _wrap_SplineFont_cidregistry_get, _wrap_SplineFont_cidregistry_set},
    { "ordering", _wrap_SplineFont_ordering_get, _wrap_SplineFont_ordering_set},
    { "supplement", _wrap_SplineFont_supplement_get, _wrap_SplineFont_supplement_set},
    { "subfontcnt", _wrap_SplineFont_subfontcnt_get, _wrap_SplineFont_subfontcnt_set},
    { "subfonts", _wrap_SplineFont_subfonts_get, _wrap_SplineFont_subfonts_set},
    { "cidmaster", _wrap_SplineFont_cidmaster_get, _wrap_SplineFont_cidmaster_set},
    { "cidversion", _wrap_SplineFont_cidversion_get, _wrap_SplineFont_cidversion_set},
    { "comments", _wrap_SplineFont_comments_get, _wrap_SplineFont_comments_set},
    { "fontlog", _wrap_SplineFont_fontlog_get, _wrap_SplineFont_fontlog_set},
    { "tempuniqueid", _wrap_SplineFont_tempuniqueid_get, _wrap_SplineFont_tempuniqueid_set},
    { "top_enc", _wrap_SplineFont_top_enc_get, _wrap_SplineFont_top_enc_set},
    { "desired_row_cnt", _wrap_SplineFont_desired_row_cnt_get, _wrap_SplineFont_desired_row_cnt_set},
    { "desired_col_cnt", _wrap_SplineFont_desired_col_cnt_get, _wrap_SplineFont_desired_col_cnt_set},
    { "glyphnames", _wrap_SplineFont_glyphnames_get, _wrap_SplineFont_glyphnames_set},
    { "cvt_names", _wrap_SplineFont_cvt_names_get, _wrap_SplineFont_cvt_names_set},
    { "instr_dlgs", _wrap_SplineFont_instr_dlgs_get, _wrap_SplineFont_instr_dlgs_set},
    { "cvt_dlg", _wrap_SplineFont_cvt_dlg_get, _wrap_SplineFont_cvt_dlg_set},
    { "kcld", _wrap_SplineFont_kcld_get, _wrap_SplineFont_kcld_set},
    { "vkcld", _wrap_SplineFont_vkcld_get, _wrap_SplineFont_vkcld_set},
    { "kcd", _wrap_SplineFont_kcd_get, _wrap_SplineFont_kcd_set},
    { "texdata", _wrap_SplineFont_texdata_get, _wrap_SplineFont_texdata_set},
    { "gsub_lookups", _wrap_SplineFont_gsub_lookups_get, _wrap_SplineFont_gsub_lookups_set},
    { "gpos_lookups", _wrap_SplineFont_gpos_lookups_get, _wrap_SplineFont_gpos_lookups_set},
    { "anchor", _wrap_SplineFont_anchor_get, _wrap_SplineFont_anchor_set},
    { "kerns", _wrap_SplineFont_kerns_get, _wrap_SplineFont_kerns_set},
    { "vkerns", _wrap_SplineFont_vkerns_get, _wrap_SplineFont_vkerns_set},
    { "possub", _wrap_SplineFont_possub_get, _wrap_SplineFont_possub_set},
    { "sm", _wrap_SplineFont_sm_get, _wrap_SplineFont_sm_set},
    { "features", _wrap_SplineFont_features_get, _wrap_SplineFont_features_set},
    { "chosenname", _wrap_SplineFont_chosenname_get, _wrap_SplineFont_chosenname_set},
    { "mm", _wrap_SplineFont_mm_get, _wrap_SplineFont_mm_set},
    { "macstyle", _wrap_SplineFont_macstyle_get, _wrap_SplineFont_macstyle_set},
    { "fondname", _wrap_SplineFont_fondname_get, _wrap_SplineFont_fondname_set},
    { "design_size", _wrap_SplineFont_design_size_get, _wrap_SplineFont_design_size_set},
    { "fontstyle_id", _wrap_SplineFont_fontstyle_id_get, _wrap_SplineFont_fontstyle_id_set},
    { "fontstyle_name", _wrap_SplineFont_fontstyle_name_get, _wrap_SplineFont_fontstyle_name_set},
    { "design_range_bottom", _wrap_SplineFont_design_range_bottom_get, _wrap_SplineFont_design_range_bottom_set},
    { "design_range_top", _wrap_SplineFont_design_range_top_get, _wrap_SplineFont_design_range_top_set},
    { "feat_names", _wrap_SplineFont_feat_names_get, _wrap_SplineFont_feat_names_set},
    { "strokewidth", _wrap_SplineFont_strokewidth_get, _wrap_SplineFont_strokewidth_set},
    { "mark_class_cnt", _wrap_SplineFont_mark_class_cnt_get, _wrap_SplineFont_mark_class_cnt_set},
    { "mark_classes", _wrap_SplineFont_mark_classes_get, _wrap_SplineFont_mark_classes_set},
    { "mark_class_names", _wrap_SplineFont_mark_class_names_get, _wrap_SplineFont_mark_class_names_set},
    { "mark_set_cnt", _wrap_SplineFont_mark_set_cnt_get, _wrap_SplineFont_mark_set_cnt_set},
    { "mark_sets", _wrap_SplineFont_mark_sets_get, _wrap_SplineFont_mark_sets_set},
    { "mark_set_names", _wrap_SplineFont_mark_set_names_get, _wrap_SplineFont_mark_set_names_set},
    { "creationtime", _wrap_SplineFont_creationtime_get, _wrap_SplineFont_creationtime_set},
    { "modificationtime", _wrap_SplineFont_modificationtime_get, _wrap_SplineFont_modificationtime_set},
    { "os2_version", _wrap_SplineFont_os2_version_get, _wrap_SplineFont_os2_version_set},
    { "compression", _wrap_SplineFont_compression_get, _wrap_SplineFont_compression_set},
    { "gasp_version", _wrap_SplineFont_gasp_version_get, _wrap_SplineFont_gasp_version_set},
    { "gasp_cnt", _wrap_SplineFont_gasp_cnt_get, _wrap_SplineFont_gasp_cnt_set},
    { "MATH", _wrap_SplineFont_MATH_get, _wrap_SplineFont_MATH_set},
    { "sfd_version", _wrap_SplineFont_sfd_version_get, _wrap_SplineFont_sfd_version_set},
    { "fontinfo", _wrap_SplineFont_fontinfo_get, _wrap_SplineFont_fontinfo_set},
    { "valwin", _wrap_SplineFont_valwin_get, _wrap_SplineFont_valwin_set},
    { "python_temporary", _wrap_SplineFont_python_temporary_get, _wrap_SplineFont_python_temporary_set},
    { "python_persistent", _wrap_SplineFont_python_persistent_get, _wrap_SplineFont_python_persistent_set},
    { "loadvalidation_state", _wrap_SplineFont_loadvalidation_state_get, _wrap_SplineFont_loadvalidation_state_set},
    { "layers", _wrap_SplineFont_layers_get, _wrap_SplineFont_layers_set},
    { "layer_cnt", _wrap_SplineFont_layer_cnt_get, _wrap_SplineFont_layer_cnt_set},
    { "display_layer", _wrap_SplineFont_display_layer_get, _wrap_SplineFont_display_layer_set},
    { "horiz_base", _wrap_SplineFont_horiz_base_get, _wrap_SplineFont_horiz_base_set},
    { "vert_base", _wrap_SplineFont_vert_base_get, _wrap_SplineFont_vert_base_set},
    { "justify", _wrap_SplineFont_justify_get, _wrap_SplineFont_justify_set},
    { "extrema_bound", _wrap_SplineFont_extrema_bound_get, _wrap_SplineFont_extrema_bound_set},
    { "width_separation", _wrap_SplineFont_width_separation_get, _wrap_SplineFont_width_separation_set},
    { "sfntRevision", _wrap_SplineFont_sfntRevision_get, _wrap_SplineFont_sfntRevision_set},
    { "woffMajor", _wrap_SplineFont_woffMajor_get, _wrap_SplineFont_woffMajor_set},
    { "woffMinor", _wrap_SplineFont_woffMinor_get, _wrap_SplineFont_woffMinor_set},
    { "woffMetadata", _wrap_SplineFont_woffMetadata_get, _wrap_SplineFont_woffMetadata_set},
    { "ufo_ascent", _wrap_SplineFont_ufo_ascent_get, _wrap_SplineFont_ufo_ascent_set},
    { "ufo_descent", _wrap_SplineFont_ufo_descent_get, _wrap_SplineFont_ufo_descent_set},
    { "pfminfo", _wrap_SplineFont_pfminfo_get, SWIG_Lua_set_immutable},
    { "ttf_tables", _wrap_SplineFont_ttf_tables_get, SWIG_Lua_set_immutable},
    { "ttf_tab_saved", _wrap_SplineFont_ttf_tab_saved_get, SWIG_Lua_set_immutable},
    { "gasp", _wrap_SplineFont_gasp_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_splinefont_bases[] = {0};
static const char *swig_splinefont_base_names[] = {0};
static swig_lua_class _wrap_class_splinefont = { "SplineFont", &SWIGTYPE_p_splinefont,_wrap_new_SplineFont, swig_delete_SplineFont, swig_splinefont_methods, swig_splinefont_attributes, swig_splinefont_bases, swig_splinefont_base_names };

static int _wrap_SplineFont_gasp_ppem_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_gasp *arg1 = (SplineFont_gasp *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("SplineFont_gasp::ppem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_gasp::ppem",1,"SplineFont_gasp *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_gasp::ppem",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_gasp,0))){
    SWIG_fail_ptr("SplineFont_gasp_ppem_set",1,SWIGTYPE_p_SplineFont_gasp);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->ppem = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_ppem_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_gasp *arg1 = (SplineFont_gasp *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("SplineFont_gasp::ppem",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_gasp::ppem",1,"SplineFont_gasp *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_gasp,0))){
    SWIG_fail_ptr("SplineFont_gasp_ppem_get",1,SWIGTYPE_p_SplineFont_gasp);
  }
  
  result = (uint16) ((arg1)->ppem);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_flags_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_gasp *arg1 = (SplineFont_gasp *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("SplineFont_gasp::flags",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_gasp::flags",1,"SplineFont_gasp *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_gasp::flags",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_gasp,0))){
    SWIG_fail_ptr("SplineFont_gasp_flags_set",1,SWIGTYPE_p_SplineFont_gasp);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->flags = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_gasp_flags_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_gasp *arg1 = (SplineFont_gasp *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("SplineFont_gasp::flags",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_gasp::flags",1,"SplineFont_gasp *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_gasp,0))){
    SWIG_fail_ptr("SplineFont_gasp_flags_get",1,SWIGTYPE_p_SplineFont_gasp);
  }
  
  result = (uint16) ((arg1)->flags);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineFont_gasp(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_gasp *result = 0 ;
  
  SWIG_check_num_args("SplineFont_gasp::SplineFont_gasp",0,0)
  result = (SplineFont_gasp *)calloc(1, sizeof(SplineFont_gasp));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_gasp,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineFont_gasp(void *obj) {
SplineFont_gasp *arg1 = (SplineFont_gasp *) obj;
free((char *) arg1);
}
static swig_lua_method swig_SplineFont_gasp_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_SplineFont_gasp_attributes[] = {
    { "ppem", _wrap_SplineFont_gasp_ppem_get, _wrap_SplineFont_gasp_ppem_set},
    { "flags", _wrap_SplineFont_gasp_flags_get, _wrap_SplineFont_gasp_flags_set},
    {0,0,0}
};
static swig_lua_class *swig_SplineFont_gasp_bases[] = {0};
static const char *swig_SplineFont_gasp_base_names[] = {0};
static swig_lua_class _wrap_class_SplineFont_gasp = { "SplineFont_gasp", &SWIGTYPE_p_SplineFont_gasp,_wrap_new_SplineFont_gasp, swig_delete_SplineFont_gasp, swig_SplineFont_gasp_methods, swig_SplineFont_gasp_attributes, swig_SplineFont_gasp_bases, swig_SplineFont_gasp_base_names };

static int _wrap_SplineFont_ttf_tab_saved_tag_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::tag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::tag",1,"SplineFont_ttf_tab_saved *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_ttf_tab_saved::tag",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_tag_set",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->tag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_tag_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::tag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::tag",1,"SplineFont_ttf_tab_saved *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_tag_get",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  result = (uint32) ((arg1)->tag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_len_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  int32 arg2 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::len",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::len",1,"SplineFont_ttf_tab_saved *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_ttf_tab_saved::len",2,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_len_set",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  if (arg1) (arg1)->len = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_len_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  int32 result;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::len",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::len",1,"SplineFont_ttf_tab_saved *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_len_get",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  result = (int32) ((arg1)->len);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_maxlen_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  int32 arg2 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::maxlen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::maxlen",1,"SplineFont_ttf_tab_saved *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_ttf_tab_saved::maxlen",2,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_maxlen_set",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  if (arg1) (arg1)->maxlen = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_maxlen_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  int32 result;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::maxlen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::maxlen",1,"SplineFont_ttf_tab_saved *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_maxlen_get",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  result = (int32) ((arg1)->maxlen);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_data_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::data",1,"SplineFont_ttf_tab_saved *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_ttf_tab_saved::data",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_data_set",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_data_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->data = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_data_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::data",1,"SplineFont_ttf_tab_saved *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_data_get",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  result = (uint8 *) ((arg1)->data);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_next_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  struct ttf_table *arg2 = (struct ttf_table *) 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::next",1,"SplineFont_ttf_tab_saved *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_ttf_tab_saved::next",2,"struct ttf_table *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_next_set",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ttf_table,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_next_set",2,SWIGTYPE_p_ttf_table);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_next_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  struct ttf_table *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::next",1,"SplineFont_ttf_tab_saved *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_next_get",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  result = (struct ttf_table *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ttf_table,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_temp_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::temp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::temp",1,"SplineFont_ttf_tab_saved *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_ttf_tab_saved::temp",2,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_temp_set",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_temp_set",2,SWIGTYPE_p_FILE);
  }
  
  if (arg1) (arg1)->temp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tab_saved_temp_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) 0 ;
  FILE *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::temp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tab_saved::temp",1,"SplineFont_ttf_tab_saved *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tab_saved,0))){
    SWIG_fail_ptr("SplineFont_ttf_tab_saved_temp_get",1,SWIGTYPE_p_SplineFont_ttf_tab_saved);
  }
  
  result = (FILE *) ((arg1)->temp);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FILE,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineFont_ttf_tab_saved(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tab_saved *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tab_saved::SplineFont_ttf_tab_saved",0,0)
  result = (SplineFont_ttf_tab_saved *)calloc(1, sizeof(SplineFont_ttf_tab_saved));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_ttf_tab_saved,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineFont_ttf_tab_saved(void *obj) {
SplineFont_ttf_tab_saved *arg1 = (SplineFont_ttf_tab_saved *) obj;
free((char *) arg1);
}
static swig_lua_method swig_SplineFont_ttf_tab_saved_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_SplineFont_ttf_tab_saved_attributes[] = {
    { "tag", _wrap_SplineFont_ttf_tab_saved_tag_get, _wrap_SplineFont_ttf_tab_saved_tag_set},
    { "len", _wrap_SplineFont_ttf_tab_saved_len_get, _wrap_SplineFont_ttf_tab_saved_len_set},
    { "maxlen", _wrap_SplineFont_ttf_tab_saved_maxlen_get, _wrap_SplineFont_ttf_tab_saved_maxlen_set},
    { "data", _wrap_SplineFont_ttf_tab_saved_data_get, _wrap_SplineFont_ttf_tab_saved_data_set},
    { "next", _wrap_SplineFont_ttf_tab_saved_next_get, _wrap_SplineFont_ttf_tab_saved_next_set},
    { "temp", _wrap_SplineFont_ttf_tab_saved_temp_get, _wrap_SplineFont_ttf_tab_saved_temp_set},
    {0,0,0}
};
static swig_lua_class *swig_SplineFont_ttf_tab_saved_bases[] = {0};
static const char *swig_SplineFont_ttf_tab_saved_base_names[] = {0};
static swig_lua_class _wrap_class_SplineFont_ttf_tab_saved = { "SplineFont_ttf_tab_saved", &SWIGTYPE_p_SplineFont_ttf_tab_saved,_wrap_new_SplineFont_ttf_tab_saved, swig_delete_SplineFont_ttf_tab_saved, swig_SplineFont_ttf_tab_saved_methods, swig_SplineFont_ttf_tab_saved_attributes, swig_SplineFont_ttf_tab_saved_bases, swig_SplineFont_ttf_tab_saved_base_names };

static int _wrap_SplineFont_ttf_tables_tag_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::tag",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::tag",1,"SplineFont_ttf_tables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_ttf_tables::tag",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_tag_set",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->tag = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_tag_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("SplineFont_ttf_tables::tag",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::tag",1,"SplineFont_ttf_tables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_tag_get",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  result = (uint32) ((arg1)->tag);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_len_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  int32 arg2 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::len",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::len",1,"SplineFont_ttf_tables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_ttf_tables::len",2,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_len_set",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  if (arg1) (arg1)->len = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_len_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  int32 result;
  
  SWIG_check_num_args("SplineFont_ttf_tables::len",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::len",1,"SplineFont_ttf_tables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_len_get",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  result = (int32) ((arg1)->len);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_maxlen_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  int32 arg2 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::maxlen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::maxlen",1,"SplineFont_ttf_tables *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_ttf_tables::maxlen",2,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_maxlen_set",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  if (arg1) (arg1)->maxlen = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_maxlen_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  int32 result;
  
  SWIG_check_num_args("SplineFont_ttf_tables::maxlen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::maxlen",1,"SplineFont_ttf_tables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_maxlen_get",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  result = (int32) ((arg1)->maxlen);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_data_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::data",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::data",1,"SplineFont_ttf_tables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_ttf_tables::data",2,"uint8 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_data_set",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_ttf_tables_data_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->data = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_data_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  uint8 *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::data",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::data",1,"SplineFont_ttf_tables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_data_get",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  result = (uint8 *) ((arg1)->data);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_next_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  struct ttf_table *arg2 = (struct ttf_table *) 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::next",1,"SplineFont_ttf_tables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_ttf_tables::next",2,"struct ttf_table *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_next_set",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ttf_table,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_ttf_tables_next_set",2,SWIGTYPE_p_ttf_table);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_next_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  struct ttf_table *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::next",1,"SplineFont_ttf_tables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_next_get",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  result = (struct ttf_table *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_ttf_table,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_temp_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::temp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::temp",1,"SplineFont_ttf_tables *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_ttf_tables::temp",2,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_temp_set",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("SplineFont_ttf_tables_temp_set",2,SWIGTYPE_p_FILE);
  }
  
  if (arg1) (arg1)->temp = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_ttf_tables_temp_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) 0 ;
  FILE *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::temp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_ttf_tables::temp",1,"SplineFont_ttf_tables *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_ttf_tables,0))){
    SWIG_fail_ptr("SplineFont_ttf_tables_temp_get",1,SWIGTYPE_p_SplineFont_ttf_tables);
  }
  
  result = (FILE *) ((arg1)->temp);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FILE,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineFont_ttf_tables(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_ttf_tables *result = 0 ;
  
  SWIG_check_num_args("SplineFont_ttf_tables::SplineFont_ttf_tables",0,0)
  result = (SplineFont_ttf_tables *)calloc(1, sizeof(SplineFont_ttf_tables));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_ttf_tables,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineFont_ttf_tables(void *obj) {
SplineFont_ttf_tables *arg1 = (SplineFont_ttf_tables *) obj;
free((char *) arg1);
}
static swig_lua_method swig_SplineFont_ttf_tables_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_SplineFont_ttf_tables_attributes[] = {
    { "tag", _wrap_SplineFont_ttf_tables_tag_get, _wrap_SplineFont_ttf_tables_tag_set},
    { "len", _wrap_SplineFont_ttf_tables_len_get, _wrap_SplineFont_ttf_tables_len_set},
    { "maxlen", _wrap_SplineFont_ttf_tables_maxlen_get, _wrap_SplineFont_ttf_tables_maxlen_set},
    { "data", _wrap_SplineFont_ttf_tables_data_get, _wrap_SplineFont_ttf_tables_data_set},
    { "next", _wrap_SplineFont_ttf_tables_next_get, _wrap_SplineFont_ttf_tables_next_set},
    { "temp", _wrap_SplineFont_ttf_tables_temp_get, _wrap_SplineFont_ttf_tables_temp_set},
    {0,0,0}
};
static swig_lua_class *swig_SplineFont_ttf_tables_bases[] = {0};
static const char *swig_SplineFont_ttf_tables_base_names[] = {0};
static swig_lua_class _wrap_class_SplineFont_ttf_tables = { "SplineFont_ttf_tables", &SWIGTYPE_p_SplineFont_ttf_tables,_wrap_new_SplineFont_ttf_tables, swig_delete_SplineFont_ttf_tables, swig_SplineFont_ttf_tables_methods, swig_SplineFont_ttf_tables_attributes, swig_SplineFont_ttf_tables_bases, swig_SplineFont_ttf_tables_base_names };

static int _wrap_SplineFont_pfminfo_pfmset_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::pfmset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::pfmset",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::pfmset",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_pfmset_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pfmset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_pfmset_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::pfmset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::pfmset",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_pfmset_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->pfmset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_winascent_add_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::winascent_add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::winascent_add",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::winascent_add",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_winascent_add_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->winascent_add = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_winascent_add_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::winascent_add",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::winascent_add",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_winascent_add_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->winascent_add);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_windescent_add_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::windescent_add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::windescent_add",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::windescent_add",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_windescent_add_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->windescent_add = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_windescent_add_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::windescent_add",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::windescent_add",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_windescent_add_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->windescent_add);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hheadascent_add_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::hheadascent_add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hheadascent_add",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::hheadascent_add",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hheadascent_add_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hheadascent_add = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hheadascent_add_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::hheadascent_add",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hheadascent_add",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hheadascent_add_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->hheadascent_add);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hheaddescent_add_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::hheaddescent_add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hheaddescent_add",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::hheaddescent_add",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hheaddescent_add_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hheaddescent_add = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hheaddescent_add_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::hheaddescent_add",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hheaddescent_add",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hheaddescent_add_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->hheaddescent_add);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_typoascent_add_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::typoascent_add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::typoascent_add",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::typoascent_add",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_typoascent_add_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->typoascent_add = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_typoascent_add_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::typoascent_add",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::typoascent_add",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_typoascent_add_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->typoascent_add);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_typodescent_add_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::typodescent_add",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::typodescent_add",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::typodescent_add",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_typodescent_add_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->typodescent_add = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_typodescent_add_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::typodescent_add",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::typodescent_add",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_typodescent_add_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->typodescent_add);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_subsuper_set_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::subsuper_set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::subsuper_set",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::subsuper_set",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_subsuper_set_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->subsuper_set = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_subsuper_set_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::subsuper_set",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::subsuper_set",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_subsuper_set_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->subsuper_set);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_panose_set_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::panose_set",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::panose_set",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::panose_set",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_panose_set_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->panose_set = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_panose_set_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::panose_set",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::panose_set",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_panose_set_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->panose_set);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hheadset_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::hheadset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hheadset",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::hheadset",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hheadset_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hheadset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hheadset_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::hheadset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hheadset",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hheadset_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->hheadset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_vheadset_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::vheadset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::vheadset",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::vheadset",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_vheadset_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->vheadset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_vheadset_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::vheadset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::vheadset",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_vheadset_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->vheadset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hascodepages_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::hascodepages",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hascodepages",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::hascodepages",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hascodepages_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hascodepages = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hascodepages_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::hascodepages",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hascodepages",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hascodepages_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->hascodepages);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hasunicoderanges_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::hasunicoderanges",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hasunicoderanges",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::hasunicoderanges",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hasunicoderanges_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->hasunicoderanges = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hasunicoderanges_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("SplineFont_pfminfo::hasunicoderanges",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hasunicoderanges",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hasunicoderanges_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned int) ((arg1)->hasunicoderanges);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_pfmfamily_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned char arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::pfmfamily",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::pfmfamily",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::pfmfamily",2,"unsigned char");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_pfmfamily_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned char)lua_tonumber(L, 2);
  if (arg1) (arg1)->pfmfamily = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_pfmfamily_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  unsigned char result;
  
  SWIG_check_num_args("SplineFont_pfminfo::pfmfamily",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::pfmfamily",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_pfmfamily_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (unsigned char) ((arg1)->pfmfamily);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_weight_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::weight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::weight",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::weight",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_weight_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->weight = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_weight_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::weight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::weight",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_weight_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->weight);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_width_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::width",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::width",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_width_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_width_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::width",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_width_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_panose_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::panose",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::panose",1,"SplineFont_pfminfo *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SplineFont_pfminfo::panose",2,"char [10]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_panose_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->panose, (const char *)arg2, 10-1);
      arg1->panose[10-1] = 0;
    } else {
      arg1->panose[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_panose_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::panose",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::panose",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_panose_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (char *)(char *) ((arg1)->panose);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_fstype_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::fstype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::fstype",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::fstype",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_fstype_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->fstype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_fstype_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::fstype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::fstype",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_fstype_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->fstype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_linegap_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::linegap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::linegap",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::linegap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_linegap_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->linegap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_linegap_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::linegap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::linegap",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_linegap_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->linegap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_vlinegap_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::vlinegap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::vlinegap",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::vlinegap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_vlinegap_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->vlinegap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_vlinegap_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::vlinegap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::vlinegap",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_vlinegap_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->vlinegap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hhead_ascent_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::hhead_ascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hhead_ascent",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::hhead_ascent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hhead_ascent_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->hhead_ascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hhead_ascent_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::hhead_ascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hhead_ascent",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hhead_ascent_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->hhead_ascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hhead_descent_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::hhead_descent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hhead_descent",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::hhead_descent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hhead_descent_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->hhead_descent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_hhead_descent_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::hhead_descent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::hhead_descent",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_hhead_descent_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->hhead_descent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_typoascent_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_typoascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_typoascent",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_typoascent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_typoascent_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_typoascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_typoascent_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_typoascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_typoascent",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_typoascent_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_typoascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_typodescent_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_typodescent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_typodescent",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_typodescent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_typodescent_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_typodescent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_typodescent_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_typodescent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_typodescent",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_typodescent_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_typodescent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_typolinegap_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_typolinegap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_typolinegap",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_typolinegap",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_typolinegap_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_typolinegap = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_typolinegap_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_typolinegap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_typolinegap",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_typolinegap_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_typolinegap);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_winascent_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_winascent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_winascent",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_winascent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_winascent_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_winascent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_winascent_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_winascent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_winascent",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_winascent_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_winascent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_windescent_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_windescent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_windescent",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_windescent",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_windescent_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_windescent = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_windescent_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_windescent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_windescent",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_windescent_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_windescent);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subxsize_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subxsize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subxsize",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_subxsize",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subxsize_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_subxsize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subxsize_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subxsize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subxsize",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subxsize_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_subxsize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subysize_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subysize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subysize",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_subysize",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subysize_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_subysize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subysize_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subysize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subysize",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subysize_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_subysize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subxoff_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subxoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subxoff",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_subxoff",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subxoff_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_subxoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subxoff_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subxoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subxoff",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subxoff_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_subxoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subyoff_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subyoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subyoff",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_subyoff",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subyoff_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_subyoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_subyoff_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_subyoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_subyoff",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_subyoff_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_subyoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supxsize_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supxsize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supxsize",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_supxsize",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supxsize_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_supxsize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supxsize_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supxsize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supxsize",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supxsize_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_supxsize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supysize_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supysize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supysize",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_supysize",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supysize_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_supysize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supysize_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supysize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supysize",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supysize_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_supysize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supxoff_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supxoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supxoff",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_supxoff",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supxoff_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_supxoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supxoff_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supxoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supxoff",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supxoff_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_supxoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supyoff_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supyoff",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supyoff",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_supyoff",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supyoff_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_supyoff = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_supyoff_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_supyoff",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_supyoff",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_supyoff_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_supyoff);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_strikeysize_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_strikeysize",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_strikeysize",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_strikeysize",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_strikeysize_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_strikeysize = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_strikeysize_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_strikeysize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_strikeysize",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_strikeysize_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_strikeysize);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_strikeypos_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_strikeypos",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_strikeypos",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_strikeypos",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_strikeypos_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_strikeypos = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_strikeypos_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_strikeypos",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_strikeypos",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_strikeypos_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_strikeypos);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_vendor_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_vendor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_vendor",1,"SplineFont_pfminfo *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_vendor",2,"char [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_vendor_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->os2_vendor, (const char *)arg2, 4-1);
      arg1->os2_vendor[4-1] = 0;
    } else {
      arg1->os2_vendor[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_vendor_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_vendor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_vendor",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_vendor_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (char *)(char *) ((arg1)->os2_vendor);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_family_class_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_family_class",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_family_class",1,"SplineFont_pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont_pfminfo::os2_family_class",2,"int16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_family_class_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  arg2 = (int16)lua_tonumber(L, 2);
  if (arg1) (arg1)->os2_family_class = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_os2_family_class_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  int16 result;
  
  SWIG_check_num_args("SplineFont_pfminfo::os2_family_class",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::os2_family_class",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_os2_family_class_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (int16) ((arg1)->os2_family_class);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_codepages_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  uint32 *arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::codepages",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::codepages",1,"SplineFont_pfminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_pfminfo::codepages",2,"uint32 [2]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_codepages_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_codepages_set",2,SWIGTYPE_p_unsigned_int);
  }
  
  {
    size_t ii;
    uint32 *b = (uint32 *) arg1->codepages;
    for (ii = 0; ii < (size_t)2; ii++) b[ii] = *((uint32 *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_codepages_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::codepages",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::codepages",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_codepages_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (uint32 *)(uint32 *) ((arg1)->codepages);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_unicoderanges_set(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  uint32 *arg2 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::unicoderanges",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::unicoderanges",1,"SplineFont_pfminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFont_pfminfo::unicoderanges",2,"uint32 [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_unicoderanges_set",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_unicoderanges_set",2,SWIGTYPE_p_unsigned_int);
  }
  
  {
    size_t ii;
    uint32 *b = (uint32 *) arg1->unicoderanges;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((uint32 *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont_pfminfo_unicoderanges_get(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) 0 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::unicoderanges",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont_pfminfo::unicoderanges",1,"SplineFont_pfminfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_SplineFont_pfminfo,0))){
    SWIG_fail_ptr("SplineFont_pfminfo_unicoderanges_get",1,SWIGTYPE_p_SplineFont_pfminfo);
  }
  
  result = (uint32 *)(uint32 *) ((arg1)->unicoderanges);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineFont_pfminfo(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont_pfminfo *result = 0 ;
  
  SWIG_check_num_args("SplineFont_pfminfo::SplineFont_pfminfo",0,0)
  result = (SplineFont_pfminfo *)calloc(1, sizeof(SplineFont_pfminfo));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_SplineFont_pfminfo,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_SplineFont_pfminfo(void *obj) {
SplineFont_pfminfo *arg1 = (SplineFont_pfminfo *) obj;
free((char *) arg1);
}
static swig_lua_method swig_SplineFont_pfminfo_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_SplineFont_pfminfo_attributes[] = {
    { "pfmset", _wrap_SplineFont_pfminfo_pfmset_get, _wrap_SplineFont_pfminfo_pfmset_set},
    { "winascent_add", _wrap_SplineFont_pfminfo_winascent_add_get, _wrap_SplineFont_pfminfo_winascent_add_set},
    { "windescent_add", _wrap_SplineFont_pfminfo_windescent_add_get, _wrap_SplineFont_pfminfo_windescent_add_set},
    { "hheadascent_add", _wrap_SplineFont_pfminfo_hheadascent_add_get, _wrap_SplineFont_pfminfo_hheadascent_add_set},
    { "hheaddescent_add", _wrap_SplineFont_pfminfo_hheaddescent_add_get, _wrap_SplineFont_pfminfo_hheaddescent_add_set},
    { "typoascent_add", _wrap_SplineFont_pfminfo_typoascent_add_get, _wrap_SplineFont_pfminfo_typoascent_add_set},
    { "typodescent_add", _wrap_SplineFont_pfminfo_typodescent_add_get, _wrap_SplineFont_pfminfo_typodescent_add_set},
    { "subsuper_set", _wrap_SplineFont_pfminfo_subsuper_set_get, _wrap_SplineFont_pfminfo_subsuper_set_set},
    { "panose_set", _wrap_SplineFont_pfminfo_panose_set_get, _wrap_SplineFont_pfminfo_panose_set_set},
    { "hheadset", _wrap_SplineFont_pfminfo_hheadset_get, _wrap_SplineFont_pfminfo_hheadset_set},
    { "vheadset", _wrap_SplineFont_pfminfo_vheadset_get, _wrap_SplineFont_pfminfo_vheadset_set},
    { "hascodepages", _wrap_SplineFont_pfminfo_hascodepages_get, _wrap_SplineFont_pfminfo_hascodepages_set},
    { "hasunicoderanges", _wrap_SplineFont_pfminfo_hasunicoderanges_get, _wrap_SplineFont_pfminfo_hasunicoderanges_set},
    { "pfmfamily", _wrap_SplineFont_pfminfo_pfmfamily_get, _wrap_SplineFont_pfminfo_pfmfamily_set},
    { "weight", _wrap_SplineFont_pfminfo_weight_get, _wrap_SplineFont_pfminfo_weight_set},
    { "width", _wrap_SplineFont_pfminfo_width_get, _wrap_SplineFont_pfminfo_width_set},
    { "panose", _wrap_SplineFont_pfminfo_panose_get, _wrap_SplineFont_pfminfo_panose_set},
    { "fstype", _wrap_SplineFont_pfminfo_fstype_get, _wrap_SplineFont_pfminfo_fstype_set},
    { "linegap", _wrap_SplineFont_pfminfo_linegap_get, _wrap_SplineFont_pfminfo_linegap_set},
    { "vlinegap", _wrap_SplineFont_pfminfo_vlinegap_get, _wrap_SplineFont_pfminfo_vlinegap_set},
    { "hhead_ascent", _wrap_SplineFont_pfminfo_hhead_ascent_get, _wrap_SplineFont_pfminfo_hhead_ascent_set},
    { "hhead_descent", _wrap_SplineFont_pfminfo_hhead_descent_get, _wrap_SplineFont_pfminfo_hhead_descent_set},
    { "os2_typoascent", _wrap_SplineFont_pfminfo_os2_typoascent_get, _wrap_SplineFont_pfminfo_os2_typoascent_set},
    { "os2_typodescent", _wrap_SplineFont_pfminfo_os2_typodescent_get, _wrap_SplineFont_pfminfo_os2_typodescent_set},
    { "os2_typolinegap", _wrap_SplineFont_pfminfo_os2_typolinegap_get, _wrap_SplineFont_pfminfo_os2_typolinegap_set},
    { "os2_winascent", _wrap_SplineFont_pfminfo_os2_winascent_get, _wrap_SplineFont_pfminfo_os2_winascent_set},
    { "os2_windescent", _wrap_SplineFont_pfminfo_os2_windescent_get, _wrap_SplineFont_pfminfo_os2_windescent_set},
    { "os2_subxsize", _wrap_SplineFont_pfminfo_os2_subxsize_get, _wrap_SplineFont_pfminfo_os2_subxsize_set},
    { "os2_subysize", _wrap_SplineFont_pfminfo_os2_subysize_get, _wrap_SplineFont_pfminfo_os2_subysize_set},
    { "os2_subxoff", _wrap_SplineFont_pfminfo_os2_subxoff_get, _wrap_SplineFont_pfminfo_os2_subxoff_set},
    { "os2_subyoff", _wrap_SplineFont_pfminfo_os2_subyoff_get, _wrap_SplineFont_pfminfo_os2_subyoff_set},
    { "os2_supxsize", _wrap_SplineFont_pfminfo_os2_supxsize_get, _wrap_SplineFont_pfminfo_os2_supxsize_set},
    { "os2_supysize", _wrap_SplineFont_pfminfo_os2_supysize_get, _wrap_SplineFont_pfminfo_os2_supysize_set},
    { "os2_supxoff", _wrap_SplineFont_pfminfo_os2_supxoff_get, _wrap_SplineFont_pfminfo_os2_supxoff_set},
    { "os2_supyoff", _wrap_SplineFont_pfminfo_os2_supyoff_get, _wrap_SplineFont_pfminfo_os2_supyoff_set},
    { "os2_strikeysize", _wrap_SplineFont_pfminfo_os2_strikeysize_get, _wrap_SplineFont_pfminfo_os2_strikeysize_set},
    { "os2_strikeypos", _wrap_SplineFont_pfminfo_os2_strikeypos_get, _wrap_SplineFont_pfminfo_os2_strikeypos_set},
    { "os2_vendor", _wrap_SplineFont_pfminfo_os2_vendor_get, _wrap_SplineFont_pfminfo_os2_vendor_set},
    { "os2_family_class", _wrap_SplineFont_pfminfo_os2_family_class_get, _wrap_SplineFont_pfminfo_os2_family_class_set},
    { "codepages", _wrap_SplineFont_pfminfo_codepages_get, _wrap_SplineFont_pfminfo_codepages_set},
    { "unicoderanges", _wrap_SplineFont_pfminfo_unicoderanges_get, _wrap_SplineFont_pfminfo_unicoderanges_set},
    {0,0,0}
};
static swig_lua_class *swig_SplineFont_pfminfo_bases[] = {0};
static const char *swig_SplineFont_pfminfo_base_names[] = {0};
static swig_lua_class _wrap_class_SplineFont_pfminfo = { "SplineFont_pfminfo", &SWIGTYPE_p_SplineFont_pfminfo,_wrap_new_SplineFont_pfminfo, swig_delete_SplineFont_pfminfo, swig_SplineFont_pfminfo_methods, swig_SplineFont_pfminfo_attributes, swig_SplineFont_pfminfo_bases, swig_SplineFont_pfminfo_base_names };

static int _wrap_MMSet_axis_count_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("mmset::axis_count",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::axis_count",1,"struct mmset *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mmset::axis_count",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_axis_count_set",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->axis_count = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axis_count_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  int result;
  
  SWIG_check_num_args("mmset::axis_count",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::axis_count",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_axis_count_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (int) ((arg1)->axis_count);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  char **arg2 ;
  
  SWIG_check_num_args("mmset::axes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::axes",1,"struct mmset *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mmset::axes",2,"char *[4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_axes_set",1,SWIGTYPE_p_mmset);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("MMSet_axes_set",2,SWIGTYPE_p_p_char);
  }
  
  {
    size_t ii;
    char * *b = (char * *) arg1->axes;
    for (ii = 0; ii < (size_t)4; ii++) b[ii] = *((char * *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("mmset::axes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::axes",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_axes_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (char **)(char **) ((arg1)->axes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_instance_count_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("mmset::instance_count",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::instance_count",1,"struct mmset *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mmset::instance_count",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_instance_count_set",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->instance_count = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_instance_count_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  int result;
  
  SWIG_check_num_args("mmset::instance_count",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::instance_count",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_instance_count_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (int) ((arg1)->instance_count);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_instances_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  SplineFont **arg2 = (SplineFont **) 0 ;
  
  SWIG_check_num_args("mmset::instances",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::instances",1,"struct mmset *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mmset::instances",2,"SplineFont **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_instances_set",1,SWIGTYPE_p_mmset);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_splinefont,0))){
    SWIG_fail_ptr("MMSet_instances_set",2,SWIGTYPE_p_p_splinefont);
  }
  
  if (arg1) (arg1)->instances = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_instances_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  SplineFont **result = 0 ;
  
  SWIG_check_num_args("mmset::instances",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::instances",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_instances_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (SplineFont **) ((arg1)->instances);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_normal_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("mmset::normal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::normal",1,"struct mmset *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mmset::normal",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_normal_set",1,SWIGTYPE_p_mmset);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_normal_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->normal = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_normal_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("mmset::normal",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::normal",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_normal_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (SplineFont *) ((arg1)->normal);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_positions_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  float *arg2 = (float *) 0 ;
  
  SWIG_check_num_args("mmset::positions",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::positions",1,"struct mmset *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mmset::positions",2,"float *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_positions_set",1,SWIGTYPE_p_mmset);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_positions_set",2,SWIGTYPE_p_float);
  }
  
  if (arg1) (arg1)->positions = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_positions_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("mmset::positions",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::positions",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_positions_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (float *) ((arg1)->positions);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_defweights_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  float *arg2 = (float *) 0 ;
  
  SWIG_check_num_args("mmset::defweights",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::defweights",1,"struct mmset *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("mmset::defweights",2,"float *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_defweights_set",1,SWIGTYPE_p_mmset);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_defweights_set",2,SWIGTYPE_p_float);
  }
  
  if (arg1) (arg1)->defweights = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_defweights_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("mmset::defweights",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::defweights",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_defweights_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (float *) ((arg1)->defweights);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_cdv_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("mmset::cdv",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::cdv",1,"struct mmset *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("mmset::cdv",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_cdv_set",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->cdv);
    if (arg2) {
      arg1->cdv = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->cdv, (const char *)arg2);
    } else {
      arg1->cdv = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_cdv_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("mmset::cdv",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::cdv",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_cdv_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (char *) ((arg1)->cdv);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_ndv_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("mmset::ndv",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::ndv",1,"struct mmset *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("mmset::ndv",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_ndv_set",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->ndv);
    if (arg2) {
      arg1->ndv = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->ndv, (const char *)arg2);
    } else {
      arg1->ndv = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_ndv_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("mmset::ndv",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::ndv",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_ndv_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (char *) ((arg1)->ndv);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_named_instance_count_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("mmset::named_instance_count",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::named_instance_count",1,"struct mmset *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mmset::named_instance_count",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_named_instance_count_set",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->named_instance_count = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_named_instance_count_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  int result;
  
  SWIG_check_num_args("mmset::named_instance_count",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::named_instance_count",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_named_instance_count_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (int) ((arg1)->named_instance_count);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_changed_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("mmset::changed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::changed",1,"struct mmset *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mmset::changed",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_changed_set",1,SWIGTYPE_p_mmset);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->changed = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_changed_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("mmset::changed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::changed",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_changed_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (unsigned int) ((arg1)->changed);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_apple_set(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("mmset::apple",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::apple",1,"struct mmset *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("mmset::apple",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_apple_set",1,SWIGTYPE_p_mmset);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->apple = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_apple_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("mmset::apple",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::apple",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_apple_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (unsigned int) ((arg1)->apple);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  MMSet_axismaps *result = 0 ;
  
  SWIG_check_num_args("mmset::axismaps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::axismaps",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_axismaps_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (MMSet_axismaps *) ((arg1)->axismaps);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MMSet_axismaps,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_named_instances_get(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *arg1 = (struct mmset *) 0 ;
  MMSet_named_instances *result = 0 ;
  
  SWIG_check_num_args("mmset::named_instances",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("mmset::named_instances",1,"struct mmset *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSet_named_instances_get",1,SWIGTYPE_p_mmset);
  }
  
  result = (MMSet_named_instances *) ((arg1)->named_instances);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MMSet_named_instances,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MMSet(lua_State* L) {
  int SWIG_arg = 0;
  struct mmset *result = 0 ;
  
  SWIG_check_num_args("mmset::mmset",0,0)
  result = (struct mmset *)calloc(1, sizeof(struct mmset));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mmset,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MMSet(void *obj) {
struct mmset *arg1 = (struct mmset *) obj;
free((char *) arg1);
}
static swig_lua_method swig_mmset_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_mmset_attributes[] = {
    { "axis_count", _wrap_MMSet_axis_count_get, _wrap_MMSet_axis_count_set},
    { "axes", _wrap_MMSet_axes_get, _wrap_MMSet_axes_set},
    { "instance_count", _wrap_MMSet_instance_count_get, _wrap_MMSet_instance_count_set},
    { "instances", _wrap_MMSet_instances_get, _wrap_MMSet_instances_set},
    { "normal", _wrap_MMSet_normal_get, _wrap_MMSet_normal_set},
    { "positions", _wrap_MMSet_positions_get, _wrap_MMSet_positions_set},
    { "defweights", _wrap_MMSet_defweights_get, _wrap_MMSet_defweights_set},
    { "cdv", _wrap_MMSet_cdv_get, _wrap_MMSet_cdv_set},
    { "ndv", _wrap_MMSet_ndv_get, _wrap_MMSet_ndv_set},
    { "named_instance_count", _wrap_MMSet_named_instance_count_get, _wrap_MMSet_named_instance_count_set},
    { "changed", _wrap_MMSet_changed_get, _wrap_MMSet_changed_set},
    { "apple", _wrap_MMSet_apple_get, _wrap_MMSet_apple_set},
    { "axismaps", _wrap_MMSet_axismaps_get, SWIG_Lua_set_immutable},
    { "named_instances", _wrap_MMSet_named_instances_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_mmset_bases[] = {0};
static const char *swig_mmset_base_names[] = {0};
static swig_lua_class _wrap_class_mmset = { "MMSet", &SWIGTYPE_p_mmset,_wrap_new_MMSet, swig_delete_MMSet, swig_mmset_methods, swig_mmset_attributes, swig_mmset_bases, swig_mmset_base_names };

static int _wrap_MMSet_named_instances_coords_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_named_instances *arg1 = (MMSet_named_instances *) 0 ;
  float *arg2 = (float *) 0 ;
  
  SWIG_check_num_args("MMSet_named_instances::coords",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_named_instances::coords",1,"MMSet_named_instances *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MMSet_named_instances::coords",2,"float *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_named_instances,0))){
    SWIG_fail_ptr("MMSet_named_instances_coords_set",1,SWIGTYPE_p_MMSet_named_instances);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_named_instances_coords_set",2,SWIGTYPE_p_float);
  }
  
  if (arg1) (arg1)->coords = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_named_instances_coords_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_named_instances *arg1 = (MMSet_named_instances *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("MMSet_named_instances::coords",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_named_instances::coords",1,"MMSet_named_instances *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_named_instances,0))){
    SWIG_fail_ptr("MMSet_named_instances_coords_get",1,SWIGTYPE_p_MMSet_named_instances);
  }
  
  result = (float *) ((arg1)->coords);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_named_instances_names_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_named_instances *arg1 = (MMSet_named_instances *) 0 ;
  struct macname *arg2 = (struct macname *) 0 ;
  
  SWIG_check_num_args("MMSet_named_instances::names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_named_instances::names",1,"MMSet_named_instances *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MMSet_named_instances::names",2,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_named_instances,0))){
    SWIG_fail_ptr("MMSet_named_instances_names_set",1,SWIGTYPE_p_MMSet_named_instances);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_named_instances_names_set",2,SWIGTYPE_p_macname);
  }
  
  if (arg1) (arg1)->names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_named_instances_names_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_named_instances *arg1 = (MMSet_named_instances *) 0 ;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("MMSet_named_instances::names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_named_instances::names",1,"MMSet_named_instances *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_named_instances,0))){
    SWIG_fail_ptr("MMSet_named_instances_names_get",1,SWIGTYPE_p_MMSet_named_instances);
  }
  
  result = (struct macname *) ((arg1)->names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MMSet_named_instances(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_named_instances *result = 0 ;
  
  SWIG_check_num_args("MMSet_named_instances::MMSet_named_instances",0,0)
  result = (MMSet_named_instances *)calloc(1, sizeof(MMSet_named_instances));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MMSet_named_instances,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MMSet_named_instances(void *obj) {
MMSet_named_instances *arg1 = (MMSet_named_instances *) obj;
free((char *) arg1);
}
static swig_lua_method swig_MMSet_named_instances_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_MMSet_named_instances_attributes[] = {
    { "coords", _wrap_MMSet_named_instances_coords_get, _wrap_MMSet_named_instances_coords_set},
    { "names", _wrap_MMSet_named_instances_names_get, _wrap_MMSet_named_instances_names_set},
    {0,0,0}
};
static swig_lua_class *swig_MMSet_named_instances_bases[] = {0};
static const char *swig_MMSet_named_instances_base_names[] = {0};
static swig_lua_class _wrap_class_MMSet_named_instances = { "MMSet_named_instances", &SWIGTYPE_p_MMSet_named_instances,_wrap_new_MMSet_named_instances, swig_delete_MMSet_named_instances, swig_MMSet_named_instances_methods, swig_MMSet_named_instances_attributes, swig_MMSet_named_instances_bases, swig_MMSet_named_instances_base_names };

static int _wrap_MMSet_axismaps_points_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("MMSet_axismaps::points",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::points",1,"MMSet_axismaps *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMSet_axismaps::points",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_points_set",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->points = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_points_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  int result;
  
  SWIG_check_num_args("MMSet_axismaps::points",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::points",1,"MMSet_axismaps *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_points_get",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  result = (int) ((arg1)->points);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_blends_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float *arg2 = (float *) 0 ;
  
  SWIG_check_num_args("MMSet_axismaps::blends",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::blends",1,"MMSet_axismaps *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MMSet_axismaps::blends",2,"float *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_blends_set",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_axismaps_blends_set",2,SWIGTYPE_p_float);
  }
  
  if (arg1) (arg1)->blends = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_blends_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("MMSet_axismaps::blends",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::blends",1,"MMSet_axismaps *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_blends_get",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  result = (float *) ((arg1)->blends);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_designs_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float *arg2 = (float *) 0 ;
  
  SWIG_check_num_args("MMSet_axismaps::designs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::designs",1,"MMSet_axismaps *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MMSet_axismaps::designs",2,"float *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_designs_set",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_axismaps_designs_set",2,SWIGTYPE_p_float);
  }
  
  if (arg1) (arg1)->designs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_designs_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("MMSet_axismaps::designs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::designs",1,"MMSet_axismaps *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_designs_get",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  result = (float *) ((arg1)->designs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_min_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("MMSet_axismaps::min",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::min",1,"MMSet_axismaps *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMSet_axismaps::min",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_min_set",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->min = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_min_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float result;
  
  SWIG_check_num_args("MMSet_axismaps::min",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::min",1,"MMSet_axismaps *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_min_get",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  result = (float) ((arg1)->min);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_def_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("MMSet_axismaps::def",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::def",1,"MMSet_axismaps *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMSet_axismaps::def",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_def_set",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->def = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_def_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float result;
  
  SWIG_check_num_args("MMSet_axismaps::def",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::def",1,"MMSet_axismaps *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_def_get",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  result = (float) ((arg1)->def);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_max_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("MMSet_axismaps::max",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::max",1,"MMSet_axismaps *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMSet_axismaps::max",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_max_set",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->max = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_max_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  float result;
  
  SWIG_check_num_args("MMSet_axismaps::max",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::max",1,"MMSet_axismaps *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_max_get",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  result = (float) ((arg1)->max);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_axisnames_set(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  struct macname *arg2 = (struct macname *) 0 ;
  
  SWIG_check_num_args("MMSet_axismaps::axisnames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::axisnames",1,"MMSet_axismaps *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MMSet_axismaps::axisnames",2,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_axisnames_set",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macname,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("MMSet_axismaps_axisnames_set",2,SWIGTYPE_p_macname);
  }
  
  if (arg1) (arg1)->axisnames = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSet_axismaps_axisnames_get(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *arg1 = (MMSet_axismaps *) 0 ;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("MMSet_axismaps::axisnames",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSet_axismaps::axisnames",1,"MMSet_axismaps *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MMSet_axismaps,0))){
    SWIG_fail_ptr("MMSet_axismaps_axisnames_get",1,SWIGTYPE_p_MMSet_axismaps);
  }
  
  result = (struct macname *) ((arg1)->axisnames);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_MMSet_axismaps(lua_State* L) {
  int SWIG_arg = 0;
  MMSet_axismaps *result = 0 ;
  
  SWIG_check_num_args("MMSet_axismaps::MMSet_axismaps",0,0)
  result = (MMSet_axismaps *)calloc(1, sizeof(MMSet_axismaps));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MMSet_axismaps,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_MMSet_axismaps(void *obj) {
MMSet_axismaps *arg1 = (MMSet_axismaps *) obj;
free((char *) arg1);
}
static swig_lua_method swig_MMSet_axismaps_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_MMSet_axismaps_attributes[] = {
    { "points", _wrap_MMSet_axismaps_points_get, _wrap_MMSet_axismaps_points_set},
    { "blends", _wrap_MMSet_axismaps_blends_get, _wrap_MMSet_axismaps_blends_set},
    { "designs", _wrap_MMSet_axismaps_designs_get, _wrap_MMSet_axismaps_designs_set},
    { "min", _wrap_MMSet_axismaps_min_get, _wrap_MMSet_axismaps_min_set},
    { "def", _wrap_MMSet_axismaps_def_get, _wrap_MMSet_axismaps_def_set},
    { "max", _wrap_MMSet_axismaps_max_get, _wrap_MMSet_axismaps_max_set},
    { "axisnames", _wrap_MMSet_axismaps_axisnames_get, _wrap_MMSet_axismaps_axisnames_set},
    {0,0,0}
};
static swig_lua_class *swig_MMSet_axismaps_bases[] = {0};
static const char *swig_MMSet_axismaps_base_names[] = {0};
static swig_lua_class _wrap_class_MMSet_axismaps = { "MMSet_axismaps", &SWIGTYPE_p_MMSet_axismaps,_wrap_new_MMSet_axismaps, swig_delete_MMSet_axismaps, swig_MMSet_axismaps_methods, swig_MMSet_axismaps_attributes, swig_MMSet_axismaps_bases, swig_MMSet_axismaps_base_names };

static int _wrap_sflist_sf_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("sflist::sf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::sf",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::sf",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_sf_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sflist_sf_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->sf = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_sf_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("sflist::sf",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::sf",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_sf_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (SplineFont *) ((arg1)->sf);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_sizes_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int32 *arg2 = (int32 *) 0 ;
  
  SWIG_check_num_args("sflist::sizes",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::sizes",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::sizes",2,"int32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_sizes_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sflist_sizes_set",2,SWIGTYPE_p_int);
  }
  
  if (arg1) (arg1)->sizes = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_sizes_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int32 *result = 0 ;
  
  SWIG_check_num_args("sflist::sizes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::sizes",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_sizes_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (int32 *) ((arg1)->sizes);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_tempttf_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  
  SWIG_check_num_args("sflist::tempttf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::tempttf",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::tempttf",2,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_tempttf_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sflist_tempttf_set",2,SWIGTYPE_p_FILE);
  }
  
  if (arg1) (arg1)->tempttf = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_tempttf_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  FILE *result = 0 ;
  
  SWIG_check_num_args("sflist::tempttf",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::tempttf",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_tempttf_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (FILE *) ((arg1)->tempttf);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FILE,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_id_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sflist::id",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::id",1,"struct sflist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sflist::id",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_id_set",1,SWIGTYPE_p_sflist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->id = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_id_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int result;
  
  SWIG_check_num_args("sflist::id",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::id",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_id_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (int) ((arg1)->id);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_ids_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int *arg2 = (int *) 0 ;
  
  SWIG_check_num_args("sflist::ids",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::ids",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::ids",2,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_ids_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sflist_ids_set",2,SWIGTYPE_p_int);
  }
  
  if (arg1) (arg1)->ids = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_ids_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int *result = 0 ;
  
  SWIG_check_num_args("sflist::ids",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::ids",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_ids_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (int *) ((arg1)->ids);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_bdfs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  BDFFont **arg2 = (BDFFont **) 0 ;
  
  SWIG_check_num_args("sflist::bdfs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::bdfs",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::bdfs",2,"BDFFont **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_bdfs_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_bdffont,0))){
    SWIG_fail_ptr("sflist_bdfs_set",2,SWIGTYPE_p_p_bdffont);
  }
  
  if (arg1) (arg1)->bdfs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_bdfs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  BDFFont **result = 0 ;
  
  SWIG_check_num_args("sflist::bdfs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::bdfs",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_bdfs_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (BDFFont **) ((arg1)->bdfs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_map_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  
  SWIG_check_num_args("sflist::map",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::map",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::map",2,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_map_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sflist_map_set",2,SWIGTYPE_p_encmap);
  }
  
  if (arg1) (arg1)->map = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_map_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  EncMap *result = 0 ;
  
  SWIG_check_num_args("sflist::map",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::map",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_map_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (EncMap *) ((arg1)->map);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_next_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  struct sflist *arg2 = (struct sflist *) 0 ;
  
  SWIG_check_num_args("sflist::next",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::next",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::next",2,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_next_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_sflist,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sflist_next_set",2,SWIGTYPE_p_sflist);
  }
  
  if (arg1) (arg1)->next = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_next_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  struct sflist *result = 0 ;
  
  SWIG_check_num_args("sflist::next",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::next",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_next_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (struct sflist *) ((arg1)->next);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sflist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_former_names_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("sflist::former_names",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::former_names",1,"struct sflist *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sflist::former_names",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_former_names_set",1,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("sflist_former_names_set",2,SWIGTYPE_p_p_char);
  }
  
  if (arg1) (arg1)->former_names = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_former_names_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("sflist::former_names",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::former_names",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_former_names_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (char **) ((arg1)->former_names);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_len_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sflist::len",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::len",1,"struct sflist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sflist::len",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_len_set",1,SWIGTYPE_p_sflist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->len = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sflist_len_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  int result;
  
  SWIG_check_num_args("sflist::len",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sflist::len",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("sflist_len_get",1,SWIGTYPE_p_sflist);
  }
  
  result = (int) ((arg1)->len);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_sflist(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *result = 0 ;
  
  SWIG_check_num_args("sflist::sflist",0,0)
  result = (struct sflist *)calloc(1, sizeof(struct sflist));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sflist,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_sflist(void *obj) {
struct sflist *arg1 = (struct sflist *) obj;
free((char *) arg1);
}
static swig_lua_method swig_sflist_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_sflist_attributes[] = {
    { "sf", _wrap_sflist_sf_get, _wrap_sflist_sf_set},
    { "sizes", _wrap_sflist_sizes_get, _wrap_sflist_sizes_set},
    { "tempttf", _wrap_sflist_tempttf_get, _wrap_sflist_tempttf_set},
    { "id", _wrap_sflist_id_get, _wrap_sflist_id_set},
    { "ids", _wrap_sflist_ids_get, _wrap_sflist_ids_set},
    { "bdfs", _wrap_sflist_bdfs_get, _wrap_sflist_bdfs_set},
    { "map", _wrap_sflist_map_get, _wrap_sflist_map_set},
    { "next", _wrap_sflist_next_get, _wrap_sflist_next_set},
    { "former_names", _wrap_sflist_former_names_get, _wrap_sflist_former_names_set},
    { "len", _wrap_sflist_len_get, _wrap_sflist_len_set},
    {0,0,0}
};
static swig_lua_class *swig_sflist_bases[] = {0};
static const char *swig_sflist_base_names[] = {0};
static swig_lua_class _wrap_class_sflist = { "sflist", &SWIGTYPE_p_sflist,_wrap_new_sflist, swig_delete_sflist, swig_sflist_methods, swig_sflist_attributes, swig_sflist_bases, swig_sflist_base_names };

static int _wrap_AnchorPos_sc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("anchorpos::sc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::sc",1,"struct anchorpos *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorpos::sc",2,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_sc_set",1,SWIGTYPE_p_anchorpos);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("AnchorPos_sc_set",2,SWIGTYPE_p_splinechar);
  }
  
  if (arg1) (arg1)->sc = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_sc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("anchorpos::sc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::sc",1,"struct anchorpos *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_sc_get",1,SWIGTYPE_p_anchorpos);
  }
  
  result = (SplineChar *) ((arg1)->sc);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_x_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("anchorpos::x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::x",1,"struct anchorpos *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpos::x",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_x_set",1,SWIGTYPE_p_anchorpos);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_x_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  int result;
  
  SWIG_check_num_args("anchorpos::x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::x",1,"struct anchorpos *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_x_get",1,SWIGTYPE_p_anchorpos);
  }
  
  result = (int) ((arg1)->x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_y_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("anchorpos::y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::y",1,"struct anchorpos *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpos::y",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_y_set",1,SWIGTYPE_p_anchorpos);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_y_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  int result;
  
  SWIG_check_num_args("anchorpos::y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::y",1,"struct anchorpos *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_y_get",1,SWIGTYPE_p_anchorpos);
  }
  
  result = (int) ((arg1)->y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_apm_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  AnchorPoint *arg2 = (AnchorPoint *) 0 ;
  
  SWIG_check_num_args("anchorpos::apm",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::apm",1,"struct anchorpos *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorpos::apm",2,"AnchorPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_apm_set",1,SWIGTYPE_p_anchorpos);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorpoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("AnchorPos_apm_set",2,SWIGTYPE_p_anchorpoint);
  }
  
  if (arg1) (arg1)->apm = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_apm_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  AnchorPoint *result = 0 ;
  
  SWIG_check_num_args("anchorpos::apm",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::apm",1,"struct anchorpos *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_apm_get",1,SWIGTYPE_p_anchorpos);
  }
  
  result = (AnchorPoint *) ((arg1)->apm);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_apb_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  AnchorPoint *arg2 = (AnchorPoint *) 0 ;
  
  SWIG_check_num_args("anchorpos::apb",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::apb",1,"struct anchorpos *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("anchorpos::apb",2,"AnchorPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_apb_set",1,SWIGTYPE_p_anchorpos);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorpoint,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("AnchorPos_apb_set",2,SWIGTYPE_p_anchorpoint);
  }
  
  if (arg1) (arg1)->apb = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_apb_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  AnchorPoint *result = 0 ;
  
  SWIG_check_num_args("anchorpos::apb",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::apb",1,"struct anchorpos *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_apb_get",1,SWIGTYPE_p_anchorpos);
  }
  
  result = (AnchorPoint *) ((arg1)->apb);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_base_index_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("anchorpos::base_index",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::base_index",1,"struct anchorpos *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpos::base_index",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_base_index_set",1,SWIGTYPE_p_anchorpos);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->base_index = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_base_index_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  int result;
  
  SWIG_check_num_args("anchorpos::base_index",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::base_index",1,"struct anchorpos *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_base_index_get",1,SWIGTYPE_p_anchorpos);
  }
  
  result = (int) ((arg1)->base_index);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_ticked_set(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  unsigned int arg2 ;
  
  SWIG_check_num_args("anchorpos::ticked",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::ticked",1,"struct anchorpos *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("anchorpos::ticked",2,"unsigned int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_ticked_set",1,SWIGTYPE_p_anchorpos);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (unsigned int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ticked = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPos_ticked_get(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *arg1 = (struct anchorpos *) 0 ;
  unsigned int result;
  
  SWIG_check_num_args("anchorpos::ticked",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("anchorpos::ticked",1,"struct anchorpos *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpos,0))){
    SWIG_fail_ptr("AnchorPos_ticked_get",1,SWIGTYPE_p_anchorpos);
  }
  
  result = (unsigned int) ((arg1)->ticked);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_AnchorPos(lua_State* L) {
  int SWIG_arg = 0;
  struct anchorpos *result = 0 ;
  
  SWIG_check_num_args("anchorpos::anchorpos",0,0)
  result = (struct anchorpos *)calloc(1, sizeof(struct anchorpos));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpos,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_AnchorPos(void *obj) {
struct anchorpos *arg1 = (struct anchorpos *) obj;
free((char *) arg1);
}
static swig_lua_method swig_anchorpos_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_anchorpos_attributes[] = {
    { "sc", _wrap_AnchorPos_sc_get, _wrap_AnchorPos_sc_set},
    { "x", _wrap_AnchorPos_x_get, _wrap_AnchorPos_x_set},
    { "y", _wrap_AnchorPos_y_get, _wrap_AnchorPos_y_set},
    { "apm", _wrap_AnchorPos_apm_get, _wrap_AnchorPos_apm_set},
    { "apb", _wrap_AnchorPos_apb_get, _wrap_AnchorPos_apb_set},
    { "base_index", _wrap_AnchorPos_base_index_get, _wrap_AnchorPos_base_index_set},
    { "ticked", _wrap_AnchorPos_ticked_get, _wrap_AnchorPos_ticked_set},
    {0,0,0}
};
static swig_lua_class *swig_anchorpos_bases[] = {0};
static const char *swig_anchorpos_base_names[] = {0};
static swig_lua_class _wrap_class_anchorpos = { "AnchorPos", &SWIGTYPE_p_anchorpos,_wrap_new_AnchorPos, swig_delete_AnchorPos, swig_anchorpos_methods, swig_anchorpos_attributes, swig_anchorpos_bases, swig_anchorpos_base_names };

static int _wrap_compressors_ext_set(lua_State* L) {
  int SWIG_arg = 0;
  struct compressors *arg1 = (struct compressors *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("compressors::ext",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compressors::ext",1,"struct compressors *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("compressors::ext",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_compressors,0))){
    SWIG_fail_ptr("compressors_ext_set",1,SWIGTYPE_p_compressors);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->ext);
    if (arg2) {
      arg1->ext = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->ext, (const char *)arg2);
    } else {
      arg1->ext = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_compressors_ext_get(lua_State* L) {
  int SWIG_arg = 0;
  struct compressors *arg1 = (struct compressors *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("compressors::ext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compressors::ext",1,"struct compressors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_compressors,0))){
    SWIG_fail_ptr("compressors_ext_get",1,SWIGTYPE_p_compressors);
  }
  
  result = (char *) ((arg1)->ext);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_compressors_decomp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct compressors *arg1 = (struct compressors *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("compressors::decomp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compressors::decomp",1,"struct compressors *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("compressors::decomp",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_compressors,0))){
    SWIG_fail_ptr("compressors_decomp_set",1,SWIGTYPE_p_compressors);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->decomp);
    if (arg2) {
      arg1->decomp = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->decomp, (const char *)arg2);
    } else {
      arg1->decomp = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_compressors_decomp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct compressors *arg1 = (struct compressors *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("compressors::decomp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compressors::decomp",1,"struct compressors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_compressors,0))){
    SWIG_fail_ptr("compressors_decomp_get",1,SWIGTYPE_p_compressors);
  }
  
  result = (char *) ((arg1)->decomp);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_compressors_recomp_set(lua_State* L) {
  int SWIG_arg = 0;
  struct compressors *arg1 = (struct compressors *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("compressors::recomp",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compressors::recomp",1,"struct compressors *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("compressors::recomp",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_compressors,0))){
    SWIG_fail_ptr("compressors_recomp_set",1,SWIGTYPE_p_compressors);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->recomp);
    if (arg2) {
      arg1->recomp = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->recomp, (const char *)arg2);
    } else {
      arg1->recomp = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_compressors_recomp_get(lua_State* L) {
  int SWIG_arg = 0;
  struct compressors *arg1 = (struct compressors *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("compressors::recomp",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("compressors::recomp",1,"struct compressors *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_compressors,0))){
    SWIG_fail_ptr("compressors_recomp_get",1,SWIGTYPE_p_compressors);
  }
  
  result = (char *) ((arg1)->recomp);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_compressors(lua_State* L) {
  int SWIG_arg = 0;
  struct compressors *result = 0 ;
  
  SWIG_check_num_args("compressors::compressors",0,0)
  result = (struct compressors *)calloc(1, sizeof(struct compressors));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_compressors,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_compressors(void *obj) {
struct compressors *arg1 = (struct compressors *) obj;
free((char *) arg1);
}
static swig_lua_method swig_compressors_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_compressors_attributes[] = {
    { "ext", _wrap_compressors_ext_get, _wrap_compressors_ext_set},
    { "decomp", _wrap_compressors_decomp_get, _wrap_compressors_decomp_set},
    { "recomp", _wrap_compressors_recomp_get, _wrap_compressors_recomp_set},
    {0,0,0}
};
static swig_lua_class *swig_compressors_bases[] = {0};
static const char *swig_compressors_base_names[] = {0};
static swig_lua_class _wrap_class_compressors = { "compressors", &SWIGTYPE_p_compressors,_wrap_new_compressors, swig_delete_compressors, swig_compressors_methods, swig_compressors_attributes, swig_compressors_bases, swig_compressors_base_names };

static int _wrap_archivers_ext_set(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("archivers::ext",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::ext",1,"struct archivers *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("archivers::ext",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_ext_set",1,SWIGTYPE_p_archivers);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->ext);
    if (arg2) {
      arg1->ext = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->ext, (const char *)arg2);
    } else {
      arg1->ext = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_ext_get(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("archivers::ext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::ext",1,"struct archivers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_ext_get",1,SWIGTYPE_p_archivers);
  }
  
  result = (char *) ((arg1)->ext);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_unarchive_set(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("archivers::unarchive",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::unarchive",1,"struct archivers *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("archivers::unarchive",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_unarchive_set",1,SWIGTYPE_p_archivers);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->unarchive);
    if (arg2) {
      arg1->unarchive = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->unarchive, (const char *)arg2);
    } else {
      arg1->unarchive = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_unarchive_get(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("archivers::unarchive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::unarchive",1,"struct archivers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_unarchive_get",1,SWIGTYPE_p_archivers);
  }
  
  result = (char *) ((arg1)->unarchive);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_archive_set(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("archivers::archive",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::archive",1,"struct archivers *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("archivers::archive",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_archive_set",1,SWIGTYPE_p_archivers);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->archive);
    if (arg2) {
      arg1->archive = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->archive, (const char *)arg2);
    } else {
      arg1->archive = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_archive_get(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("archivers::archive",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::archive",1,"struct archivers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_archive_get",1,SWIGTYPE_p_archivers);
  }
  
  result = (char *) ((arg1)->archive);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_listargs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("archivers::listargs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::listargs",1,"struct archivers *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("archivers::listargs",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_listargs_set",1,SWIGTYPE_p_archivers);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->listargs);
    if (arg2) {
      arg1->listargs = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->listargs, (const char *)arg2);
    } else {
      arg1->listargs = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_listargs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("archivers::listargs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::listargs",1,"struct archivers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_listargs_get",1,SWIGTYPE_p_archivers);
  }
  
  result = (char *) ((arg1)->listargs);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_extractargs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("archivers::extractargs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::extractargs",1,"struct archivers *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("archivers::extractargs",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_extractargs_set",1,SWIGTYPE_p_archivers);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->extractargs);
    if (arg2) {
      arg1->extractargs = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->extractargs, (const char *)arg2);
    } else {
      arg1->extractargs = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_extractargs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("archivers::extractargs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::extractargs",1,"struct archivers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_extractargs_get",1,SWIGTYPE_p_archivers);
  }
  
  result = (char *) ((arg1)->extractargs);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_appendargs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("archivers::appendargs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::appendargs",1,"struct archivers *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("archivers::appendargs",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_appendargs_set",1,SWIGTYPE_p_archivers);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->appendargs);
    if (arg2) {
      arg1->appendargs = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->appendargs, (const char *)arg2);
    } else {
      arg1->appendargs = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_appendargs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("archivers::appendargs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::appendargs",1,"struct archivers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_appendargs_get",1,SWIGTYPE_p_archivers);
  }
  
  result = (char *) ((arg1)->appendargs);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_ars_set(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  enum archive_list_style arg2 ;
  
  SWIG_check_num_args("archivers::ars",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::ars",1,"struct archivers *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("archivers::ars",2,"enum archive_list_style");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_ars_set",1,SWIGTYPE_p_archivers);
  }
  
  arg2 = (enum archive_list_style)(int)lua_tonumber(L, 2);
  if (arg1) (arg1)->ars = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_archivers_ars_get(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *arg1 = (struct archivers *) 0 ;
  enum archive_list_style result;
  
  SWIG_check_num_args("archivers::ars",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("archivers::ars",1,"struct archivers *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_archivers,0))){
    SWIG_fail_ptr("archivers_ars_get",1,SWIGTYPE_p_archivers);
  }
  
  result = (enum archive_list_style) ((arg1)->ars);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_archivers(lua_State* L) {
  int SWIG_arg = 0;
  struct archivers *result = 0 ;
  
  SWIG_check_num_args("archivers::archivers",0,0)
  result = (struct archivers *)calloc(1, sizeof(struct archivers));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_archivers,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_archivers(void *obj) {
struct archivers *arg1 = (struct archivers *) obj;
free((char *) arg1);
}
static swig_lua_method swig_archivers_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_archivers_attributes[] = {
    { "ext", _wrap_archivers_ext_get, _wrap_archivers_ext_set},
    { "unarchive", _wrap_archivers_unarchive_get, _wrap_archivers_unarchive_set},
    { "archive", _wrap_archivers_archive_get, _wrap_archivers_archive_set},
    { "listargs", _wrap_archivers_listargs_get, _wrap_archivers_listargs_set},
    { "extractargs", _wrap_archivers_extractargs_get, _wrap_archivers_extractargs_set},
    { "appendargs", _wrap_archivers_appendargs_get, _wrap_archivers_appendargs_set},
    { "ars", _wrap_archivers_ars_get, _wrap_archivers_ars_set},
    {0,0,0}
};
static swig_lua_class *swig_archivers_bases[] = {0};
static const char *swig_archivers_base_names[] = {0};
static swig_lua_class _wrap_class_archivers = { "archivers", &SWIGTYPE_p_archivers,_wrap_new_archivers, swig_delete_archivers, swig_archivers_methods, swig_archivers_attributes, swig_archivers_bases, swig_archivers_base_names };

static int _wrap_chunkalloc(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  void *result = 0 ;
  
  SWIG_check_num_args("chunkalloc",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("chunkalloc",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (void *)chunkalloc(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_chunkfree(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("chunkfree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("chunkfree",1,"void *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("chunkfree",2,"int");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"chunkfree");
  arg2 = (int)lua_tonumber(L, 2);
  chunkfree(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_strconcat(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("strconcat",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("strconcat",1,"char const *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("strconcat",2,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  result = (char *)strconcat((char const *)arg1,(char const *)arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_strconcat3(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("strconcat3",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("strconcat3",1,"char const *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("strconcat3",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("strconcat3",3,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (char *)strconcat3((char const *)arg1,(char const *)arg2,(char const *)arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_XUIDFromFD(lua_State* L) {
  int SWIG_arg = 0;
  int *arg1 ;
  char *result = 0 ;
  
  SWIG_check_num_args("XUIDFromFD",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("XUIDFromFD",1,"int [20]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("XUIDFromFD",1,SWIGTYPE_p_int);
  }
  
  result = (char *)XUIDFromFD(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontFromPSFont(lua_State* L) {
  int SWIG_arg = 0;
  struct fontdict *arg1 = (struct fontdict *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontFromPSFont",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontFromPSFont",1,"struct fontdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_fontdict,0))){
    SWIG_fail_ptr("SplineFontFromPSFont",1,SWIGTYPE_p_fontdict);
  }
  
  result = (SplineFont *)SplineFontFromPSFont(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CheckAfmOfPostScript(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("CheckAfmOfPostScript",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CheckAfmOfPostScript",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("CheckAfmOfPostScript",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("CheckAfmOfPostScript",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CheckAfmOfPostScript",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("CheckAfmOfPostScript",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)CheckAfmOfPostScript(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadKerningDataFromAmfm(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("LoadKerningDataFromAmfm",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadKerningDataFromAmfm",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadKerningDataFromAmfm",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LoadKerningDataFromAmfm",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LoadKerningDataFromAmfm",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("LoadKerningDataFromAmfm",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)LoadKerningDataFromAmfm(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadKerningDataFromAfm(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("LoadKerningDataFromAfm",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadKerningDataFromAfm",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadKerningDataFromAfm",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LoadKerningDataFromAfm",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LoadKerningDataFromAfm",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("LoadKerningDataFromAfm",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)LoadKerningDataFromAfm(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadKerningDataFromTfm(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("LoadKerningDataFromTfm",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadKerningDataFromTfm",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadKerningDataFromTfm",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LoadKerningDataFromTfm",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LoadKerningDataFromTfm",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("LoadKerningDataFromTfm",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)LoadKerningDataFromTfm(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadKerningDataFromOfm(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("LoadKerningDataFromOfm",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadKerningDataFromOfm",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadKerningDataFromOfm",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LoadKerningDataFromOfm",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LoadKerningDataFromOfm",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("LoadKerningDataFromOfm",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)LoadKerningDataFromOfm(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadKerningDataFromPfm(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("LoadKerningDataFromPfm",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadKerningDataFromPfm",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadKerningDataFromPfm",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LoadKerningDataFromPfm",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LoadKerningDataFromPfm",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("LoadKerningDataFromPfm",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)LoadKerningDataFromPfm(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadKerningDataFromMacFOND(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("LoadKerningDataFromMacFOND",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadKerningDataFromMacFOND",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadKerningDataFromMacFOND",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LoadKerningDataFromMacFOND",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LoadKerningDataFromMacFOND",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("LoadKerningDataFromMacFOND",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)LoadKerningDataFromMacFOND(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadKerningDataFromMetricsFile(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("LoadKerningDataFromMetricsFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LoadKerningDataFromMetricsFile",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadKerningDataFromMetricsFile",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LoadKerningDataFromMetricsFile",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LoadKerningDataFromMetricsFile",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("LoadKerningDataFromMetricsFile",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)LoadKerningDataFromMetricsFile(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatDumpFontLookups(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("FeatDumpFontLookups",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FeatDumpFontLookups",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FeatDumpFontLookups",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("FeatDumpFontLookups",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FeatDumpFontLookups",2,SWIGTYPE_p_splinefont);
  }
  
  FeatDumpFontLookups(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatDumpOneLookup(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  OTLookup *arg3 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("FeatDumpOneLookup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FeatDumpOneLookup",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FeatDumpOneLookup",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FeatDumpOneLookup",3,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("FeatDumpOneLookup",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FeatDumpOneLookup",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("FeatDumpOneLookup",3,SWIGTYPE_p_otlookup);
  }
  
  FeatDumpOneLookup(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFApplyFeatureFile(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  char *arg3 = (char *) 0 ;
  
  SWIG_check_num_args("SFApplyFeatureFile",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFApplyFeatureFile",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFApplyFeatureFile",2,"FILE *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFApplyFeatureFile",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFApplyFeatureFile",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SFApplyFeatureFile",2,SWIGTYPE_p_FILE);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  SFApplyFeatureFile(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFApplyFeatureFilename(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("SFApplyFeatureFilename",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFApplyFeatureFilename",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFApplyFeatureFilename",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFApplyFeatureFilename",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  SFApplyFeatureFilename(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SubsNew(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  enum possub_type arg2 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  SplineChar *arg5 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SubsNew",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SubsNew",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SubsNew",2,"enum possub_type");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SubsNew",3,"int");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SubsNew",4,"char *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("SubsNew",5,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SubsNew",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (enum possub_type)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SubsNew",5,SWIGTYPE_p_splinechar);
  }
  
  SubsNew(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PosNew(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  
  SWIG_check_num_args("PosNew",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PosNew",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PosNew",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PosNew",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("PosNew",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("PosNew",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("PosNew",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("PosNew",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  PosNew(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFOneWidth(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int result;
  
  SWIG_check_num_args("SFOneWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFOneWidth",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFOneWidth",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int)SFOneWidth(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CIDOneWidth(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int result;
  
  SWIG_check_num_args("CIDOneWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CIDOneWidth",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CIDOneWidth",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int)CIDOneWidth(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFOneHeight(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int result;
  
  SWIG_check_num_args("SFOneHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFOneHeight",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFOneHeight",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int)SFOneHeight(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFIsCJK(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("SFIsCJK",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFIsCJK",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFIsCJK",2,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFIsCJK",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFIsCJK",2,SWIGTYPE_p_encmap);
  }
  
  result = (int)SFIsCJK(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CIDMasterAsDes(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("CIDMasterAsDes",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CIDMasterAsDes",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CIDMasterAsDes",1,SWIGTYPE_p_splinefont);
  }
  
  CIDMasterAsDes(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CanWoff(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("CanWoff",0,0)
  result = (int)CanWoff();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont2ChrsSubrs(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  struct pschars *arg3 = (struct pschars *) 0 ;
  int arg4 ;
  enum fontformat arg5 ;
  int arg6 ;
  struct pschars *result = 0 ;
  
  SWIG_check_num_args("SplineFont2ChrsSubrs",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont2ChrsSubrs",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont2ChrsSubrs",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineFont2ChrsSubrs",3,"struct pschars *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineFont2ChrsSubrs",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplineFont2ChrsSubrs",5,"enum fontformat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SplineFont2ChrsSubrs",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont2ChrsSubrs",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("SplineFont2ChrsSubrs",3,SWIGTYPE_p_pschars);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (enum fontformat)(int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (struct pschars *)SplineFont2ChrsSubrs(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pschars,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CanonicalCombiner(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int result;
  
  SWIG_check_num_args("CanonicalCombiner",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("CanonicalCombiner",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (int)CanonicalCombiner(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBuf_pt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *arg1 = (struct growbuf *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  SWIG_check_num_args("growbuf::pt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("growbuf::pt",1,"struct growbuf *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("growbuf::pt",2,"unsigned char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBuf_pt_set",1,SWIGTYPE_p_growbuf);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("GrowBuf_pt_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->pt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBuf_pt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *arg1 = (struct growbuf *) 0 ;
  unsigned char *result = 0 ;
  
  SWIG_check_num_args("growbuf::pt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("growbuf::pt",1,"struct growbuf *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBuf_pt_get",1,SWIGTYPE_p_growbuf);
  }
  
  result = (unsigned char *) ((arg1)->pt);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBuf_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *arg1 = (struct growbuf *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  SWIG_check_num_args("growbuf::base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("growbuf::base",1,"struct growbuf *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("growbuf::base",2,"unsigned char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBuf_base_set",1,SWIGTYPE_p_growbuf);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("GrowBuf_base_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBuf_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *arg1 = (struct growbuf *) 0 ;
  unsigned char *result = 0 ;
  
  SWIG_check_num_args("growbuf::base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("growbuf::base",1,"struct growbuf *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBuf_base_get",1,SWIGTYPE_p_growbuf);
  }
  
  result = (unsigned char *) ((arg1)->base);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBuf_end_set(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *arg1 = (struct growbuf *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  SWIG_check_num_args("growbuf::end",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("growbuf::end",1,"struct growbuf *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("growbuf::end",2,"unsigned char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBuf_end_set",1,SWIGTYPE_p_growbuf);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("GrowBuf_end_set",2,SWIGTYPE_p_unsigned_char);
  }
  
  if (arg1) (arg1)->end = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBuf_end_get(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *arg1 = (struct growbuf *) 0 ;
  unsigned char *result = 0 ;
  
  SWIG_check_num_args("growbuf::end",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("growbuf::end",1,"struct growbuf *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBuf_end_get",1,SWIGTYPE_p_growbuf);
  }
  
  result = (unsigned char *) ((arg1)->end);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_GrowBuf(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *result = 0 ;
  
  SWIG_check_num_args("growbuf::growbuf",0,0)
  result = (struct growbuf *)calloc(1, sizeof(struct growbuf));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_growbuf,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_GrowBuf(void *obj) {
struct growbuf *arg1 = (struct growbuf *) obj;
free((char *) arg1);
}
static swig_lua_method swig_growbuf_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_growbuf_attributes[] = {
    { "pt", _wrap_GrowBuf_pt_get, _wrap_GrowBuf_pt_set},
    { "base", _wrap_GrowBuf_base_get, _wrap_GrowBuf_base_set},
    { "end", _wrap_GrowBuf_end_get, _wrap_GrowBuf_end_set},
    {0,0,0}
};
static swig_lua_class *swig_growbuf_bases[] = {0};
static const char *swig_growbuf_base_names[] = {0};
static swig_lua_class _wrap_class_growbuf = { "GrowBuf", &SWIGTYPE_p_growbuf,_wrap_new_GrowBuf, swig_delete_GrowBuf, swig_growbuf_methods, swig_growbuf_attributes, swig_growbuf_bases, swig_growbuf_base_names };

static int _wrap_GrowBuffer(lua_State* L) {
  int SWIG_arg = 0;
  GrowBuf *arg1 = (GrowBuf *) 0 ;
  
  SWIG_check_num_args("GrowBuffer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GrowBuffer",1,"GrowBuf *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBuffer",1,SWIGTYPE_p_growbuf);
  }
  
  GrowBuffer(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBufferAdd(lua_State* L) {
  int SWIG_arg = 0;
  GrowBuf *arg1 = (GrowBuf *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("GrowBufferAdd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GrowBufferAdd",1,"GrowBuf *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("GrowBufferAdd",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBufferAdd",1,SWIGTYPE_p_growbuf);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  GrowBufferAdd(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GrowBufferAddStr(lua_State* L) {
  int SWIG_arg = 0;
  GrowBuf *arg1 = (GrowBuf *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("GrowBufferAddStr",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GrowBufferAddStr",1,"GrowBuf *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GrowBufferAddStr",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("GrowBufferAddStr",1,SWIGTYPE_p_growbuf);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  GrowBufferAddStr(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UnitsParallel(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("UnitsParallel",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnitsParallel",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("UnitsParallel",2,"BasePoint *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("UnitsParallel",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("UnitsParallel",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("UnitsParallel",2,SWIGTYPE_p_basepoint);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)UnitsParallel(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CvtPsStem3(lua_State* L) {
  int SWIG_arg = 0;
  struct growbuf *arg1 = (struct growbuf *) 0 ;
  SplineChar **arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("CvtPsStem3",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CvtPsStem3",1,"struct growbuf *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CvtPsStem3",2,"SplineChar *[16]");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CvtPsStem3",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("CvtPsStem3",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("CvtPsStem3",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_growbuf,0))){
    SWIG_fail_ptr("CvtPsStem3",1,SWIGTYPE_p_growbuf);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_splinechar,0))){
    SWIG_fail_ptr("CvtPsStem3",2,SWIGTYPE_p_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)CvtPsStem3(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CID2ChrsSubrs(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct cidbytes *arg2 = (struct cidbytes *) 0 ;
  int arg3 ;
  int arg4 ;
  struct pschars *result = 0 ;
  
  SWIG_check_num_args("CID2ChrsSubrs",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CID2ChrsSubrs",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CID2ChrsSubrs",2,"struct cidbytes *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CID2ChrsSubrs",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("CID2ChrsSubrs",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CID2ChrsSubrs",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_cidbytes,0))){
    SWIG_fail_ptr("CID2ChrsSubrs",2,SWIGTYPE_p_cidbytes);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (struct pschars *)CID2ChrsSubrs(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pschars,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFont2ChrsSubrs2(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  struct pschars **arg7 = (struct pschars **) 0 ;
  int arg8 ;
  struct pschars *result = 0 ;
  
  SWIG_check_num_args("SplineFont2ChrsSubrs2",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFont2ChrsSubrs2",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFont2ChrsSubrs2",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFont2ChrsSubrs2",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SplineFont2ChrsSubrs2",4,"int const *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplineFont2ChrsSubrs2",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SplineFont2ChrsSubrs2",6,"int");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("SplineFont2ChrsSubrs2",7,"struct pschars **");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("SplineFont2ChrsSubrs2",8,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFont2ChrsSubrs2",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SplineFont2ChrsSubrs2",4,SWIGTYPE_p_int);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_p_pschars,0))){
    SWIG_fail_ptr("SplineFont2ChrsSubrs2",7,SWIGTYPE_p_p_pschars);
  }
  
  arg8 = (int)lua_tonumber(L, 8);
  result = (struct pschars *)SplineFont2ChrsSubrs2(arg1,arg2,arg3,(int const *)arg4,arg5,arg6,arg7,arg8);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pschars,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CID2ChrsSubrs2(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct fd2data *arg2 = (struct fd2data *) 0 ;
  int arg3 ;
  struct pschars **arg4 = (struct pschars **) 0 ;
  int arg5 ;
  struct pschars *result = 0 ;
  
  SWIG_check_num_args("CID2ChrsSubrs2",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CID2ChrsSubrs2",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CID2ChrsSubrs2",2,"struct fd2data *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CID2ChrsSubrs2",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("CID2ChrsSubrs2",4,"struct pschars **");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("CID2ChrsSubrs2",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CID2ChrsSubrs2",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_fd2data,0))){
    SWIG_fail_ptr("CID2ChrsSubrs2",2,SWIGTYPE_p_fd2data);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_p_pschars,0))){
    SWIG_fail_ptr("CID2ChrsSubrs2",4,SWIGTYPE_p_p_pschars);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  result = (struct pschars *)CID2ChrsSubrs2(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pschars,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_filechecksum(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int32 result;
  
  SWIG_check_num_args("filechecksum",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("filechecksum",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("filechecksum",1,SWIGTYPE_p_FILE);
  }
  
  result = (int32)filechecksum(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GetAuthor(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("GetAuthor",0,0)
  result = (char *)GetAuthor();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindExistingCharMac(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SFFindExistingCharMac",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindExistingCharMac",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFFindExistingCharMac",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFFindExistingCharMac",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindExistingCharMac",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFFindExistingCharMac",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (SplineChar *)SFFindExistingCharMac(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SC_PSDump(lua_State* L) {
  int SWIG_arg = 0;
  void (*arg1)(int,void *) = (void (*)(int,void *)) 0 ;
  void *arg2 = (void *) 0 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  
  SWIG_check_num_args("SC_PSDump",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SC_PSDump",1,"void (*)(int,void *)");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SC_PSDump",2,"void *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SC_PSDump",3,"SplineChar *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SC_PSDump",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SC_PSDump",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SC_PSDump",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_f_int_p_void__void,0))){
    SWIG_fail_ptr("SC_PSDump",1,SWIGTYPE_p_f_int_p_void__void);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"SC_PSDump");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SC_PSDump",3,SWIGTYPE_p_splinechar);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  SC_PSDump(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__WritePSFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  SplineFont *arg6 = (SplineFont *) 0 ;
  int arg7 ;
  int result;
  
  SWIG_check_num_args("_WritePSFont",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_WritePSFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_WritePSFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_WritePSFont",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("_WritePSFont",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("_WritePSFont",5,"EncMap *");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("_WritePSFont",6,"SplineFont *");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("_WritePSFont",7,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_WritePSFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_WritePSFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("_WritePSFont",5,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_WritePSFont",6,SWIGTYPE_p_splinefont);
  }
  
  arg7 = (int)lua_tonumber(L, 7);
  result = (int)_WritePSFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WritePSFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  SplineFont *arg6 = (SplineFont *) 0 ;
  int arg7 ;
  int result;
  
  SWIG_check_num_args("WritePSFont",7,7)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WritePSFont",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WritePSFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WritePSFont",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("WritePSFont",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("WritePSFont",5,"EncMap *");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("WritePSFont",6,"SplineFont *");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("WritePSFont",7,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WritePSFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WritePSFont",5,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WritePSFont",6,SWIGTYPE_p_splinefont);
  }
  
  arg7 = (int)lua_tonumber(L, 7);
  result = (int)WritePSFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteMacPSFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("WriteMacPSFont",6,6)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteMacPSFont",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteMacPSFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteMacPSFont",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("WriteMacPSFont",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("WriteMacPSFont",5,"EncMap *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteMacPSFont",6,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WriteMacPSFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WriteMacPSFont",5,SWIGTYPE_p_encmap);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)WriteMacPSFont(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__WriteWOFFFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int32 *arg4 = (int32 *) 0 ;
  enum bitmapformat arg5 ;
  int arg6 ;
  EncMap *arg7 = (EncMap *) 0 ;
  int arg8 ;
  int result;
  
  SWIG_check_num_args("_WriteWOFFFont",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_WriteWOFFFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_WriteWOFFFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_WriteWOFFFont",3,"enum fontformat");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("_WriteWOFFFont",4,"int32 *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("_WriteWOFFFont",5,"enum bitmapformat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("_WriteWOFFFont",6,"int");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("_WriteWOFFFont",7,"EncMap *");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("_WriteWOFFFont",8,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_WriteWOFFFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_WriteWOFFFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("_WriteWOFFFont",4,SWIGTYPE_p_int);
  }
  
  arg5 = (enum bitmapformat)(int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("_WriteWOFFFont",7,SWIGTYPE_p_encmap);
  }
  
  arg8 = (int)lua_tonumber(L, 8);
  result = (int)_WriteWOFFFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteWOFFFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int32 *arg4 = (int32 *) 0 ;
  enum bitmapformat arg5 ;
  int arg6 ;
  EncMap *arg7 = (EncMap *) 0 ;
  int arg8 ;
  int result;
  
  SWIG_check_num_args("WriteWOFFFont",8,8)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteWOFFFont",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteWOFFFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteWOFFFont",3,"enum fontformat");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("WriteWOFFFont",4,"int32 *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("WriteWOFFFont",5,"enum bitmapformat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteWOFFFont",6,"int");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("WriteWOFFFont",7,"EncMap *");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("WriteWOFFFont",8,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WriteWOFFFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("WriteWOFFFont",4,SWIGTYPE_p_int);
  }
  
  arg5 = (enum bitmapformat)(int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WriteWOFFFont",7,SWIGTYPE_p_encmap);
  }
  
  arg8 = (int)lua_tonumber(L, 8);
  result = (int)WriteWOFFFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__WriteTTFFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int32 *arg4 = (int32 *) 0 ;
  enum bitmapformat arg5 ;
  int arg6 ;
  EncMap *arg7 = (EncMap *) 0 ;
  int arg8 ;
  int result;
  
  SWIG_check_num_args("_WriteTTFFont",8,8)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_WriteTTFFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_WriteTTFFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_WriteTTFFont",3,"enum fontformat");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("_WriteTTFFont",4,"int32 *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("_WriteTTFFont",5,"enum bitmapformat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("_WriteTTFFont",6,"int");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("_WriteTTFFont",7,"EncMap *");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("_WriteTTFFont",8,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_WriteTTFFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_WriteTTFFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("_WriteTTFFont",4,SWIGTYPE_p_int);
  }
  
  arg5 = (enum bitmapformat)(int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("_WriteTTFFont",7,SWIGTYPE_p_encmap);
  }
  
  arg8 = (int)lua_tonumber(L, 8);
  result = (int)_WriteTTFFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteTTFFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int32 *arg4 = (int32 *) 0 ;
  enum bitmapformat arg5 ;
  int arg6 ;
  EncMap *arg7 = (EncMap *) 0 ;
  int arg8 ;
  int result;
  
  SWIG_check_num_args("WriteTTFFont",8,8)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteTTFFont",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteTTFFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteTTFFont",3,"enum fontformat");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("WriteTTFFont",4,"int32 *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("WriteTTFFont",5,"enum bitmapformat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteTTFFont",6,"int");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("WriteTTFFont",7,"EncMap *");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("WriteTTFFont",8,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WriteTTFFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("WriteTTFFont",4,SWIGTYPE_p_int);
  }
  
  arg5 = (enum bitmapformat)(int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WriteTTFFont",7,SWIGTYPE_p_encmap);
  }
  
  arg8 = (int)lua_tonumber(L, 8);
  result = (int)WriteTTFFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__WriteType42SFNTS(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("_WriteType42SFNTS",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_WriteType42SFNTS",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_WriteType42SFNTS",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_WriteType42SFNTS",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("_WriteType42SFNTS",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("_WriteType42SFNTS",5,"EncMap *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("_WriteType42SFNTS",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_WriteType42SFNTS",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_WriteType42SFNTS",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("_WriteType42SFNTS",5,SWIGTYPE_p_encmap);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)_WriteType42SFNTS(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteMacTTFFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int32 *arg4 = (int32 *) 0 ;
  enum bitmapformat arg5 ;
  int arg6 ;
  EncMap *arg7 = (EncMap *) 0 ;
  int arg8 ;
  int result;
  
  SWIG_check_num_args("WriteMacTTFFont",8,8)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteMacTTFFont",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteMacTTFFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteMacTTFFont",3,"enum fontformat");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("WriteMacTTFFont",4,"int32 *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("WriteMacTTFFont",5,"enum bitmapformat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteMacTTFFont",6,"int");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("WriteMacTTFFont",7,"EncMap *");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("WriteMacTTFFont",8,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WriteMacTTFFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("WriteMacTTFFont",4,SWIGTYPE_p_int);
  }
  
  arg5 = (enum bitmapformat)(int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WriteMacTTFFont",7,SWIGTYPE_p_encmap);
  }
  
  arg8 = (int)lua_tonumber(L, 8);
  result = (int)WriteMacTTFFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteMacBitmaps(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int32 *arg3 = (int32 *) 0 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("WriteMacBitmaps",5,5)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteMacBitmaps",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteMacBitmaps",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("WriteMacBitmaps",3,"int32 *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("WriteMacBitmaps",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("WriteMacBitmaps",5,"EncMap *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WriteMacBitmaps",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("WriteMacBitmaps",3,SWIGTYPE_p_int);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WriteMacBitmaps",5,SWIGTYPE_p_encmap);
  }
  
  result = (int)WriteMacBitmaps(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WritePalmBitmaps(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int32 *arg3 = (int32 *) 0 ;
  EncMap *arg4 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("WritePalmBitmaps",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WritePalmBitmaps",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WritePalmBitmaps",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("WritePalmBitmaps",3,"int32 *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("WritePalmBitmaps",4,"EncMap *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WritePalmBitmaps",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("WritePalmBitmaps",3,SWIGTYPE_p_int);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WritePalmBitmaps",4,SWIGTYPE_p_encmap);
  }
  
  result = (int)WritePalmBitmaps(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteMacFamily(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  struct sflist *arg2 = (struct sflist *) 0 ;
  enum fontformat arg3 ;
  enum bitmapformat arg4 ;
  int arg5 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("WriteMacFamily",6,6)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteMacFamily",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteMacFamily",2,"struct sflist *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteMacFamily",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("WriteMacFamily",4,"enum bitmapformat");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("WriteMacFamily",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteMacFamily",6,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("WriteMacFamily",2,SWIGTYPE_p_sflist);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (enum bitmapformat)(int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)WriteMacFamily(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteTTC(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  struct sflist *arg2 = (struct sflist *) 0 ;
  enum fontformat arg3 ;
  enum bitmapformat arg4 ;
  int arg5 ;
  int arg6 ;
  enum ttc_flags arg7 ;
  int result;
  
  SWIG_check_num_args("WriteTTC",7,7)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteTTC",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteTTC",2,"struct sflist *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteTTC",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("WriteTTC",4,"enum bitmapformat");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("WriteTTC",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteTTC",6,"int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("WriteTTC",7,"enum ttc_flags");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("WriteTTC",2,SWIGTYPE_p_sflist);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (enum bitmapformat)(int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  arg7 = (enum ttc_flags)(int)lua_tonumber(L, 7);
  result = (int)WriteTTC(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_mactime(lua_State* L) {
  int SWIG_arg = 0;
  long result;
  
  SWIG_check_num_args("mactime",0,0)
  result = (long)mactime();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteSVGFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("WriteSVGFont",6,6)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteSVGFont",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteSVGFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteSVGFont",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("WriteSVGFont",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("WriteSVGFont",5,"EncMap *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteSVGFont",6,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WriteSVGFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WriteSVGFont",5,SWIGTYPE_p_encmap);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)WriteSVGFont(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__WriteSVGFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("_WriteSVGFont",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_WriteSVGFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_WriteSVGFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_WriteSVGFont",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("_WriteSVGFont",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("_WriteSVGFont",5,"EncMap *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("_WriteSVGFont",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_WriteSVGFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_WriteSVGFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("_WriteSVGFont",5,SWIGTYPE_p_encmap);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)_WriteSVGFont(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WriteUFOFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  enum fontformat arg3 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("WriteUFOFont",6,6)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("WriteUFOFont",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("WriteUFOFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("WriteUFOFont",3,"enum fontformat");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("WriteUFOFont",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("WriteUFOFont",5,"EncMap *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("WriteUFOFont",6,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("WriteUFOFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("WriteUFOFont",5,SWIGTYPE_p_encmap);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)WriteUFOFont(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SfListFree(lua_State* L) {
  int SWIG_arg = 0;
  struct sflist *arg1 = (struct sflist *) 0 ;
  
  SWIG_check_num_args("SfListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SfListFree",1,"struct sflist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("SfListFree",1,SWIGTYPE_p_sflist);
  }
  
  SfListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TTF_PSDupsDefault(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("TTF_PSDupsDefault",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TTF_PSDupsDefault",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("TTF_PSDupsDefault",1,SWIGTYPE_p_splinefont);
  }
  
  TTF_PSDupsDefault(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DefaultTTFEnglishNames(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("DefaultTTFEnglishNames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DefaultTTFEnglishNames",1,"struct ttflangname *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("DefaultTTFEnglishNames",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("DefaultTTFEnglishNames",1,SWIGTYPE_p_ttflangname);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("DefaultTTFEnglishNames",2,SWIGTYPE_p_splinefont);
  }
  
  DefaultTTFEnglishNames(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TeXDefaultParams(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("TeXDefaultParams",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TeXDefaultParams",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("TeXDefaultParams",1,SWIGTYPE_p_splinefont);
  }
  
  TeXDefaultParams(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AlreadyMSSymbolArea(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("AlreadyMSSymbolArea",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AlreadyMSSymbolArea",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AlreadyMSSymbolArea",2,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("AlreadyMSSymbolArea",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("AlreadyMSSymbolArea",2,SWIGTYPE_p_encmap);
  }
  
  result = (int)AlreadyMSSymbolArea(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OS2FigureCodePages(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 *arg2 ;
  
  SWIG_check_num_args("OS2FigureCodePages",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OS2FigureCodePages",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OS2FigureCodePages",2,"uint32 [2]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("OS2FigureCodePages",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("OS2FigureCodePages",2,SWIGTYPE_p_unsigned_int);
  }
  
  OS2FigureCodePages(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OS2FigureUnicodeRanges(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 *arg2 ;
  
  SWIG_check_num_args("OS2FigureUnicodeRanges",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OS2FigureUnicodeRanges",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OS2FigureUnicodeRanges",2,"uint32 [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("OS2FigureUnicodeRanges",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("OS2FigureUnicodeRanges",2,SWIGTYPE_p_unsigned_int);
  }
  
  OS2FigureUnicodeRanges(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDefaultOS2Info(lua_State* L) {
  int SWIG_arg = 0;
  struct pfminfo *arg1 = (struct pfminfo *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  char *arg3 = (char *) 0 ;
  
  SWIG_check_num_args("SFDefaultOS2Info",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDefaultOS2Info",1,"struct pfminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFDefaultOS2Info",2,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFDefaultOS2Info",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pfminfo,0))){
    SWIG_fail_ptr("SFDefaultOS2Info",1,SWIGTYPE_p_pfminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDefaultOS2Info",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  SFDefaultOS2Info(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDefaultOS2Simple(lua_State* L) {
  int SWIG_arg = 0;
  struct pfminfo *arg1 = (struct pfminfo *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFDefaultOS2Simple",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDefaultOS2Simple",1,"struct pfminfo *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFDefaultOS2Simple",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pfminfo,0))){
    SWIG_fail_ptr("SFDefaultOS2Simple",1,SWIGTYPE_p_pfminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDefaultOS2Simple",2,SWIGTYPE_p_splinefont);
  }
  
  SFDefaultOS2Simple(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDefaultOS2SubSuper(lua_State* L) {
  int SWIG_arg = 0;
  struct pfminfo *arg1 = (struct pfminfo *) 0 ;
  int arg2 ;
  double arg3 ;
  
  SWIG_check_num_args("SFDefaultOS2SubSuper",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDefaultOS2SubSuper",1,"struct pfminfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFDefaultOS2SubSuper",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFDefaultOS2SubSuper",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pfminfo,0))){
    SWIG_fail_ptr("SFDefaultOS2SubSuper",1,SWIGTYPE_p_pfminfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3);
  SFDefaultOS2SubSuper(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptIsRightToLeft(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  int result;
  
  SWIG_check_num_args("ScriptIsRightToLeft",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ScriptIsRightToLeft",1,"uint32");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  result = (int)ScriptIsRightToLeft(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptMainRange(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  
  SWIG_check_num_args("ScriptMainRange",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ScriptMainRange",1,"uint32");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ScriptMainRange",2,"int *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ScriptMainRange",3,"int *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("ScriptMainRange",2,SWIGTYPE_p_int);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("ScriptMainRange",3,SWIGTYPE_p_int);
  }
  
  ScriptMainRange(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptFromUnicode(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("ScriptFromUnicode",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ScriptFromUnicode",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ScriptFromUnicode",2,"SplineFont *");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ScriptFromUnicode",2,SWIGTYPE_p_splinefont);
  }
  
  result = (uint32)ScriptFromUnicode(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCScriptFromUnicode(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("SCScriptFromUnicode",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCScriptFromUnicode",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCScriptFromUnicode",1,SWIGTYPE_p_splinechar);
  }
  
  result = (uint32)SCScriptFromUnicode(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCRightToLeft(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int result;
  
  SWIG_check_num_args("SCRightToLeft",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCRightToLeft",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCRightToLeft",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int)SCRightToLeft(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFForceEncoding(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  Encoding *arg3 = (Encoding *) 0 ;
  int result;
  
  SWIG_check_num_args("SFForceEncoding",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFForceEncoding",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFForceEncoding",2,"EncMap *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFForceEncoding",3,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFForceEncoding",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFForceEncoding",2,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("SFForceEncoding",3,SWIGTYPE_p_enc);
  }
  
  result = (int)SFForceEncoding(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CountOfEncoding(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *arg1 = (Encoding *) 0 ;
  int result;
  
  SWIG_check_num_args("CountOfEncoding",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CountOfEncoding",1,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("CountOfEncoding",1,SWIGTYPE_p_enc);
  }
  
  result = (int)CountOfEncoding(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFMatchGlyphs(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("SFMatchGlyphs",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFMatchGlyphs",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFMatchGlyphs",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFMatchGlyphs",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFMatchGlyphs",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFMatchGlyphs",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  SFMatchGlyphs(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMMatchGlyphs(lua_State* L) {
  int SWIG_arg = 0;
  MMSet *arg1 = (MMSet *) 0 ;
  
  SWIG_check_num_args("MMMatchGlyphs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMMatchGlyphs",1,"MMSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMMatchGlyphs",1,SWIGTYPE_p_mmset);
  }
  
  MMMatchGlyphs(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__GetModifiers(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("_GetModifiers",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("_GetModifiers",1,"char *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("_GetModifiers",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("_GetModifiers",3,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (char *)_GetModifiers(arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGetModifiers(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("SFGetModifiers",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGetModifiers",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGetModifiers",1,SWIGTYPE_p_splinefont);
  }
  
  result = (char *)SFGetModifiers(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__uGetModifiers(lua_State* L) {
  int SWIG_arg = 0;
  unichar_t *arg1 = (unichar_t *) 0 ;
  unichar_t *arg2 = (unichar_t *) 0 ;
  unichar_t *arg3 = (unichar_t *) 0 ;
  unichar_t *result = 0 ;
  
  SWIG_check_num_args("_uGetModifiers",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_uGetModifiers",1,"unichar_t const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_uGetModifiers",2,"unichar_t const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("_uGetModifiers",3,"unichar_t const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("_uGetModifiers",1,SWIGTYPE_p_unsigned_int);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("_uGetModifiers",2,SWIGTYPE_p_unsigned_int);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("_uGetModifiers",3,SWIGTYPE_p_unsigned_int);
  }
  
  result = (unichar_t *)_uGetModifiers((unsigned int const *)arg1,(unsigned int const *)arg2,(unsigned int const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSetFontName(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  
  SWIG_check_num_args("SFSetFontName",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSetFontName",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFSetFontName",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFSetFontName",3,"char *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SFSetFontName",4,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSetFontName",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  SFSetFontName(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttfdumpbitmap(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct alltabs *arg2 = (struct alltabs *) 0 ;
  int32 *arg3 = (int32 *) 0 ;
  
  SWIG_check_num_args("ttfdumpbitmap",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttfdumpbitmap",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ttfdumpbitmap",2,"struct alltabs *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ttfdumpbitmap",3,"int32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ttfdumpbitmap",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_alltabs,0))){
    SWIG_fail_ptr("ttfdumpbitmap",2,SWIGTYPE_p_alltabs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("ttfdumpbitmap",3,SWIGTYPE_p_int);
  }
  
  ttfdumpbitmap(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttfdumpbitmapscaling(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct alltabs *arg2 = (struct alltabs *) 0 ;
  int32 *arg3 = (int32 *) 0 ;
  
  SWIG_check_num_args("ttfdumpbitmapscaling",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttfdumpbitmapscaling",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ttfdumpbitmapscaling",2,"struct alltabs *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ttfdumpbitmapscaling",3,"int32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ttfdumpbitmapscaling",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_alltabs,0))){
    SWIG_fail_ptr("ttfdumpbitmapscaling",2,SWIGTYPE_p_alltabs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("ttfdumpbitmapscaling",3,SWIGTYPE_p_int);
  }
  
  ttfdumpbitmapscaling(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontSetUnChanged(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SplineFontSetUnChanged",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontSetUnChanged",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontSetUnChanged",1,SWIGTYPE_p_splinefont);
  }
  
  SplineFontSetUnChanged(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Within4RoundingErrors(lua_State* L) {
  int SWIG_arg = 0;
  double arg1 ;
  double arg2 ;
  int result;
  
  SWIG_check_num_args("Within4RoundingErrors",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Within4RoundingErrors",1,"double");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Within4RoundingErrors",2,"double");
  arg1 = (double)lua_tonumber(L, 1);
  arg2 = (double)lua_tonumber(L, 2);
  result = (int)Within4RoundingErrors(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Within16RoundingErrors(lua_State* L) {
  int SWIG_arg = 0;
  double arg1 ;
  double arg2 ;
  int result;
  
  SWIG_check_num_args("Within16RoundingErrors",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Within16RoundingErrors",1,"double");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Within16RoundingErrors",2,"double");
  arg1 = (double)lua_tonumber(L, 1);
  arg2 = (double)lua_tonumber(L, 2);
  result = (int)Within16RoundingErrors(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Within64RoundingErrors(lua_State* L) {
  int SWIG_arg = 0;
  double arg1 ;
  double arg2 ;
  int result;
  
  SWIG_check_num_args("Within64RoundingErrors",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("Within64RoundingErrors",1,"double");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Within64RoundingErrors",2,"double");
  arg1 = (double)lua_tonumber(L, 1);
  arg2 = (double)lua_tonumber(L, 2);
  result = (int)Within64RoundingErrors(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealNear(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  int result;
  
  SWIG_check_num_args("RealNear",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("RealNear",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RealNear",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (int)RealNear(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealNearish(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  int result;
  
  SWIG_check_num_args("RealNearish",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("RealNearish",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RealNearish",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (int)RealNearish(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealApprox(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  int result;
  
  SWIG_check_num_args("RealApprox",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("RealApprox",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RealApprox",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (int)RealApprox(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealWithin(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  int result;
  
  SWIG_check_num_args("RealWithin",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("RealWithin",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RealWithin",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("RealWithin",3,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (int)RealWithin(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RealRatio(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  int result;
  
  SWIG_check_num_args("RealRatio",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("RealRatio",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RealRatio",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("RealRatio",3,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (int)RealRatio(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PointsDiagonalable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  BasePoint **arg2 = (BasePoint **) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("PointsDiagonalable",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PointsDiagonalable",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PointsDiagonalable",2,"BasePoint **");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PointsDiagonalable",3,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("PointsDiagonalable",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_basepoint,0))){
    SWIG_fail_ptr("PointsDiagonalable",2,SWIGTYPE_p_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("PointsDiagonalable",3,SWIGTYPE_p_basepoint);
  }
  
  result = (int)PointsDiagonalable(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MergeDStemInfo(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  DStemInfo **arg2 = (DStemInfo **) 0 ;
  DStemInfo *arg3 = (DStemInfo *) 0 ;
  int result;
  
  SWIG_check_num_args("MergeDStemInfo",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MergeDStemInfo",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MergeDStemInfo",2,"DStemInfo **");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("MergeDStemInfo",3,"DStemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("MergeDStemInfo",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_dsteminfo,0))){
    SWIG_fail_ptr("MergeDStemInfo",2,SWIGTYPE_p_p_dsteminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("MergeDStemInfo",3,SWIGTYPE_p_dsteminfo);
  }
  
  result = (int)MergeDStemInfo(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineListFree(lua_State* L) {
  int SWIG_arg = 0;
  LineList *arg1 = (LineList *) 0 ;
  
  SWIG_check_num_args("LineListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LineListFree",1,"LineList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linelist,0))){
    SWIG_fail_ptr("LineListFree",1,SWIGTYPE_p_linelist);
  }
  
  LineListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LinearApproxFree(lua_State* L) {
  int SWIG_arg = 0;
  LinearApprox *arg1 = (LinearApprox *) 0 ;
  
  SWIG_check_num_args("LinearApproxFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LinearApproxFree",1,"LinearApprox *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_linearapprox,0))){
    SWIG_fail_ptr("LinearApproxFree",1,SWIGTYPE_p_linearapprox);
  }
  
  LinearApproxFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFree(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  
  SWIG_check_num_args("SplineFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFree",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineFree",1,SWIGTYPE_p_spline);
  }
  
  SplineFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointCreate(lua_State* L) {
  int SWIG_arg = 0;
  float arg1 ;
  float arg2 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("SplinePointCreate",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("SplinePointCreate",1,"float");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplinePointCreate",2,"float");
  arg1 = (float)lua_tonumber(L, 1);
  arg2 = (float)lua_tonumber(L, 2);
  result = (SplinePoint *)SplinePointCreate(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointFree(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplinePointFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointFree",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePointFree",1,SWIGTYPE_p_splinepoint);
  }
  
  SplinePointFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointMDFree(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplinePointMDFree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointMDFree",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointMDFree",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplinePointMDFree",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePointMDFree",2,SWIGTYPE_p_splinepoint);
  }
  
  SplinePointMDFree(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointsFree(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SplinePointsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointsFree",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointsFree",1,SWIGTYPE_p_splinepointlist);
  }
  
  SplinePointsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListFree(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SplinePointListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListFree",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListFree",1,SWIGTYPE_p_splinepointlist);
  }
  
  SplinePointListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListMDFree(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SplinePointListMDFree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListMDFree",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointListMDFree",2,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplinePointListMDFree",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListMDFree",2,SWIGTYPE_p_splinepointlist);
  }
  
  SplinePointListMDFree(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListsMDFree(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SplinePointListsMDFree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListsMDFree",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointListsMDFree",2,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplinePointListsMDFree",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListsMDFree",2,SWIGTYPE_p_splinepointlist);
  }
  
  SplinePointListsMDFree(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListsFree(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SplinePointListsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListsFree",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListsFree",1,SWIGTYPE_p_splinepointlist);
  }
  
  SplinePointListsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetSpirosClear(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("SplineSetSpirosClear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetSpirosClear",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetSpirosClear",1,SWIGTYPE_p_splinepointlist);
  }
  
  SplineSetSpirosClear(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetBeziersClear(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("SplineSetBeziersClear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetBeziersClear",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetBeziersClear",1,SWIGTYPE_p_splinepointlist);
  }
  
  SplineSetBeziersClear(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefCharFree(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  
  SWIG_check_num_args("RefCharFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefCharFree",1,"RefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefCharFree",1,SWIGTYPE_p_refchar);
  }
  
  RefCharFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefCharsFree(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  
  SWIG_check_num_args("RefCharsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefCharsFree",1,"RefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefCharsFree",1,SWIGTYPE_p_refchar);
  }
  
  RefCharsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefCharsFreeRef(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  
  SWIG_check_num_args("RefCharsFreeRef",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefCharsFreeRef",1,"RefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefCharsFreeRef",1,SWIGTYPE_p_refchar);
  }
  
  RefCharsFreeRef(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CopyBufferFree(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("CopyBufferFree",0,0)
  CopyBufferFree();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CopyBufferClearCopiedFrom(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("CopyBufferClearCopiedFrom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CopyBufferClearCopiedFrom",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CopyBufferClearCopiedFrom",1,SWIGTYPE_p_splinefont);
  }
  
  CopyBufferClearCopiedFrom(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UndoesFree(lua_State* L) {
  int SWIG_arg = 0;
  Undoes *arg1 = (Undoes *) 0 ;
  
  SWIG_check_num_args("UndoesFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UndoesFree",1,"Undoes *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_undoes,0))){
    SWIG_fail_ptr("UndoesFree",1,SWIGTYPE_p_undoes);
  }
  
  UndoesFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfosFree(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo *arg1 = (StemInfo *) 0 ;
  
  SWIG_check_num_args("StemInfosFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfosFree",1,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfosFree",1,SWIGTYPE_p_steminfo);
  }
  
  StemInfosFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfoFree(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo *arg1 = (StemInfo *) 0 ;
  
  SWIG_check_num_args("StemInfoFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfoFree",1,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfoFree",1,SWIGTYPE_p_steminfo);
  }
  
  StemInfoFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfosFree(lua_State* L) {
  int SWIG_arg = 0;
  DStemInfo *arg1 = (DStemInfo *) 0 ;
  
  SWIG_check_num_args("DStemInfosFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DStemInfosFree",1,"DStemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfosFree",1,SWIGTYPE_p_dsteminfo);
  }
  
  DStemInfosFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfoFree(lua_State* L) {
  int SWIG_arg = 0;
  DStemInfo *arg1 = (DStemInfo *) 0 ;
  
  SWIG_check_num_args("DStemInfoFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DStemInfoFree",1,"DStemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfoFree",1,SWIGTYPE_p_dsteminfo);
  }
  
  DStemInfoFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernPairsFree(lua_State* L) {
  int SWIG_arg = 0;
  KernPair *arg1 = (KernPair *) 0 ;
  
  SWIG_check_num_args("KernPairsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("KernPairsFree",1,"KernPair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("KernPairsFree",1,SWIGTYPE_p_kernpair);
  }
  
  KernPairsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCOrderAP(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCOrderAP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCOrderAP",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCOrderAP",1,SWIGTYPE_p_splinechar);
  }
  
  SCOrderAP(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPointsFree(lua_State* L) {
  int SWIG_arg = 0;
  AnchorPoint *arg1 = (AnchorPoint *) 0 ;
  
  SWIG_check_num_args("AnchorPointsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AnchorPointsFree",1,"AnchorPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPointsFree",1,SWIGTYPE_p_anchorpoint);
  }
  
  AnchorPointsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorPointsCopy(lua_State* L) {
  int SWIG_arg = 0;
  AnchorPoint *arg1 = (AnchorPoint *) 0 ;
  AnchorPoint *result = 0 ;
  
  SWIG_check_num_args("AnchorPointsCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AnchorPointsCopy",1,"AnchorPoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorPointsCopy",1,SWIGTYPE_p_anchorpoint);
  }
  
  result = (AnchorPoint *)AnchorPointsCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveAnchorClass(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  
  SWIG_check_num_args("SFRemoveAnchorClass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveAnchorClass",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFRemoveAnchorClass",2,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveAnchorClass",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("SFRemoveAnchorClass",2,SWIGTYPE_p_anchorclass);
  }
  
  SFRemoveAnchorClass(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IsAnchorClassUsed(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  int result;
  
  SWIG_check_num_args("IsAnchorClassUsed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsAnchorClassUsed",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("IsAnchorClassUsed",2,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("IsAnchorClassUsed",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("IsAnchorClassUsed",2,SWIGTYPE_p_anchorclass);
  }
  
  result = (int)IsAnchorClassUsed(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_APAnchorClassMerge(lua_State* L) {
  int SWIG_arg = 0;
  AnchorPoint *arg1 = (AnchorPoint *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  AnchorClass *arg3 = (AnchorClass *) 0 ;
  AnchorPoint *result = 0 ;
  
  SWIG_check_num_args("APAnchorClassMerge",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("APAnchorClassMerge",1,"AnchorPoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("APAnchorClassMerge",2,"AnchorClass *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("APAnchorClassMerge",3,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("APAnchorClassMerge",1,SWIGTYPE_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("APAnchorClassMerge",2,SWIGTYPE_p_anchorclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("APAnchorClassMerge",3,SWIGTYPE_p_anchorclass);
  }
  
  result = (AnchorPoint *)APAnchorClassMerge(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorpoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClassMerge(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  AnchorClass *arg3 = (AnchorClass *) 0 ;
  
  SWIG_check_num_args("AnchorClassMerge",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AnchorClassMerge",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AnchorClassMerge",2,"AnchorClass *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("AnchorClassMerge",3,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("AnchorClassMerge",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClassMerge",2,SWIGTYPE_p_anchorclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClassMerge",3,SWIGTYPE_p_anchorclass);
  }
  
  AnchorClassMerge(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClassesFree(lua_State* L) {
  int SWIG_arg = 0;
  AnchorClass *arg1 = (AnchorClass *) 0 ;
  
  SWIG_check_num_args("AnchorClassesFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AnchorClassesFree",1,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClassesFree",1,SWIGTYPE_p_anchorclass);
  }
  
  AnchorClassesFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TtfTablesFree(lua_State* L) {
  int SWIG_arg = 0;
  struct ttf_table *arg1 = (struct ttf_table *) 0 ;
  
  SWIG_check_num_args("TtfTablesFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TtfTablesFree",1,"struct ttf_table *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttf_table,0))){
    SWIG_fail_ptr("TtfTablesFree",1,SWIGTYPE_p_ttf_table);
  }
  
  TtfTablesFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveSavedTable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("SFRemoveSavedTable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveSavedTable",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFRemoveSavedTable",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveSavedTable",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  SFRemoveSavedTable(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClassMatch(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  AnchorClass *arg3 = (AnchorClass *) 0 ;
  AnchorPoint **arg4 = (AnchorPoint **) 0 ;
  AnchorPoint **arg5 = (AnchorPoint **) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("AnchorClassMatch",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AnchorClassMatch",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AnchorClassMatch",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("AnchorClassMatch",3,"AnchorClass *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("AnchorClassMatch",4,"AnchorPoint **");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("AnchorClassMatch",5,"AnchorPoint **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AnchorClassMatch",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AnchorClassMatch",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("AnchorClassMatch",3,SWIGTYPE_p_anchorclass);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorClassMatch",4,SWIGTYPE_p_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorClassMatch",5,SWIGTYPE_p_p_anchorpoint);
  }
  
  result = (AnchorClass *)AnchorClassMatch(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClassMkMkMatch(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  AnchorPoint **arg3 = (AnchorPoint **) 0 ;
  AnchorPoint **arg4 = (AnchorPoint **) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("AnchorClassMkMkMatch",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AnchorClassMkMkMatch",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AnchorClassMkMkMatch",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("AnchorClassMkMkMatch",3,"AnchorPoint **");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("AnchorClassMkMkMatch",4,"AnchorPoint **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AnchorClassMkMkMatch",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AnchorClassMkMkMatch",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorClassMkMkMatch",3,SWIGTYPE_p_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorClassMkMkMatch",4,SWIGTYPE_p_p_anchorpoint);
  }
  
  result = (AnchorClass *)AnchorClassMkMkMatch(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AnchorClassCursMatch(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  AnchorPoint **arg3 = (AnchorPoint **) 0 ;
  AnchorPoint **arg4 = (AnchorPoint **) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("AnchorClassCursMatch",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AnchorClassCursMatch",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AnchorClassCursMatch",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("AnchorClassCursMatch",3,"AnchorPoint **");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("AnchorClassCursMatch",4,"AnchorPoint **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AnchorClassCursMatch",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AnchorClassCursMatch",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorClassCursMatch",3,SWIGTYPE_p_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_p_anchorpoint,0))){
    SWIG_fail_ptr("AnchorClassCursMatch",4,SWIGTYPE_p_p_anchorpoint);
  }
  
  result = (AnchorClass *)AnchorClassCursMatch(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSTFree(lua_State* L) {
  int SWIG_arg = 0;
  PST *arg1 = (PST *) 0 ;
  
  SWIG_check_num_args("PSTFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSTFree",1,"PST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PSTFree",1,SWIGTYPE_p_generic_pst);
  }
  
  PSTFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSTContains(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("PSTContains",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("PSTContains",1,"char const *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PSTContains",2,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)PSTContains((char const *)arg1,(char const *)arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfoCopy(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo *arg1 = (StemInfo *) 0 ;
  StemInfo *result = 0 ;
  
  SWIG_check_num_args("StemInfoCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfoCopy",1,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfoCopy",1,SWIGTYPE_p_steminfo);
  }
  
  result = (StemInfo *)StemInfoCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_steminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DStemInfoCopy(lua_State* L) {
  int SWIG_arg = 0;
  DStemInfo *arg1 = (DStemInfo *) 0 ;
  DStemInfo *result = 0 ;
  
  SWIG_check_num_args("DStemInfoCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DStemInfoCopy",1,"DStemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("DStemInfoCopy",1,SWIGTYPE_p_dsteminfo);
  }
  
  result = (DStemInfo *)DStemInfoCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_dsteminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistanceCopy(lua_State* L) {
  int SWIG_arg = 0;
  MinimumDistance *arg1 = (MinimumDistance *) 0 ;
  MinimumDistance *result = 0 ;
  
  SWIG_check_num_args("MinimumDistanceCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MinimumDistanceCopy",1,"MinimumDistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistanceCopy",1,SWIGTYPE_p_minimumdistance);
  }
  
  result = (MinimumDistance *)MinimumDistanceCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_minimumdistance,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPChangePointType(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SPChangePointType",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPChangePointType",1,"SplinePoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SPChangePointType",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SPChangePointType",1,SWIGTYPE_p_splinepoint);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SPChangePointType(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_sf_from_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("sfmergecontext::sf_from",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::sf_from",1,"struct sfmergecontext *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext::sf_from",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_sf_from_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_sf_from_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->sf_from = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_sf_from_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext::sf_from",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::sf_from",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_sf_from_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (SplineFont *) ((arg1)->sf_from);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_sf_to_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("sfmergecontext::sf_to",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::sf_to",1,"struct sfmergecontext *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext::sf_to",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_sf_to_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_sf_to_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->sf_to = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_sf_to_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext::sf_to",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::sf_to",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_sf_to_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (SplineFont *) ((arg1)->sf_to);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext::lcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::lcnt",1,"struct sfmergecontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext::lcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_lcnt_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext::lcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::lcnt",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_lcnt_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (int) ((arg1)->lcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_scnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext::scnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::scnt",1,"struct sfmergecontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext::scnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_scnt_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->scnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_scnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext::scnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::scnt",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_scnt_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (int) ((arg1)->scnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext::acnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::acnt",1,"struct sfmergecontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext::acnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_acnt_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->acnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext::acnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::acnt",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_acnt_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (int) ((arg1)->acnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_prefix_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("sfmergecontext::prefix",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::prefix",1,"struct sfmergecontext *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("sfmergecontext::prefix",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_prefix_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->prefix);
    if (arg2) {
      arg1->prefix = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->prefix, (const char *)arg2);
    } else {
      arg1->prefix = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_prefix_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext::prefix",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::prefix",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_prefix_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (char *) ((arg1)->prefix);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_preserveCrossFontKerning_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext::preserveCrossFontKerning",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::preserveCrossFontKerning",1,"struct sfmergecontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext::preserveCrossFontKerning",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_preserveCrossFontKerning_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->preserveCrossFontKerning = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_preserveCrossFontKerning_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext::preserveCrossFontKerning",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::preserveCrossFontKerning",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_preserveCrossFontKerning_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (int) ((arg1)->preserveCrossFontKerning);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext::lmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::lmax",1,"struct sfmergecontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext::lmax",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_lmax_set",1,SWIGTYPE_p_sfmergecontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext::lmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::lmax",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_lmax_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (int) ((arg1)->lmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lks_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  sfmergecontext_lks *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext::lks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::lks",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_lks_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (sfmergecontext_lks *) ((arg1)->lks);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sfmergecontext_lks,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_subs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  sfmergecontext_subs *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext::subs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::subs",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_subs_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (sfmergecontext_subs *) ((arg1)->subs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sfmergecontext_subs,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  sfmergecontext_acs *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext::acs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext::acs",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("sfmergecontext_acs_get",1,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (sfmergecontext_acs *) ((arg1)->acs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sfmergecontext_acs,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_sfmergecontext(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext::sfmergecontext",0,0)
  result = (struct sfmergecontext *)calloc(1, sizeof(struct sfmergecontext));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sfmergecontext,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_sfmergecontext(void *obj) {
struct sfmergecontext *arg1 = (struct sfmergecontext *) obj;
free((char *) arg1);
}
static swig_lua_method swig_sfmergecontext_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_sfmergecontext_attributes[] = {
    { "sf_from", _wrap_sfmergecontext_sf_from_get, _wrap_sfmergecontext_sf_from_set},
    { "sf_to", _wrap_sfmergecontext_sf_to_get, _wrap_sfmergecontext_sf_to_set},
    { "lcnt", _wrap_sfmergecontext_lcnt_get, _wrap_sfmergecontext_lcnt_set},
    { "scnt", _wrap_sfmergecontext_scnt_get, _wrap_sfmergecontext_scnt_set},
    { "acnt", _wrap_sfmergecontext_acnt_get, _wrap_sfmergecontext_acnt_set},
    { "prefix", _wrap_sfmergecontext_prefix_get, _wrap_sfmergecontext_prefix_set},
    { "preserveCrossFontKerning", _wrap_sfmergecontext_preserveCrossFontKerning_get, _wrap_sfmergecontext_preserveCrossFontKerning_set},
    { "lmax", _wrap_sfmergecontext_lmax_get, _wrap_sfmergecontext_lmax_set},
    { "lks", _wrap_sfmergecontext_lks_get, SWIG_Lua_set_immutable},
    { "subs", _wrap_sfmergecontext_subs_get, SWIG_Lua_set_immutable},
    { "acs", _wrap_sfmergecontext_acs_get, SWIG_Lua_set_immutable},
    {0,0,0}
};
static swig_lua_class *swig_sfmergecontext_bases[] = {0};
static const char *swig_sfmergecontext_base_names[] = {0};
static swig_lua_class _wrap_class_sfmergecontext = { "sfmergecontext", &SWIGTYPE_p_sfmergecontext,_wrap_new_sfmergecontext, swig_delete_sfmergecontext, swig_sfmergecontext_methods, swig_sfmergecontext_attributes, swig_sfmergecontext_bases, swig_sfmergecontext_base_names };

static int _wrap_sfmergecontext_acs_from_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_acs *arg1 = (sfmergecontext_acs *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  
  SWIG_check_num_args("sfmergecontext_acs::from",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_acs::from",1,"sfmergecontext_acs *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext_acs::from",2,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_acs,0))){
    SWIG_fail_ptr("sfmergecontext_acs_from_set",1,SWIGTYPE_p_sfmergecontext_acs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_acs_from_set",2,SWIGTYPE_p_anchorclass);
  }
  
  if (arg1) (arg1)->from = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acs_from_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_acs *arg1 = (sfmergecontext_acs *) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_acs::from",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_acs::from",1,"sfmergecontext_acs *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_acs,0))){
    SWIG_fail_ptr("sfmergecontext_acs_from_get",1,SWIGTYPE_p_sfmergecontext_acs);
  }
  
  result = (AnchorClass *) ((arg1)->from);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acs_to_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_acs *arg1 = (sfmergecontext_acs *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  
  SWIG_check_num_args("sfmergecontext_acs::to",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_acs::to",1,"sfmergecontext_acs *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext_acs::to",2,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_acs,0))){
    SWIG_fail_ptr("sfmergecontext_acs_to_set",1,SWIGTYPE_p_sfmergecontext_acs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_acs_to_set",2,SWIGTYPE_p_anchorclass);
  }
  
  if (arg1) (arg1)->to = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acs_to_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_acs *arg1 = (sfmergecontext_acs *) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_acs::to",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_acs::to",1,"sfmergecontext_acs *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_acs,0))){
    SWIG_fail_ptr("sfmergecontext_acs_to_get",1,SWIGTYPE_p_sfmergecontext_acs);
  }
  
  result = (AnchorClass *) ((arg1)->to);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acs_old_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_acs *arg1 = (sfmergecontext_acs *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext_acs::old",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_acs::old",1,"sfmergecontext_acs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext_acs::old",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_acs,0))){
    SWIG_fail_ptr("sfmergecontext_acs_old_set",1,SWIGTYPE_p_sfmergecontext_acs);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->old = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_acs_old_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_acs *arg1 = (sfmergecontext_acs *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext_acs::old",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_acs::old",1,"sfmergecontext_acs *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_acs,0))){
    SWIG_fail_ptr("sfmergecontext_acs_old_get",1,SWIGTYPE_p_sfmergecontext_acs);
  }
  
  result = (int) ((arg1)->old);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_sfmergecontext_acs(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_acs *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_acs::sfmergecontext_acs",0,0)
  result = (sfmergecontext_acs *)calloc(1, sizeof(sfmergecontext_acs));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sfmergecontext_acs,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_sfmergecontext_acs(void *obj) {
sfmergecontext_acs *arg1 = (sfmergecontext_acs *) obj;
free((char *) arg1);
}
static swig_lua_method swig_sfmergecontext_acs_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_sfmergecontext_acs_attributes[] = {
    { "from", _wrap_sfmergecontext_acs_from_get, _wrap_sfmergecontext_acs_from_set},
    { "to", _wrap_sfmergecontext_acs_to_get, _wrap_sfmergecontext_acs_to_set},
    { "old", _wrap_sfmergecontext_acs_old_get, _wrap_sfmergecontext_acs_old_set},
    {0,0,0}
};
static swig_lua_class *swig_sfmergecontext_acs_bases[] = {0};
static const char *swig_sfmergecontext_acs_base_names[] = {0};
static swig_lua_class _wrap_class_sfmergecontext_acs = { "sfmergecontext_acs", &SWIGTYPE_p_sfmergecontext_acs,_wrap_new_sfmergecontext_acs, swig_delete_sfmergecontext_acs, swig_sfmergecontext_acs_methods, swig_sfmergecontext_acs_attributes, swig_sfmergecontext_acs_bases, swig_sfmergecontext_acs_base_names };

static int _wrap_sfmergecontext_subs_from_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_subs *arg1 = (sfmergecontext_subs *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("sfmergecontext_subs::from",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_subs::from",1,"sfmergecontext_subs *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext_subs::from",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_subs,0))){
    SWIG_fail_ptr("sfmergecontext_subs_from_set",1,SWIGTYPE_p_sfmergecontext_subs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_subs_from_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->from = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_subs_from_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_subs *arg1 = (sfmergecontext_subs *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_subs::from",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_subs::from",1,"sfmergecontext_subs *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_subs,0))){
    SWIG_fail_ptr("sfmergecontext_subs_from_get",1,SWIGTYPE_p_sfmergecontext_subs);
  }
  
  result = (struct lookup_subtable *) ((arg1)->from);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_subs_to_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_subs *arg1 = (sfmergecontext_subs *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("sfmergecontext_subs::to",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_subs::to",1,"sfmergecontext_subs *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext_subs::to",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_subs,0))){
    SWIG_fail_ptr("sfmergecontext_subs_to_set",1,SWIGTYPE_p_sfmergecontext_subs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_subs_to_set",2,SWIGTYPE_p_lookup_subtable);
  }
  
  if (arg1) (arg1)->to = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_subs_to_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_subs *arg1 = (sfmergecontext_subs *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_subs::to",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_subs::to",1,"sfmergecontext_subs *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_subs,0))){
    SWIG_fail_ptr("sfmergecontext_subs_to_get",1,SWIGTYPE_p_sfmergecontext_subs);
  }
  
  result = (struct lookup_subtable *) ((arg1)->to);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_subs_old_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_subs *arg1 = (sfmergecontext_subs *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext_subs::old",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_subs::old",1,"sfmergecontext_subs *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext_subs::old",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_subs,0))){
    SWIG_fail_ptr("sfmergecontext_subs_old_set",1,SWIGTYPE_p_sfmergecontext_subs);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->old = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_subs_old_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_subs *arg1 = (sfmergecontext_subs *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext_subs::old",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_subs::old",1,"sfmergecontext_subs *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_subs,0))){
    SWIG_fail_ptr("sfmergecontext_subs_old_get",1,SWIGTYPE_p_sfmergecontext_subs);
  }
  
  result = (int) ((arg1)->old);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_sfmergecontext_subs(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_subs *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_subs::sfmergecontext_subs",0,0)
  result = (sfmergecontext_subs *)calloc(1, sizeof(sfmergecontext_subs));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sfmergecontext_subs,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_sfmergecontext_subs(void *obj) {
sfmergecontext_subs *arg1 = (sfmergecontext_subs *) obj;
free((char *) arg1);
}
static swig_lua_method swig_sfmergecontext_subs_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_sfmergecontext_subs_attributes[] = {
    { "from", _wrap_sfmergecontext_subs_from_get, _wrap_sfmergecontext_subs_from_set},
    { "to", _wrap_sfmergecontext_subs_to_get, _wrap_sfmergecontext_subs_to_set},
    { "old", _wrap_sfmergecontext_subs_old_get, _wrap_sfmergecontext_subs_old_set},
    {0,0,0}
};
static swig_lua_class *swig_sfmergecontext_subs_bases[] = {0};
static const char *swig_sfmergecontext_subs_base_names[] = {0};
static swig_lua_class _wrap_class_sfmergecontext_subs = { "sfmergecontext_subs", &SWIGTYPE_p_sfmergecontext_subs,_wrap_new_sfmergecontext_subs, swig_delete_sfmergecontext_subs, swig_sfmergecontext_subs_methods, swig_sfmergecontext_subs_attributes, swig_sfmergecontext_subs_bases, swig_sfmergecontext_subs_base_names };

static int _wrap_sfmergecontext_lks_from_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_lks *arg1 = (sfmergecontext_lks *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("sfmergecontext_lks::from",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_lks::from",1,"sfmergecontext_lks *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext_lks::from",2,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_lks,0))){
    SWIG_fail_ptr("sfmergecontext_lks_from_set",1,SWIGTYPE_p_sfmergecontext_lks);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_lks_from_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->from = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lks_from_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_lks *arg1 = (sfmergecontext_lks *) 0 ;
  OTLookup *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_lks::from",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_lks::from",1,"sfmergecontext_lks *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_lks,0))){
    SWIG_fail_ptr("sfmergecontext_lks_from_get",1,SWIGTYPE_p_sfmergecontext_lks);
  }
  
  result = (OTLookup *) ((arg1)->from);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lks_to_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_lks *arg1 = (sfmergecontext_lks *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("sfmergecontext_lks::to",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_lks::to",1,"sfmergecontext_lks *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sfmergecontext_lks::to",2,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_lks,0))){
    SWIG_fail_ptr("sfmergecontext_lks_to_set",1,SWIGTYPE_p_sfmergecontext_lks);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sfmergecontext_lks_to_set",2,SWIGTYPE_p_otlookup);
  }
  
  if (arg1) (arg1)->to = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lks_to_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_lks *arg1 = (sfmergecontext_lks *) 0 ;
  OTLookup *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_lks::to",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_lks::to",1,"sfmergecontext_lks *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_lks,0))){
    SWIG_fail_ptr("sfmergecontext_lks_to_get",1,SWIGTYPE_p_sfmergecontext_lks);
  }
  
  result = (OTLookup *) ((arg1)->to);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lks_old_set(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_lks *arg1 = (sfmergecontext_lks *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sfmergecontext_lks::old",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_lks::old",1,"sfmergecontext_lks *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sfmergecontext_lks::old",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_lks,0))){
    SWIG_fail_ptr("sfmergecontext_lks_old_set",1,SWIGTYPE_p_sfmergecontext_lks);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->old = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sfmergecontext_lks_old_get(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_lks *arg1 = (sfmergecontext_lks *) 0 ;
  int result;
  
  SWIG_check_num_args("sfmergecontext_lks::old",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sfmergecontext_lks::old",1,"sfmergecontext_lks *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext_lks,0))){
    SWIG_fail_ptr("sfmergecontext_lks_old_get",1,SWIGTYPE_p_sfmergecontext_lks);
  }
  
  result = (int) ((arg1)->old);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_sfmergecontext_lks(lua_State* L) {
  int SWIG_arg = 0;
  sfmergecontext_lks *result = 0 ;
  
  SWIG_check_num_args("sfmergecontext_lks::sfmergecontext_lks",0,0)
  result = (sfmergecontext_lks *)calloc(1, sizeof(sfmergecontext_lks));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sfmergecontext_lks,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_sfmergecontext_lks(void *obj) {
sfmergecontext_lks *arg1 = (sfmergecontext_lks *) obj;
free((char *) arg1);
}
static swig_lua_method swig_sfmergecontext_lks_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_sfmergecontext_lks_attributes[] = {
    { "from", _wrap_sfmergecontext_lks_from_get, _wrap_sfmergecontext_lks_from_set},
    { "to", _wrap_sfmergecontext_lks_to_get, _wrap_sfmergecontext_lks_to_set},
    { "old", _wrap_sfmergecontext_lks_old_get, _wrap_sfmergecontext_lks_old_set},
    {0,0,0}
};
static swig_lua_class *swig_sfmergecontext_lks_bases[] = {0};
static const char *swig_sfmergecontext_lks_base_names[] = {0};
static swig_lua_class _wrap_class_sfmergecontext_lks = { "sfmergecontext_lks", &SWIGTYPE_p_sfmergecontext_lks,_wrap_new_sfmergecontext_lks, swig_delete_sfmergecontext_lks, swig_sfmergecontext_lks_methods, swig_sfmergecontext_lks_attributes, swig_sfmergecontext_lks_bases, swig_sfmergecontext_lks_base_names };

static int _wrap_PSTCopy(lua_State* L) {
  int SWIG_arg = 0;
  PST *arg1 = (PST *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  struct sfmergecontext *arg3 = (struct sfmergecontext *) 0 ;
  PST *result = 0 ;
  
  SWIG_check_num_args("PSTCopy",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSTCopy",1,"PST *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PSTCopy",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PSTCopy",3,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_pst,0))){
    SWIG_fail_ptr("PSTCopy",1,SWIGTYPE_p_generic_pst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("PSTCopy",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("PSTCopy",3,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (PST *)PSTCopy(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_pst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MCConvertSubtable(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("MCConvertSubtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MCConvertSubtable",1,"struct sfmergecontext *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MCConvertSubtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("MCConvertSubtable",1,SWIGTYPE_p_sfmergecontext);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,0))){
    SWIG_fail_ptr("MCConvertSubtable",2,SWIGTYPE_p_lookup_subtable);
  }
  
  result = (struct lookup_subtable *)MCConvertSubtable(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MCConvertAnchorClass(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  AnchorClass *arg2 = (AnchorClass *) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("MCConvertAnchorClass",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MCConvertAnchorClass",1,"struct sfmergecontext *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MCConvertAnchorClass",2,"AnchorClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("MCConvertAnchorClass",1,SWIGTYPE_p_sfmergecontext);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_anchorclass,0))){
    SWIG_fail_ptr("MCConvertAnchorClass",2,SWIGTYPE_p_anchorclass);
  }
  
  result = (AnchorClass *)MCConvertAnchorClass(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFinishMergeContext(lua_State* L) {
  int SWIG_arg = 0;
  struct sfmergecontext *arg1 = (struct sfmergecontext *) 0 ;
  
  SWIG_check_num_args("SFFinishMergeContext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFinishMergeContext",1,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("SFFinishMergeContext",1,SWIGTYPE_p_sfmergecontext);
  }
  
  SFFinishMergeContext(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharCopy(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  struct sfmergecontext *arg3 = (struct sfmergecontext *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharCopy",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharCopy",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharCopy",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineCharCopy",3,"struct sfmergecontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharCopy",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineCharCopy",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_sfmergecontext,0))){
    SWIG_fail_ptr("SplineCharCopy",3,SWIGTYPE_p_sfmergecontext);
  }
  
  result = (SplineChar *)SplineCharCopy(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFCharCopy(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("BDFCharCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFCharCopy",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFCharCopy",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (BDFChar *)BDFCharCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCFlattenFloat(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCFlattenFloat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCFlattenFloat",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCFlattenFloat",1,SWIGTYPE_p_bdfchar);
  }
  
  BCFlattenFloat(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BitmapsCopy(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("BitmapsCopy",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BitmapsCopy",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BitmapsCopy",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BitmapsCopy",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("BitmapsCopy",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("BitmapsCopy",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("BitmapsCopy",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  BitmapsCopy(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageAlterClut(lua_State* L) {
  int SWIG_arg = 0;
  struct gimage *arg1 = (struct gimage *) 0 ;
  struct gimage *result = 0 ;
  
  SWIG_check_num_args("ImageAlterClut",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ImageAlterClut",1,"struct gimage *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gimage,0))){
    SWIG_fail_ptr("ImageAlterClut",1,SWIGTYPE_p_gimage);
  }
  
  result = (struct gimage *)ImageAlterClut(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gimage,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageListsFree(lua_State* L) {
  int SWIG_arg = 0;
  ImageList *arg1 = (ImageList *) 0 ;
  
  SWIG_check_num_args("ImageListsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ImageListsFree",1,"ImageList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageListsFree",1,SWIGTYPE_p_imagelist);
  }
  
  ImageListsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TTFLangNamesFree(lua_State* L) {
  int SWIG_arg = 0;
  struct ttflangname *arg1 = (struct ttflangname *) 0 ;
  
  SWIG_check_num_args("TTFLangNamesFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TTFLangNamesFree",1,"struct ttflangname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_ttflangname,0))){
    SWIG_fail_ptr("TTFLangNamesFree",1,SWIGTYPE_p_ttflangname);
  }
  
  TTFLangNamesFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AltUniFree(lua_State* L) {
  int SWIG_arg = 0;
  struct altuni *arg1 = (struct altuni *) 0 ;
  
  SWIG_check_num_args("AltUniFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AltUniFree",1,"struct altuni *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_altuni,0))){
    SWIG_fail_ptr("AltUniFree",1,SWIGTYPE_p_altuni);
  }
  
  AltUniFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AltUniFigure(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("AltUniFigure",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AltUniFigure",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AltUniFigure",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("AltUniFigure",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("AltUniFigure",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("AltUniFigure",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  AltUniFigure(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AltUniRemove(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("AltUniRemove",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AltUniRemove",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AltUniRemove",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AltUniRemove",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  AltUniRemove(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AltUniAdd(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("AltUniAdd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AltUniAdd",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AltUniAdd",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AltUniAdd",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  AltUniAdd(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AltUniAdd_DontCheckDups(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("AltUniAdd_DontCheckDups",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AltUniAdd_DontCheckDups",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("AltUniAdd_DontCheckDups",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AltUniAdd_DontCheckDups",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  AltUniAdd_DontCheckDups(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MinimumDistancesFree(lua_State* L) {
  int SWIG_arg = 0;
  MinimumDistance *arg1 = (MinimumDistance *) 0 ;
  
  SWIG_check_num_args("MinimumDistancesFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MinimumDistancesFree",1,"MinimumDistance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MinimumDistancesFree",1,SWIGTYPE_p_minimumdistance);
  }
  
  MinimumDistancesFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerDefault(lua_State* L) {
  int SWIG_arg = 0;
  Layer *arg1 = (Layer *) 0 ;
  
  SWIG_check_num_args("LayerDefault",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerDefault",1,"Layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayerDefault",1,SWIGTYPE_p_layer);
  }
  
  LayerDefault(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharCreate(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharCreate",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("SplineCharCreate",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (SplineChar *)SplineCharCreate(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSplineCharCreate(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SFSplineCharCreate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSplineCharCreate",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSplineCharCreate",1,SWIGTYPE_p_splinefont);
  }
  
  result = (SplineChar *)SFSplineCharCreate(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefCharCreate(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *result = 0 ;
  
  SWIG_check_num_args("RefCharCreate",0,0)
  result = (RefChar *)RefCharCreate();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefCharsCopy(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  RefChar *result = 0 ;
  
  SWIG_check_num_args("RefCharsCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefCharsCopy",1,"RefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefCharsCopy",1,SWIGTYPE_p_refchar);
  }
  
  result = (RefChar *)RefCharsCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AltUniCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct altuni *arg1 = (struct altuni *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  struct altuni *result = 0 ;
  
  SWIG_check_num_args("AltUniCopy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AltUniCopy",1,"struct altuni *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AltUniCopy",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_altuni,0))){
    SWIG_fail_ptr("AltUniCopy",1,SWIGTYPE_p_altuni);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("AltUniCopy",2,SWIGTYPE_p_splinefont);
  }
  
  result = (struct altuni *)AltUniCopy(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_altuni,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCAddRef(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("SCAddRef",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCAddRef",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCAddRef",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCAddRef",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCAddRef",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCAddRef",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCAddRef",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCAddRef",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  SCAddRef(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SCAddRef(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  float *arg4 ;
  
  SWIG_check_num_args("_SCAddRef",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_SCAddRef",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_SCAddRef",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_SCAddRef",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("_SCAddRef",4,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_SCAddRef",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_SCAddRef",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("_SCAddRef",4,SWIGTYPE_p_float);
  }
  
  _SCAddRef(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClassCopy(lua_State* L) {
  int SWIG_arg = 0;
  KernClass *arg1 = (KernClass *) 0 ;
  KernClass *result = 0 ;
  
  SWIG_check_num_args("KernClassCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("KernClassCopy",1,"KernClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClassCopy",1,SWIGTYPE_p_kernclass);
  }
  
  result = (KernClass *)KernClassCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_kernclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClassFreeContents(lua_State* L) {
  int SWIG_arg = 0;
  KernClass *arg1 = (KernClass *) 0 ;
  
  SWIG_check_num_args("KernClassFreeContents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("KernClassFreeContents",1,"KernClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClassFreeContents",1,SWIGTYPE_p_kernclass);
  }
  
  KernClassFreeContents(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClassListFree(lua_State* L) {
  int SWIG_arg = 0;
  KernClass *arg1 = (KernClass *) 0 ;
  
  SWIG_check_num_args("KernClassListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("KernClassListFree",1,"KernClass *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClassListFree",1,SWIGTYPE_p_kernclass);
  }
  
  KernClassListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernClassContains(lua_State* L) {
  int SWIG_arg = 0;
  KernClass *arg1 = (KernClass *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("KernClassContains",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("KernClassContains",1,"KernClass *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("KernClassContains",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("KernClassContains",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("KernClassContains",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_kernclass,0))){
    SWIG_fail_ptr("KernClassContains",1,SWIGTYPE_p_kernclass);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)KernClassContains(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookupFree(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup *arg1 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("OTLookupFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookupFree",1,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookupFree",1,SWIGTYPE_p_otlookup);
  }
  
  OTLookupFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookupListFree(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup *arg1 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("OTLookupListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookupListFree",1,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookupListFree",1,SWIGTYPE_p_otlookup);
  }
  
  OTLookupListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTCopy(lua_State* L) {
  int SWIG_arg = 0;
  FPST *arg1 = (FPST *) 0 ;
  FPST *result = 0 ;
  
  SWIG_check_num_args("FPSTCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTCopy",1,"FPST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPSTCopy",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (FPST *)FPSTCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_fpst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTRuleContentsFree(lua_State* L) {
  int SWIG_arg = 0;
  struct fpst_rule *arg1 = (struct fpst_rule *) 0 ;
  enum fpossub_format arg2 ;
  
  SWIG_check_num_args("FPSTRuleContentsFree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTRuleContentsFree",1,"struct fpst_rule *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPSTRuleContentsFree",2,"enum fpossub_format");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_fpst_rule,0))){
    SWIG_fail_ptr("FPSTRuleContentsFree",1,SWIGTYPE_p_fpst_rule);
  }
  
  arg2 = (enum fpossub_format)(int)lua_tonumber(L, 2);
  FPSTRuleContentsFree(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTClassesFree(lua_State* L) {
  int SWIG_arg = 0;
  FPST *arg1 = (FPST *) 0 ;
  
  SWIG_check_num_args("FPSTClassesFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTClassesFree",1,"FPST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPSTClassesFree",1,SWIGTYPE_p_generic_fpst);
  }
  
  FPSTClassesFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTRulesFree(lua_State* L) {
  int SWIG_arg = 0;
  struct fpst_rule *arg1 = (struct fpst_rule *) 0 ;
  enum fpossub_format arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("FPSTRulesFree",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTRulesFree",1,"struct fpst_rule *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FPSTRulesFree",2,"enum fpossub_format");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FPSTRulesFree",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_fpst_rule,0))){
    SWIG_fail_ptr("FPSTRulesFree",1,SWIGTYPE_p_fpst_rule);
  }
  
  arg2 = (enum fpossub_format)(int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  FPSTRulesFree(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTFree(lua_State* L) {
  int SWIG_arg = 0;
  FPST *arg1 = (FPST *) 0 ;
  
  SWIG_check_num_args("FPSTFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTFree",1,"FPST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPSTFree",1,SWIGTYPE_p_generic_fpst);
  }
  
  FPSTFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASMFree(lua_State* L) {
  int SWIG_arg = 0;
  ASM *arg1 = (ASM *) 0 ;
  
  SWIG_check_num_args("ASMFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASMFree",1,"ASM *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_asm,0))){
    SWIG_fail_ptr("ASMFree",1,SWIGTYPE_p_generic_asm);
  }
  
  ASMFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacNameCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("MacNameCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacNameCopy",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("MacNameCopy",1,SWIGTYPE_p_macname);
  }
  
  result = (struct macname *)MacNameCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacNameListFree(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  
  SWIG_check_num_args("MacNameListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacNameListFree",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("MacNameListFree",1,SWIGTYPE_p_macname);
  }
  
  MacNameListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacSettingListFree(lua_State* L) {
  int SWIG_arg = 0;
  struct macsetting *arg1 = (struct macsetting *) 0 ;
  
  SWIG_check_num_args("MacSettingListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacSettingListFree",1,"struct macsetting *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macsetting,0))){
    SWIG_fail_ptr("MacSettingListFree",1,SWIGTYPE_p_macsetting);
  }
  
  MacSettingListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacFeatListFree(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat *arg1 = (MacFeat *) 0 ;
  
  SWIG_check_num_args("MacFeatListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacFeatListFree",1,"MacFeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("MacFeatListFree",1,SWIGTYPE_p_macfeat);
  }
  
  MacFeatListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlyphVariantsFree(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  
  SWIG_check_num_args("GlyphVariantsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GlyphVariantsFree",1,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("GlyphVariantsFree",1,SWIGTYPE_p_glyphvariants);
  }
  
  GlyphVariantsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlyphVariantsCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct glyphvariants *arg1 = (struct glyphvariants *) 0 ;
  struct glyphvariants *result = 0 ;
  
  SWIG_check_num_args("GlyphVariantsCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GlyphVariantsCopy",1,"struct glyphvariants *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_glyphvariants,0))){
    SWIG_fail_ptr("GlyphVariantsCopy",1,SWIGTYPE_p_glyphvariants);
  }
  
  result = (struct glyphvariants *)GlyphVariantsCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_glyphvariants,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MathKernVContentsFree(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkernvertex *arg1 = (struct mathkernvertex *) 0 ;
  
  SWIG_check_num_args("MathKernVContentsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MathKernVContentsFree",1,"struct mathkernvertex *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkernvertex,0))){
    SWIG_fail_ptr("MathKernVContentsFree",1,SWIGTYPE_p_mathkernvertex);
  }
  
  MathKernVContentsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MathKernFree(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  
  SWIG_check_num_args("MathKernFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MathKernFree",1,"struct mathkern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("MathKernFree",1,SWIGTYPE_p_mathkern);
  }
  
  MathKernFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MathKernCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct mathkern *arg1 = (struct mathkern *) 0 ;
  struct mathkern *result = 0 ;
  
  SWIG_check_num_args("MathKernCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MathKernCopy",1,"struct mathkern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mathkern,0))){
    SWIG_fail_ptr("MathKernCopy",1,SWIGTYPE_p_mathkern);
  }
  
  result = (struct mathkern *)MathKernCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_mathkern,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharListsFree(lua_State* L) {
  int SWIG_arg = 0;
  struct splinecharlist *arg1 = (struct splinecharlist *) 0 ;
  
  SWIG_check_num_args("SplineCharListsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharListsFree",1,"struct splinecharlist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinecharlist,0))){
    SWIG_fail_ptr("SplineCharListsFree",1,SWIGTYPE_p_splinecharlist);
  }
  
  SplineCharListsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerFreeContents(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("LayerFreeContents",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerFreeContents",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("LayerFreeContents",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("LayerFreeContents",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  LayerFreeContents(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharFreeContents(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SplineCharFreeContents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharFreeContents",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharFreeContents",1,SWIGTYPE_p_splinechar);
  }
  
  SplineCharFreeContents(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharFree(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SplineCharFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharFree",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharFree",1,SWIGTYPE_p_splinechar);
  }
  
  SplineCharFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMapFree(lua_State* L) {
  int SWIG_arg = 0;
  EncMap *arg1 = (EncMap *) 0 ;
  
  SWIG_check_num_args("EncMapFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("EncMapFree",1,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMapFree",1,SWIGTYPE_p_encmap);
  }
  
  EncMapFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMapFromEncoding(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  Encoding *arg2 = (Encoding *) 0 ;
  EncMap *result = 0 ;
  
  SWIG_check_num_args("EncMapFromEncoding",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("EncMapFromEncoding",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("EncMapFromEncoding",2,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("EncMapFromEncoding",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("EncMapFromEncoding",2,SWIGTYPE_p_enc);
  }
  
  result = (EncMap *)EncMapFromEncoding(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CompactEncMap(lua_State* L) {
  int SWIG_arg = 0;
  EncMap *arg1 = (EncMap *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  EncMap *result = 0 ;
  
  SWIG_check_num_args("CompactEncMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CompactEncMap",1,"EncMap *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CompactEncMap",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("CompactEncMap",1,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CompactEncMap",2,SWIGTYPE_p_splinefont);
  }
  
  result = (EncMap *)CompactEncMap(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMapNew(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int arg2 ;
  Encoding *arg3 = (Encoding *) 0 ;
  EncMap *result = 0 ;
  
  SWIG_check_num_args("EncMapNew",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("EncMapNew",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("EncMapNew",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("EncMapNew",3,"Encoding *");
  arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("EncMapNew",3,SWIGTYPE_p_enc);
  }
  
  result = (EncMap *)EncMapNew(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMap1to1(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  EncMap *result = 0 ;
  
  SWIG_check_num_args("EncMap1to1",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("EncMap1to1",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (EncMap *)EncMap1to1(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncMapCopy(lua_State* L) {
  int SWIG_arg = 0;
  EncMap *arg1 = (EncMap *) 0 ;
  EncMap *result = 0 ;
  
  SWIG_check_num_args("EncMapCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("EncMapCopy",1,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("EncMapCopy",1,SWIGTYPE_p_encmap);
  }
  
  result = (EncMap *)EncMapCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_encmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFExpandGlyphCount(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFExpandGlyphCount",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFExpandGlyphCount",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFExpandGlyphCount",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFExpandGlyphCount",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFExpandGlyphCount(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptLangListFree(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  
  SWIG_check_num_args("ScriptLangListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ScriptLangListFree",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("ScriptLangListFree",1,SWIGTYPE_p_scriptlanglist);
  }
  
  ScriptLangListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptLangListFree(lua_State* L) {
  int SWIG_arg = 0;
  FeatureScriptLangList *arg1 = (FeatureScriptLangList *) 0 ;
  
  SWIG_check_num_args("FeatureScriptLangListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FeatureScriptLangListFree",1,"FeatureScriptLangList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptLangListFree",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  FeatureScriptLangListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFBaseSort(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFBaseSort",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFBaseSort",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFBaseSort",1,SWIGTYPE_p_splinefont);
  }
  
  SFBaseSort(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BaseLangCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  struct baselangextent *result = 0 ;
  
  SWIG_check_num_args("BaseLangCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BaseLangCopy",1,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("BaseLangCopy",1,SWIGTYPE_p_baselangextent);
  }
  
  result = (struct baselangextent *)BaseLangCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_baselangextent,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BaseLangFree(lua_State* L) {
  int SWIG_arg = 0;
  struct baselangextent *arg1 = (struct baselangextent *) 0 ;
  
  SWIG_check_num_args("BaseLangFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BaseLangFree",1,"struct baselangextent *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_baselangextent,0))){
    SWIG_fail_ptr("BaseLangFree",1,SWIGTYPE_p_baselangextent);
  }
  
  BaseLangFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BaseScriptFree(lua_State* L) {
  int SWIG_arg = 0;
  struct basescript *arg1 = (struct basescript *) 0 ;
  
  SWIG_check_num_args("BaseScriptFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BaseScriptFree",1,"struct basescript *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basescript,0))){
    SWIG_fail_ptr("BaseScriptFree",1,SWIGTYPE_p_basescript);
  }
  
  BaseScriptFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BaseFree(lua_State* L) {
  int SWIG_arg = 0;
  struct Base *arg1 = (struct Base *) 0 ;
  
  SWIG_check_num_args("BaseFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BaseFree",1,"struct Base *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_Base,0))){
    SWIG_fail_ptr("BaseFree",1,SWIGTYPE_p_Base);
  }
  
  BaseFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontFree(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SplineFontFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontFree",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontFree",1,SWIGTYPE_p_splinefont);
  }
  
  SplineFontFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_JstfLangsCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  struct jstf_lang *result = 0 ;
  
  SWIG_check_num_args("JstfLangsCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("JstfLangsCopy",1,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("JstfLangsCopy",1,SWIGTYPE_p_jstf_lang);
  }
  
  result = (struct jstf_lang *)JstfLangsCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_jstf_lang,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_JstfLangFree(lua_State* L) {
  int SWIG_arg = 0;
  struct jstf_lang *arg1 = (struct jstf_lang *) 0 ;
  
  SWIG_check_num_args("JstfLangFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("JstfLangFree",1,"struct jstf_lang *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_lang,0))){
    SWIG_fail_ptr("JstfLangFree",1,SWIGTYPE_p_jstf_lang);
  }
  
  JstfLangFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_JustifyFree(lua_State* L) {
  int SWIG_arg = 0;
  Justify *arg1 = (Justify *) 0 ;
  
  SWIG_check_num_args("JustifyFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("JustifyFree",1,"Justify *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_jstf_script,0))){
    SWIG_fail_ptr("JustifyFree",1,SWIGTYPE_p_jstf_script);
  }
  
  JustifyFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MATHFree(lua_State* L) {
  int SWIG_arg = 0;
  struct MATH *arg1 = (struct MATH *) 0 ;
  
  SWIG_check_num_args("MATHFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MATHFree",1,"struct MATH *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_MATH,0))){
    SWIG_fail_ptr("MATHFree",1,SWIGTYPE_p_MATH);
  }
  
  MATHFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MathTableNew(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct MATH *result = 0 ;
  
  SWIG_check_num_args("MathTableNew",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MathTableNew",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("MathTableNew",1,SWIGTYPE_p_splinefont);
  }
  
  result = (struct MATH *)MathTableNew(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_MATH,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OtfNameListFree(lua_State* L) {
  int SWIG_arg = 0;
  struct otfname *arg1 = (struct otfname *) 0 ;
  
  SWIG_check_num_args("OtfNameListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OtfNameListFree",1,"struct otfname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otfname,0))){
    SWIG_fail_ptr("OtfNameListFree",1,SWIGTYPE_p_otfname);
  }
  
  OtfNameListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OtfFeatNameListFree(lua_State* L) {
  int SWIG_arg = 0;
  struct otffeatname *arg1 = (struct otffeatname *) 0 ;
  
  SWIG_check_num_args("OtfFeatNameListFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OtfFeatNameListFree",1,"struct otffeatname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otffeatname,0))){
    SWIG_fail_ptr("OtfFeatNameListFree",1,SWIGTYPE_p_otffeatname);
  }
  
  OtfFeatNameListFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_findotffeatname(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  struct otffeatname *result = 0 ;
  
  SWIG_check_num_args("findotffeatname",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("findotffeatname",1,"uint32");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("findotffeatname",2,"SplineFont *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("findotffeatname",2,SWIGTYPE_p_splinefont);
  }
  
  result = (struct otffeatname *)findotffeatname(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otffeatname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MarkSetFree(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char **arg2 = (char **) 0 ;
  char **arg3 = (char **) 0 ;
  
  SWIG_check_num_args("MarkSetFree",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("MarkSetFree",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MarkSetFree",2,"char **");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("MarkSetFree",3,"char **");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("MarkSetFree",2,SWIGTYPE_p_p_char);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("MarkSetFree",3,SWIGTYPE_p_p_char);
  }
  
  MarkSetFree(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MarkClassFree(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char **arg2 = (char **) 0 ;
  char **arg3 = (char **) 0 ;
  
  SWIG_check_num_args("MarkClassFree",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("MarkClassFree",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MarkClassFree",2,"char **");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("MarkClassFree",3,"char **");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("MarkClassFree",2,SWIGTYPE_p_p_char);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("MarkClassFree",3,SWIGTYPE_p_p_char);
  }
  
  MarkClassFree(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSetFreeContents(lua_State* L) {
  int SWIG_arg = 0;
  MMSet *arg1 = (MMSet *) 0 ;
  
  SWIG_check_num_args("MMSetFreeContents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSetFreeContents",1,"MMSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSetFreeContents",1,SWIGTYPE_p_mmset);
  }
  
  MMSetFreeContents(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMSetFree(lua_State* L) {
  int SWIG_arg = 0;
  MMSet *arg1 = (MMSet *) 0 ;
  
  SWIG_check_num_args("MMSetFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMSetFree",1,"MMSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMSetFree",1,SWIGTYPE_p_mmset);
  }
  
  MMSetFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveUndoes(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint8 *arg2 = (uint8 *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  
  SWIG_check_num_args("SFRemoveUndoes",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveUndoes",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFRemoveUndoes",2,"uint8 *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFRemoveUndoes",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveUndoes",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("SFRemoveUndoes",2,SWIGTYPE_p_unsigned_char);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFRemoveUndoes",3,SWIGTYPE_p_encmap);
  }
  
  SFRemoveUndoes(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineRefigure3(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  
  SWIG_check_num_args("SplineRefigure3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineRefigure3",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineRefigure3",1,SWIGTYPE_p_spline);
  }
  
  SplineRefigure3(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineRefigure(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  
  SWIG_check_num_args("SplineRefigure",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineRefigure",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineRefigure",1,SWIGTYPE_p_spline);
  }
  
  SplineRefigure(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineMake3(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("SplineMake3",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineMake3",1,"SplinePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineMake3",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineMake3",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineMake3",2,SWIGTYPE_p_splinepoint);
  }
  
  result = (Spline *)SplineMake3(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineApproximate(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  float arg2 ;
  LinearApprox *result = 0 ;
  
  SWIG_check_num_args("SplineApproximate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineApproximate",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineApproximate",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineApproximate",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  result = (LinearApprox *)SplineApproximate(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_linearapprox,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListIsClockwise(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SplinePointListIsClockwise",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListIsClockwise",1,"SplineSet const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListIsClockwise",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SplinePointListIsClockwise((struct splinepointlist const *)arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineSetFindBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetFindBounds",1,"SplinePointList const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetFindBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetFindBounds",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineSetFindBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineSetFindBounds((struct splinepointlist const *)arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharLayerFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  DBounds *arg3 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineCharLayerFindBounds",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharLayerFindBounds",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharLayerFindBounds",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineCharLayerFindBounds",3,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharLayerFindBounds",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineCharLayerFindBounds",3,SWIGTYPE_p_dbounds);
  }
  
  SplineCharLayerFindBounds(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineCharFindBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharFindBounds",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharFindBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharFindBounds",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineCharFindBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineCharFindBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontLayerFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  DBounds *arg3 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineFontLayerFindBounds",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontLayerFindBounds",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontLayerFindBounds",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineFontLayerFindBounds",3,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontLayerFindBounds",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineFontLayerFindBounds",3,SWIGTYPE_p_dbounds);
  }
  
  SplineFontLayerFindBounds(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineFontFindBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontFindBounds",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFontFindBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontFindBounds",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineFontFindBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineFontFindBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CIDLayerFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  DBounds *arg3 = (DBounds *) 0 ;
  
  SWIG_check_num_args("CIDLayerFindBounds",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CIDLayerFindBounds",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CIDLayerFindBounds",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("CIDLayerFindBounds",3,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CIDLayerFindBounds",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("CIDLayerFindBounds",3,SWIGTYPE_p_dbounds);
  }
  
  CIDLayerFindBounds(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetQuickBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineSetQuickBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetQuickBounds",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetQuickBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetQuickBounds",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineSetQuickBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineSetQuickBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharLayerQuickBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  DBounds *arg3 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineCharLayerQuickBounds",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharLayerQuickBounds",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharLayerQuickBounds",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineCharLayerQuickBounds",3,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharLayerQuickBounds",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineCharLayerQuickBounds",3,SWIGTYPE_p_dbounds);
  }
  
  SplineCharLayerQuickBounds(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharQuickBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineCharQuickBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharQuickBounds",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharQuickBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharQuickBounds",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineCharQuickBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineCharQuickBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetQuickConservativeBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineSetQuickConservativeBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetQuickConservativeBounds",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetQuickConservativeBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetQuickConservativeBounds",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineSetQuickConservativeBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineSetQuickConservativeBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharQuickConservativeBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineCharQuickConservativeBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharQuickConservativeBounds",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharQuickConservativeBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharQuickConservativeBounds",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineCharQuickConservativeBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineCharQuickConservativeBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontQuickConservativeBounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  DBounds *arg2 = (DBounds *) 0 ;
  
  SWIG_check_num_args("SplineFontQuickConservativeBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontQuickConservativeBounds",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFontQuickConservativeBounds",2,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontQuickConservativeBounds",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineFontQuickConservativeBounds",2,SWIGTYPE_p_dbounds);
  }
  
  SplineFontQuickConservativeBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointCatagorize(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplinePointCatagorize",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointCatagorize",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePointCatagorize",1,SWIGTYPE_p_splinepoint);
  }
  
  SplinePointCatagorize(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointIsACorner(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("SplinePointIsACorner",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointIsACorner",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePointIsACorner",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (int)SplinePointIsACorner(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLCatagorizePoints(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SPLCatagorizePoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLCatagorizePoints",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SPLCatagorizePoints",1,SWIGTYPE_p_splinepointlist);
  }
  
  SPLCatagorizePoints(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCCatagorizePoints(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCCatagorizePoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCCatagorizePoints",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCCatagorizePoints",1,SWIGTYPE_p_splinechar);
  }
  
  SCCatagorizePoints(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListCopy1(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListCopy1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListCopy1",1,"SplinePointList const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListCopy1",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplinePointList *)SplinePointListCopy1((struct splinepointlist const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListCopy(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListCopy",1,"SplinePointList const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListCopy",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplinePointList *)SplinePointListCopy((struct splinepointlist const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListCopySelected(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListCopySelected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListCopySelected",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListCopySelected",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplinePointList *)SplinePointListCopySelected(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListCopySpiroSelected(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListCopySpiroSelected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListCopySpiroSelected",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListCopySpiroSelected",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplinePointList *)SplinePointListCopySpiroSelected(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageListCopy(lua_State* L) {
  int SWIG_arg = 0;
  ImageList *arg1 = (ImageList *) 0 ;
  ImageList *result = 0 ;
  
  SWIG_check_num_args("ImageListCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ImageListCopy",1,"ImageList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageListCopy",1,SWIGTYPE_p_imagelist);
  }
  
  result = (ImageList *)ImageListCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_imagelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ImageListTransform(lua_State* L) {
  int SWIG_arg = 0;
  ImageList *arg1 = (ImageList *) 0 ;
  float *arg2 ;
  int arg3 ;
  ImageList *result = 0 ;
  
  SWIG_check_num_args("ImageListTransform",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ImageListTransform",1,"ImageList *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ImageListTransform",2,"float [6]");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ImageListTransform",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("ImageListTransform",1,SWIGTYPE_p_imagelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ImageListTransform",2,SWIGTYPE_p_float);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (ImageList *)ImageListTransform(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_imagelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BpTransform(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  float *arg3 ;
  
  SWIG_check_num_args("BpTransform",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BpTransform",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BpTransform",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BpTransform",3,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpTransform",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpTransform",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("BpTransform",3,SWIGTYPE_p_float);
  }
  
  BpTransform(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ApTransform(lua_State* L) {
  int SWIG_arg = 0;
  AnchorPoint *arg1 = (AnchorPoint *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("ApTransform",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ApTransform",1,"AnchorPoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ApTransform",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_anchorpoint,0))){
    SWIG_fail_ptr("ApTransform",1,SWIGTYPE_p_anchorpoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("ApTransform",2,SWIGTYPE_p_float);
  }
  
  ApTransform(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListTransform(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  float *arg2 ;
  enum transformPointType arg3 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListTransform",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListTransform",1,"SplinePointList *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointListTransform",2,"float [6]");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplinePointListTransform",3,"enum transformPointType");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListTransform",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("SplinePointListTransform",2,SWIGTYPE_p_float);
  }
  
  arg3 = (enum transformPointType)(int)lua_tonumber(L, 3);
  result = (SplinePointList *)SplinePointListTransform(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListSpiroTransform(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  float *arg2 ;
  int arg3 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListSpiroTransform",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListSpiroTransform",1,"SplinePointList *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointListSpiroTransform",2,"float [6]");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplinePointListSpiroTransform",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListSpiroTransform",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("SplinePointListSpiroTransform",2,SWIGTYPE_p_float);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (SplinePointList *)SplinePointListSpiroTransform(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListShift(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  float arg2 ;
  enum transformPointType arg3 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListShift",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListShift",1,"SplinePointList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplinePointListShift",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplinePointListShift",3,"enum transformPointType");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListShift",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (enum transformPointType)(int)lua_tonumber(L, 3);
  result = (SplinePointList *)SplinePointListShift(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintMaskFromTransformedRef(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  HintMask *arg4 = (HintMask *) 0 ;
  HintMask *result = 0 ;
  
  SWIG_check_num_args("HintMaskFromTransformedRef",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HintMaskFromTransformedRef",1,"RefChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("HintMaskFromTransformedRef",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("HintMaskFromTransformedRef",3,"SplineChar *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("HintMaskFromTransformedRef",4,"HintMask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("HintMaskFromTransformedRef",1,SWIGTYPE_p_refchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("HintMaskFromTransformedRef",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("HintMaskFromTransformedRef",3,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_a_96_8__unsigned_char,0))){
    SWIG_fail_ptr("HintMaskFromTransformedRef",4,SWIGTYPE_p_a_96_8__unsigned_char);
  }
  
  result = (HintMask *)HintMaskFromTransformedRef(arg1,arg2,arg3,(unsigned char (*)[96/8])arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_a_96_8__unsigned_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLCopyTranslatedHintMasks(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  BasePoint *arg4 = (BasePoint *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SPLCopyTranslatedHintMasks",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLCopyTranslatedHintMasks",1,"SplinePointList *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SPLCopyTranslatedHintMasks",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SPLCopyTranslatedHintMasks",3,"SplineChar *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SPLCopyTranslatedHintMasks",4,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SPLCopyTranslatedHintMasks",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLCopyTranslatedHintMasks",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLCopyTranslatedHintMasks",3,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SPLCopyTranslatedHintMasks",4,SWIGTYPE_p_basepoint);
  }
  
  result = (SplinePointList *)SPLCopyTranslatedHintMasks(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLCopyTransformedHintMasks(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  int arg4 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SPLCopyTransformedHintMasks",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLCopyTransformedHintMasks",1,"RefChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SPLCopyTransformedHintMasks",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SPLCopyTransformedHintMasks",3,"BasePoint *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SPLCopyTransformedHintMasks",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("SPLCopyTransformedHintMasks",1,SWIGTYPE_p_refchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLCopyTransformedHintMasks",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SPLCopyTransformedHintMasks",3,SWIGTYPE_p_basepoint);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (SplinePointList *)SPLCopyTransformedHintMasks(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListRemoveSelected(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListRemoveSelected",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListRemoveSelected",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointListRemoveSelected",2,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplinePointListRemoveSelected",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListRemoveSelected",2,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplinePointList *)SplinePointListRemoveSelected(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListSet(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SplinePointListSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListSet",1,"SplinePointList *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointListSet",2,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListSet",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListSet",2,SWIGTYPE_p_splinepointlist);
  }
  
  SplinePointListSet(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListSelect(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SplinePointListSelect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListSelect",1,"SplinePointList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplinePointListSelect",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListSelect",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SplinePointListSelect(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCRefToSplines(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  RefChar *arg2 = (RefChar *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("SCRefToSplines",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCRefToSplines",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCRefToSplines",2,"RefChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCRefToSplines",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCRefToSplines",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("SCRefToSplines",2,SWIGTYPE_p_refchar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  SCRefToSplines(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefCharFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  
  SWIG_check_num_args("RefCharFindBounds",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefCharFindBounds",1,"RefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefCharFindBounds",1,SWIGTYPE_p_refchar);
  }
  
  RefCharFindBounds(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCReinstanciateRefChar(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  RefChar *arg2 = (RefChar *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("SCReinstanciateRefChar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCReinstanciateRefChar",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCReinstanciateRefChar",2,"RefChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCReinstanciateRefChar",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCReinstanciateRefChar",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("SCReinstanciateRefChar",2,SWIGTYPE_p_refchar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  SCReinstanciateRefChar(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCReinstanciateRef(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("SCReinstanciateRef",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCReinstanciateRef",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCReinstanciateRef",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCReinstanciateRef",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCReinstanciateRef",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCReinstanciateRef",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  SCReinstanciateRef(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReinstanciateRefs(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFReinstanciateRefs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFReinstanciateRefs",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFReinstanciateRefs",1,SWIGTYPE_p_splinefont);
  }
  
  SFReinstanciateRefs(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFInstanciateRefs(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFInstanciateRefs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFInstanciateRefs",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFInstanciateRefs",1,SWIGTYPE_p_splinefont);
  }
  
  SFInstanciateRefs(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCRemoveDependent(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  RefChar *arg2 = (RefChar *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("SCRemoveDependent",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCRemoveDependent",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCRemoveDependent",2,"RefChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCRemoveDependent",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCRemoveDependent",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("SCRemoveDependent",2,SWIGTYPE_p_refchar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  SCRemoveDependent(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCRemoveLayerDependents(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCRemoveLayerDependents",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCRemoveLayerDependents",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCRemoveLayerDependents",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCRemoveLayerDependents",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCRemoveLayerDependents(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCRemoveDependents(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCRemoveDependents",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCRemoveDependents",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCRemoveDependents",1,SWIGTYPE_p_splinechar);
  }
  
  SCRemoveDependents(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCDependsOnSC(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int result;
  
  SWIG_check_num_args("SCDependsOnSC",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCDependsOnSC",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCDependsOnSC",2,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCDependsOnSC",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCDependsOnSC",2,SWIGTYPE_p_splinechar);
  }
  
  result = (int)SCDependsOnSC(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCCompressBitmap(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCCompressBitmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCCompressBitmap",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCCompressBitmap",1,SWIGTYPE_p_bdfchar);
  }
  
  BCCompressBitmap(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCRegularizeBitmap(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCRegularizeBitmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCRegularizeBitmap",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCRegularizeBitmap",1,SWIGTYPE_p_bdfchar);
  }
  
  BCRegularizeBitmap(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCRegularizeGreymap(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCRegularizeGreymap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCRegularizeGreymap",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCRegularizeGreymap",1,SWIGTYPE_p_bdfchar);
  }
  
  BCRegularizeGreymap(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCPasteInto(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  BDFChar *arg2 = (BDFChar *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  
  SWIG_check_num_args("BCPasteInto",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCPasteInto",1,"BDFChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BCPasteInto",2,"BDFChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BCPasteInto",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("BCPasteInto",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("BCPasteInto",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("BCPasteInto",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCPasteInto",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCPasteInto",2,SWIGTYPE_p_bdfchar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  BCPasteInto(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCRotateCharForVert(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  BDFChar *arg2 = (BDFChar *) 0 ;
  BDFFont *arg3 = (BDFFont *) 0 ;
  
  SWIG_check_num_args("BCRotateCharForVert",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCRotateCharForVert",1,"BDFChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BCRotateCharForVert",2,"BDFChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BCRotateCharForVert",3,"BDFFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCRotateCharForVert",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCRotateCharForVert",2,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BCRotateCharForVert",3,SWIGTYPE_p_bdffont);
  }
  
  BCRotateCharForVert(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharRasterize(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  double arg3 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharRasterize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharRasterize",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharRasterize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineCharRasterize",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharRasterize",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3);
  result = (BDFChar *)SplineCharRasterize(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontToBDFHeader(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontToBDFHeader",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontToBDFHeader",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontToBDFHeader",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFontToBDFHeader",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontToBDFHeader",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (BDFFont *)SplineFontToBDFHeader(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontRasterize(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontRasterize",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontRasterize",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontRasterize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFontRasterize",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineFontRasterize",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontRasterize",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (BDFFont *)SplineFontRasterize(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFCAntiAlias(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("BDFCAntiAlias",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFCAntiAlias",1,"BDFChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BDFCAntiAlias",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFCAntiAlias",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  BDFCAntiAlias(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharAntiAlias(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharAntiAlias",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharAntiAlias",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharAntiAlias",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineCharAntiAlias",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineCharAntiAlias",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharAntiAlias",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (BDFChar *)SplineCharAntiAlias(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontAntiAlias(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontAntiAlias",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontAntiAlias",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontAntiAlias",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFontAntiAlias",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineFontAntiAlias",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontAntiAlias",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (BDFFont *)SplineFontAntiAlias(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__BDFClut(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  struct clut *result = 0 ;
  
  SWIG_check_num_args("_BDFClut",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("_BDFClut",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (struct clut *)_BDFClut(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_clut,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFClut(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("BDFClut",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFClut",1,"BDFFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BDFClut",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFClut",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  BDFClut(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFDepth(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  int result;
  
  SWIG_check_num_args("BDFDepth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFDepth",1,"BDFFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFDepth",1,SWIGTYPE_p_bdffont);
  }
  
  result = (int)BDFDepth(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFPieceMeal(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  int arg2 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("BDFPieceMeal",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFPieceMeal",1,"BDFFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BDFPieceMeal",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFPieceMeal",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (BDFChar *)BDFPieceMeal(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFPieceMealCheck(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  int arg2 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("BDFPieceMealCheck",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFPieceMealCheck",1,"BDFFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BDFPieceMealCheck",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFPieceMealCheck",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (BDFChar *)BDFPieceMealCheck(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontPieceMeal(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  void *arg6 = (void *) 0 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontPieceMeal",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontPieceMeal",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontPieceMeal",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFontPieceMeal",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineFontPieceMeal",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplineFontPieceMeal",5,"int");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("SplineFontPieceMeal",6,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontPieceMeal",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6=(void *)SWIG_MustGetPtr(L,6,0,0,6,"SplineFontPieceMeal");
  result = (BDFFont *)SplineFontPieceMeal(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFCharFindBounds(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  IBounds *arg2 = (IBounds *) 0 ;
  
  SWIG_check_num_args("BDFCharFindBounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFCharFindBounds",1,"BDFChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BDFCharFindBounds",2,"IBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFCharFindBounds",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("BDFCharFindBounds",2,SWIGTYPE_p_ibounds);
  }
  
  BDFCharFindBounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFCharQuickBounds(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  IBounds *arg2 = (IBounds *) 0 ;
  int8 arg3 ;
  int8 arg4 ;
  int arg5 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("BDFCharQuickBounds",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFCharQuickBounds",1,"BDFChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BDFCharQuickBounds",2,"IBounds *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BDFCharQuickBounds",3,"int8");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("BDFCharQuickBounds",4,"int8");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("BDFCharQuickBounds",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("BDFCharQuickBounds",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFCharQuickBounds",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ibounds,0))){
    SWIG_fail_ptr("BDFCharQuickBounds",2,SWIGTYPE_p_ibounds);
  }
  
  arg3 = (int8)lua_tonumber(L, 3);
  arg4 = (int8)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)BDFCharQuickBounds(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCPrepareForOutput(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("BCPrepareForOutput",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCPrepareForOutput",1,"BDFChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BCPrepareForOutput",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCPrepareForOutput",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  BCPrepareForOutput(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCRestoreAfterOutput(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCRestoreAfterOutput",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCRestoreAfterOutput",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCRestoreAfterOutput",1,SWIGTYPE_p_bdfchar);
  }
  
  BCRestoreAfterOutput(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCMakeDependent(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  BDFChar *arg2 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCMakeDependent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCMakeDependent",1,"BDFChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BCMakeDependent",2,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCMakeDependent",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCMakeDependent",2,SWIGTYPE_p_bdfchar);
  }
  
  BCMakeDependent(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCRemoveDependent(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  BDFRefChar *arg2 = (BDFRefChar *) 0 ;
  
  SWIG_check_num_args("BCRemoveDependent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCRemoveDependent",1,"BDFChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BCRemoveDependent",2,"BDFRefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCRemoveDependent",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_refbdfc,0))){
    SWIG_fail_ptr("BCRemoveDependent",2,SWIGTYPE_p_refbdfc);
  }
  
  BCRemoveDependent(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCExpandBitmapToEmBox(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  
  SWIG_check_num_args("BCExpandBitmapToEmBox",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCExpandBitmapToEmBox",1,"BDFChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BCExpandBitmapToEmBox",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BCExpandBitmapToEmBox",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("BCExpandBitmapToEmBox",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("BCExpandBitmapToEmBox",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCExpandBitmapToEmBox",1,SWIGTYPE_p_bdfchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  BCExpandBitmapToEmBox(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BitmapFontScaleTo(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  int arg2 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("BitmapFontScaleTo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BitmapFontScaleTo",1,"BDFFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BitmapFontScaleTo",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BitmapFontScaleTo",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (BDFFont *)BitmapFontScaleTo(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFCharFree(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BDFCharFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFCharFree",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BDFCharFree",1,SWIGTYPE_p_bdfchar);
  }
  
  BDFCharFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFPropsFree(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  
  SWIG_check_num_args("BDFPropsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFPropsFree",1,"BDFFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFPropsFree",1,SWIGTYPE_p_bdffont);
  }
  
  BDFPropsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFontFree(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  
  SWIG_check_num_args("BDFFontFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFFontFree",1,"BDFFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFontFree",1,SWIGTYPE_p_bdffont);
  }
  
  BDFFontFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDefaultAscent(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFDefaultAscent",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDefaultAscent",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDefaultAscent",1,SWIGTYPE_p_splinefont);
  }
  
  SFDefaultAscent(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSBitmapDump(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  BDFFont *arg2 = (BDFFont *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("PSBitmapDump",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("PSBitmapDump",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PSBitmapDump",2,"BDFFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PSBitmapDump",3,"EncMap *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("PSBitmapDump",2,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("PSBitmapDump",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)PSBitmapDump(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFontDump(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  BDFFont *arg2 = (BDFFont *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("BDFFontDump",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("BDFFontDump",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BDFFontDump",2,"BDFFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BDFFontDump",3,"EncMap *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("BDFFontDump",4,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFFontDump",2,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("BDFFontDump",3,SWIGTYPE_p_encmap);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)BDFFontDump(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FNTFontDump(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  BDFFont *arg2 = (BDFFont *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("FNTFontDump",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("FNTFontDump",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FNTFontDump",2,"BDFFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FNTFontDump",3,"EncMap *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("FNTFontDump",4,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("FNTFontDump",2,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("FNTFontDump",3,SWIGTYPE_p_encmap);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)FNTFontDump(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FONFontDump(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int32 *arg3 = (int32 *) 0 ;
  int arg4 ;
  EncMap *arg5 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("FONFontDump",5,5)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("FONFontDump",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FONFontDump",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FONFontDump",3,"int32 *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("FONFontDump",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("FONFontDump",5,"EncMap *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FONFontDump",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("FONFontDump",3,SWIGTYPE_p_int);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("FONFontDump",5,SWIGTYPE_p_encmap);
  }
  
  result = (int)FONFontDump(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReplaceEncodingBDFProps(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  
  SWIG_check_num_args("SFReplaceEncodingBDFProps",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFReplaceEncodingBDFProps",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFReplaceEncodingBDFProps",2,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFReplaceEncodingBDFProps",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFReplaceEncodingBDFProps",2,SWIGTYPE_p_encmap);
  }
  
  SFReplaceEncodingBDFProps(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReplaceFontnameBDFProps(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFReplaceFontnameBDFProps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFReplaceFontnameBDFProps",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFReplaceFontnameBDFProps",1,SWIGTYPE_p_splinefont);
  }
  
  SFReplaceFontnameBDFProps(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IsUnsignedBDFKey(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("IsUnsignedBDFKey",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("IsUnsignedBDFKey",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (int)IsUnsignedBDFKey(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BdfPropHasInt(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("BdfPropHasInt",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BdfPropHasInt",1,"BDFFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("BdfPropHasInt",2,"char const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BdfPropHasInt",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BdfPropHasInt",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)BdfPropHasInt(arg1,(char const *)arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BdfPropHasString(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("BdfPropHasString",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BdfPropHasString",1,"BDFFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("BdfPropHasString",2,"char const *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("BdfPropHasString",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BdfPropHasString",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (char *)BdfPropHasString(arg1,(char const *)arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_def_Charset_Enc(lua_State* L) {
  int SWIG_arg = 0;
  EncMap *arg1 = (EncMap *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  
  SWIG_check_num_args("def_Charset_Enc",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("def_Charset_Enc",1,"EncMap *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("def_Charset_Enc",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("def_Charset_Enc",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("def_Charset_Enc",1,SWIGTYPE_p_encmap);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  def_Charset_Enc(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Default_XLFD(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("Default_XLFD",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Default_XLFD",1,"BDFFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Default_XLFD",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Default_XLFD",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("Default_XLFD",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("Default_XLFD",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  Default_XLFD(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Default_Properties(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  char *arg3 = (char *) 0 ;
  
  SWIG_check_num_args("Default_Properties",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Default_Properties",1,"BDFFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Default_Properties",2,"EncMap *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("Default_Properties",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("Default_Properties",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("Default_Properties",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  Default_Properties(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFDefaultProps(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("BDFDefaultProps",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFDefaultProps",1,"BDFFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BDFDefaultProps",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BDFDefaultProps",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFDefaultProps",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("BDFDefaultProps",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  BDFDefaultProps(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BdfPropsCopy(lua_State* L) {
  int SWIG_arg = 0;
  BDFProperties *arg1 = (BDFProperties *) 0 ;
  int arg2 ;
  BDFProperties *result = 0 ;
  
  SWIG_check_num_args("BdfPropsCopy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BdfPropsCopy",1,"BDFProperties *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BdfPropsCopy",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfprops,0))){
    SWIG_fail_ptr("BdfPropsCopy",1,SWIGTYPE_p_bdfprops);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (BDFProperties *)BdfPropsCopy(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfprops,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_foundry_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::foundry",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::foundry",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::foundry",2,"char [80]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_foundry_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->foundry, (const char *)arg2, 80-1);
      arg1->foundry[80-1] = 0;
    } else {
      arg1->foundry[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_foundry_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::foundry",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::foundry",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_foundry_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->foundry);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_family_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::family",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::family",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::family",2,"char [100]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_family_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->family, (const char *)arg2, 100-1);
      arg1->family[100-1] = 0;
    } else {
      arg1->family[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_family_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::family",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::family",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_family_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->family);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_weight_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::weight",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::weight",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::weight",2,"char [80]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_weight_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->weight, (const char *)arg2, 80-1);
      arg1->weight[80-1] = 0;
    } else {
      arg1->weight[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_weight_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::weight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::weight",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_weight_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->weight);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_slant_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::slant",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::slant",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::slant",2,"char [40]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_slant_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->slant, (const char *)arg2, 40-1);
      arg1->slant[40-1] = 0;
    } else {
      arg1->slant[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_slant_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::slant",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::slant",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_slant_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->slant);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_setwidth_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::setwidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::setwidth",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::setwidth",2,"char [50]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_setwidth_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->setwidth, (const char *)arg2, 50-1);
      arg1->setwidth[50-1] = 0;
    } else {
      arg1->setwidth[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_setwidth_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::setwidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::setwidth",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_setwidth_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->setwidth);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_add_style_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::add_style",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::add_style",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::add_style",2,"char [50]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_add_style_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->add_style, (const char *)arg2, 50-1);
      arg1->add_style[50-1] = 0;
    } else {
      arg1->add_style[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_add_style_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::add_style",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::add_style",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_add_style_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->add_style);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_pixel_size_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("xlfd_components::pixel_size",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::pixel_size",1,"struct xlfd_components *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("xlfd_components::pixel_size",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_pixel_size_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->pixel_size = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_pixel_size_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int result;
  
  SWIG_check_num_args("xlfd_components::pixel_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::pixel_size",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_pixel_size_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (int) ((arg1)->pixel_size);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_point_size_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("xlfd_components::point_size",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::point_size",1,"struct xlfd_components *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("xlfd_components::point_size",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_point_size_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->point_size = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_point_size_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int result;
  
  SWIG_check_num_args("xlfd_components::point_size",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::point_size",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_point_size_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (int) ((arg1)->point_size);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_res_x_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("xlfd_components::res_x",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::res_x",1,"struct xlfd_components *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("xlfd_components::res_x",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_res_x_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->res_x = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_res_x_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int result;
  
  SWIG_check_num_args("xlfd_components::res_x",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::res_x",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_res_x_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (int) ((arg1)->res_x);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_res_y_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("xlfd_components::res_y",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::res_y",1,"struct xlfd_components *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("xlfd_components::res_y",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_res_y_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->res_y = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_res_y_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int result;
  
  SWIG_check_num_args("xlfd_components::res_y",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::res_y",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_res_y_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (int) ((arg1)->res_y);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_spacing_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::spacing",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::spacing",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::spacing",2,"char [40]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_spacing_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->spacing, (const char *)arg2, 40-1);
      arg1->spacing[40-1] = 0;
    } else {
      arg1->spacing[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_spacing_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::spacing",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::spacing",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_spacing_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->spacing);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_avg_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("xlfd_components::avg_width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::avg_width",1,"struct xlfd_components *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("xlfd_components::avg_width",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_avg_width_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->avg_width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_avg_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int result;
  
  SWIG_check_num_args("xlfd_components::avg_width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::avg_width",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_avg_width_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (int) ((arg1)->avg_width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_cs_reg_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::cs_reg",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::cs_reg",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::cs_reg",2,"char [80]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_cs_reg_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->cs_reg, (const char *)arg2, 80-1);
      arg1->cs_reg[80-1] = 0;
    } else {
      arg1->cs_reg[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_cs_reg_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::cs_reg",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::cs_reg",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_cs_reg_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->cs_reg);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_cs_enc_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *arg2 ;
  
  SWIG_check_num_args("xlfd_components::cs_enc",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::cs_enc",1,"struct xlfd_components *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("xlfd_components::cs_enc",2,"char [80]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_cs_enc_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if(arg2) {
      strncpy((char*)arg1->cs_enc, (const char *)arg2, 80-1);
      arg1->cs_enc[80-1] = 0;
    } else {
      arg1->cs_enc[0] = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_cs_enc_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::cs_enc",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::cs_enc",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_cs_enc_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (char *)(char *) ((arg1)->cs_enc);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_char_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("xlfd_components::char_cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::char_cnt",1,"struct xlfd_components *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("xlfd_components::char_cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_char_cnt_set",1,SWIGTYPE_p_xlfd_components);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->char_cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xlfd_components_char_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *arg1 = (struct xlfd_components *) 0 ;
  int result;
  
  SWIG_check_num_args("xlfd_components::char_cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("xlfd_components::char_cnt",1,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("xlfd_components_char_cnt_get",1,SWIGTYPE_p_xlfd_components);
  }
  
  result = (int) ((arg1)->char_cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_xlfd_components(lua_State* L) {
  int SWIG_arg = 0;
  struct xlfd_components *result = 0 ;
  
  SWIG_check_num_args("xlfd_components::xlfd_components",0,0)
  result = (struct xlfd_components *)calloc(1, sizeof(struct xlfd_components));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_xlfd_components,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_xlfd_components(void *obj) {
struct xlfd_components *arg1 = (struct xlfd_components *) obj;
free((char *) arg1);
}
static swig_lua_method swig_xlfd_components_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_xlfd_components_attributes[] = {
    { "foundry", _wrap_xlfd_components_foundry_get, _wrap_xlfd_components_foundry_set},
    { "family", _wrap_xlfd_components_family_get, _wrap_xlfd_components_family_set},
    { "weight", _wrap_xlfd_components_weight_get, _wrap_xlfd_components_weight_set},
    { "slant", _wrap_xlfd_components_slant_get, _wrap_xlfd_components_slant_set},
    { "setwidth", _wrap_xlfd_components_setwidth_get, _wrap_xlfd_components_setwidth_set},
    { "add_style", _wrap_xlfd_components_add_style_get, _wrap_xlfd_components_add_style_set},
    { "pixel_size", _wrap_xlfd_components_pixel_size_get, _wrap_xlfd_components_pixel_size_set},
    { "point_size", _wrap_xlfd_components_point_size_get, _wrap_xlfd_components_point_size_set},
    { "res_x", _wrap_xlfd_components_res_x_get, _wrap_xlfd_components_res_x_set},
    { "res_y", _wrap_xlfd_components_res_y_get, _wrap_xlfd_components_res_y_set},
    { "spacing", _wrap_xlfd_components_spacing_get, _wrap_xlfd_components_spacing_set},
    { "avg_width", _wrap_xlfd_components_avg_width_get, _wrap_xlfd_components_avg_width_set},
    { "cs_reg", _wrap_xlfd_components_cs_reg_get, _wrap_xlfd_components_cs_reg_set},
    { "cs_enc", _wrap_xlfd_components_cs_enc_get, _wrap_xlfd_components_cs_enc_set},
    { "char_cnt", _wrap_xlfd_components_char_cnt_get, _wrap_xlfd_components_char_cnt_set},
    {0,0,0}
};
static swig_lua_class *swig_xlfd_components_bases[] = {0};
static const char *swig_xlfd_components_base_names[] = {0};
static swig_lua_class _wrap_class_xlfd_components = { "xlfd_components", &SWIGTYPE_p_xlfd_components,_wrap_new_xlfd_components, swig_delete_xlfd_components, swig_xlfd_components_methods, swig_xlfd_components_attributes, swig_xlfd_components_bases, swig_xlfd_components_base_names };

static int _wrap_std_bdf_props_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct std_bdf_props *arg1 = (struct std_bdf_props *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("std_bdf_props::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std_bdf_props::name",1,"struct std_bdf_props *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("std_bdf_props::name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std_bdf_props,0))){
    SWIG_fail_ptr("std_bdf_props_name_set",1,SWIGTYPE_p_std_bdf_props);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->name);
    if (arg2) {
      arg1->name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_std_bdf_props_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct std_bdf_props *arg1 = (struct std_bdf_props *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("std_bdf_props::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std_bdf_props::name",1,"struct std_bdf_props *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std_bdf_props,0))){
    SWIG_fail_ptr("std_bdf_props_name_get",1,SWIGTYPE_p_std_bdf_props);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_std_bdf_props_type_set(lua_State* L) {
  int SWIG_arg = 0;
  struct std_bdf_props *arg1 = (struct std_bdf_props *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("std_bdf_props::type",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std_bdf_props::type",1,"struct std_bdf_props *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std_bdf_props::type",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std_bdf_props,0))){
    SWIG_fail_ptr("std_bdf_props_type_set",1,SWIGTYPE_p_std_bdf_props);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->type = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_std_bdf_props_type_get(lua_State* L) {
  int SWIG_arg = 0;
  struct std_bdf_props *arg1 = (struct std_bdf_props *) 0 ;
  int result;
  
  SWIG_check_num_args("std_bdf_props::type",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std_bdf_props::type",1,"struct std_bdf_props *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std_bdf_props,0))){
    SWIG_fail_ptr("std_bdf_props_type_get",1,SWIGTYPE_p_std_bdf_props);
  }
  
  result = (int) ((arg1)->type);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_std_bdf_props_defaultable_set(lua_State* L) {
  int SWIG_arg = 0;
  struct std_bdf_props *arg1 = (struct std_bdf_props *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("std_bdf_props::defaultable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std_bdf_props::defaultable",1,"struct std_bdf_props *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("std_bdf_props::defaultable",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std_bdf_props,0))){
    SWIG_fail_ptr("std_bdf_props_defaultable_set",1,SWIGTYPE_p_std_bdf_props);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->defaultable = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_std_bdf_props_defaultable_get(lua_State* L) {
  int SWIG_arg = 0;
  struct std_bdf_props *arg1 = (struct std_bdf_props *) 0 ;
  int result;
  
  SWIG_check_num_args("std_bdf_props::defaultable",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("std_bdf_props::defaultable",1,"struct std_bdf_props *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_std_bdf_props,0))){
    SWIG_fail_ptr("std_bdf_props_defaultable_get",1,SWIGTYPE_p_std_bdf_props);
  }
  
  result = (int) ((arg1)->defaultable);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_std_bdf_props(lua_State* L) {
  int SWIG_arg = 0;
  struct std_bdf_props *result = 0 ;
  
  SWIG_check_num_args("std_bdf_props::std_bdf_props",0,0)
  result = (struct std_bdf_props *)calloc(1, sizeof(struct std_bdf_props));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_std_bdf_props,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_std_bdf_props(void *obj) {
struct std_bdf_props *arg1 = (struct std_bdf_props *) obj;
free((char *) arg1);
}
static swig_lua_method swig_std_bdf_props_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_std_bdf_props_attributes[] = {
    { "name", _wrap_std_bdf_props_name_get, _wrap_std_bdf_props_name_set},
    { "type", _wrap_std_bdf_props_type_get, _wrap_std_bdf_props_type_set},
    { "defaultable", _wrap_std_bdf_props_defaultable_get, _wrap_std_bdf_props_defaultable_set},
    {0,0,0}
};
static swig_lua_class *swig_std_bdf_props_bases[] = {0};
static const char *swig_std_bdf_props_base_names[] = {0};
static swig_lua_class _wrap_class_std_bdf_props = { "std_bdf_props", &SWIGTYPE_p_std_bdf_props,_wrap_new_std_bdf_props, swig_delete_std_bdf_props, swig_std_bdf_props_methods, swig_std_bdf_props_attributes, swig_std_bdf_props_bases, swig_std_bdf_props_base_names };

static int _wrap_XLFD_GetComponents(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  struct xlfd_components *arg2 = (struct xlfd_components *) 0 ;
  
  SWIG_check_num_args("XLFD_GetComponents",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("XLFD_GetComponents",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("XLFD_GetComponents",2,"struct xlfd_components *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("XLFD_GetComponents",2,SWIGTYPE_p_xlfd_components);
  }
  
  XLFD_GetComponents(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_XLFD_CreateComponents(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  struct xlfd_components *arg4 = (struct xlfd_components *) 0 ;
  
  SWIG_check_num_args("XLFD_CreateComponents",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("XLFD_CreateComponents",1,"BDFFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("XLFD_CreateComponents",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("XLFD_CreateComponents",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("XLFD_CreateComponents",4,"struct xlfd_components *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("XLFD_CreateComponents",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("XLFD_CreateComponents",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_xlfd_components,0))){
    SWIG_fail_ptr("XLFD_CreateComponents",4,SWIGTYPE_p_xlfd_components);
  }
  
  XLFD_CreateComponents(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinesIntersect(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  Spline *arg2 = (Spline *) 0 ;
  BasePoint *arg3 ;
  double *arg4 ;
  double *arg5 ;
  int result;
  
  SWIG_check_num_args("SplinesIntersect",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinesIntersect",1,"Spline const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinesIntersect",2,"Spline const *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplinesIntersect",3,"BasePoint [9]");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SplinesIntersect",4,"double [10]");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("SplinesIntersect",5,"double [10]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplinesIntersect",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplinesIntersect",2,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SplinesIntersect",3,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SplinesIntersect",4,SWIGTYPE_p_double);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SplinesIntersect",5,SWIGTYPE_p_double);
  }
  
  result = (int)SplinesIntersect((struct spline const *)arg1,(struct spline const *)arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerAllSplines(lua_State* L) {
  int SWIG_arg = 0;
  Layer *arg1 = (Layer *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("LayerAllSplines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerAllSplines",1,"Layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayerAllSplines",1,SWIGTYPE_p_layer);
  }
  
  result = (SplineSet *)LayerAllSplines(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerUnAllSplines(lua_State* L) {
  int SWIG_arg = 0;
  Layer *arg1 = (Layer *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("LayerUnAllSplines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerUnAllSplines",1,"Layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayerUnAllSplines",1,SWIGTYPE_p_layer);
  }
  
  result = (SplineSet *)LayerUnAllSplines(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetIntersect(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  Spline **arg2 = (Spline **) 0 ;
  Spline **arg3 = (Spline **) 0 ;
  int result;
  
  SWIG_check_num_args("SplineSetIntersect",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetIntersect",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetIntersect",2,"Spline **");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineSetIntersect",3,"Spline **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetIntersect",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_spline,0))){
    SWIG_fail_ptr("SplineSetIntersect",2,SWIGTYPE_p_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_spline,0))){
    SWIG_fail_ptr("SplineSetIntersect",3,SWIGTYPE_p_p_spline);
  }
  
  result = (int)SplineSetIntersect(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LineTangentToSplineThroughPt(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  double *arg3 ;
  double arg4 ;
  double arg5 ;
  int result;
  
  SWIG_check_num_args("LineTangentToSplineThroughPt",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LineTangentToSplineThroughPt",1,"Spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("LineTangentToSplineThroughPt",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("LineTangentToSplineThroughPt",3,"double [4]");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("LineTangentToSplineThroughPt",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("LineTangentToSplineThroughPt",5,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("LineTangentToSplineThroughPt",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("LineTangentToSplineThroughPt",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("LineTangentToSplineThroughPt",3,SWIGTYPE_p_double);
  }
  
  arg4 = (double)lua_tonumber(L, 4);
  arg5 = (double)lua_tonumber(L, 5);
  result = (int)LineTangentToSplineThroughPt(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__CubicSolve(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double arg2 ;
  double *arg3 ;
  int result;
  
  SWIG_check_num_args("_CubicSolve",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_CubicSolve",1,"Spline1D const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_CubicSolve",2,"double");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("_CubicSolve",3,"double [3]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("_CubicSolve",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("_CubicSolve",3,SWIGTYPE_p_double);
  }
  
  result = (int)_CubicSolve((struct spline1d const *)arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CubicSolve(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double arg2 ;
  double *arg3 ;
  int result;
  
  SWIG_check_num_args("CubicSolve",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CubicSolve",1,"Spline1D const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CubicSolve",2,"double");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("CubicSolve",3,"double [3]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("CubicSolve",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("CubicSolve",3,SWIGTYPE_p_double);
  }
  
  result = (int)CubicSolve((struct spline1d const *)arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSolve(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  float arg2 ;
  float arg3 ;
  double arg4 ;
  double result;
  
  SWIG_check_num_args("SplineSolve",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSolve",1,"Spline1D const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineSolve",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSolve",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineSolve",4,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("SplineSolve",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (double)lua_tonumber(L, 4);
  result = (double)SplineSolve((struct spline1d const *)arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSolveFixup(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  float arg2 ;
  float arg3 ;
  double arg4 ;
  double result;
  
  SWIG_check_num_args("SplineSolveFixup",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSolveFixup",1,"Spline1D const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineSolveFixup",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSolveFixup",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineSolveFixup",4,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("SplineSolveFixup",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (double)lua_tonumber(L, 4);
  result = (double)SplineSolveFixup((struct spline1d const *)arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IterateSplineSolve(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double result;
  
  SWIG_check_num_args("IterateSplineSolve",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IterateSplineSolve",1,"Spline1D const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IterateSplineSolve",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("IterateSplineSolve",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("IterateSplineSolve",4,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("IterateSplineSolve",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3);
  arg4 = (double)lua_tonumber(L, 4);
  result = (double)IterateSplineSolve((struct spline1d const *)arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IterateSplineSolveFixup(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double arg2 ;
  double arg3 ;
  double arg4 ;
  double result;
  
  SWIG_check_num_args("IterateSplineSolveFixup",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IterateSplineSolveFixup",1,"Spline1D const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("IterateSplineSolveFixup",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("IterateSplineSolveFixup",3,"double");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("IterateSplineSolveFixup",4,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("IterateSplineSolveFixup",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3);
  arg4 = (double)lua_tonumber(L, 4);
  result = (double)IterateSplineSolveFixup((struct spline1d const *)arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFindExtrema(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  
  SWIG_check_num_args("SplineFindExtrema",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFindExtrema",1,"Spline1D const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineFindExtrema",2,"double *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineFindExtrema",3,"double *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("SplineFindExtrema",1,SWIGTYPE_p_spline1d);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SplineFindExtrema",2,SWIGTYPE_p_double);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SplineFindExtrema",3,SWIGTYPE_p_double);
  }
  
  SplineFindExtrema((struct spline1d const *)arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSBoundsWithin(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  double arg2 ;
  double arg3 ;
  double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("SSBoundsWithin",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSBoundsWithin",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SSBoundsWithin",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SSBoundsWithin",3,"double");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SSBoundsWithin",4,"double *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("SSBoundsWithin",5,"double *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SSBoundsWithin",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSBoundsWithin",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SSBoundsWithin",4,SWIGTYPE_p_double);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SSBoundsWithin",5,SWIGTYPE_p_double);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)SSBoundsWithin(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineMinDistanceToPoint(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  double result;
  
  SWIG_check_num_args("SplineMinDistanceToPoint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineMinDistanceToPoint",1,"Spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineMinDistanceToPoint",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineMinDistanceToPoint",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SplineMinDistanceToPoint",2,SWIGTYPE_p_basepoint);
  }
  
  result = (double)SplineMinDistanceToPoint(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsInterpolate(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  float arg3 ;
  SplineChar *arg4 = (SplineChar *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsInterpolate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsInterpolate",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetsInterpolate",2,"SplineSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSetsInterpolate",3,"float");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SplineSetsInterpolate",4,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsInterpolate",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsInterpolate",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineSetsInterpolate",4,SWIGTYPE_p_splinechar);
  }
  
  result = (SplineSet *)SplineSetsInterpolate(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharInterpolate(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  float arg3 ;
  SplineFont *arg4 = (SplineFont *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharInterpolate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharInterpolate",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharInterpolate",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineCharInterpolate",3,"float");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SplineCharInterpolate",4,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharInterpolate",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharInterpolate",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineCharInterpolate",4,SWIGTYPE_p_splinefont);
  }
  
  result = (SplineChar *)SplineCharInterpolate(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_InterpolateFont(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  float arg3 ;
  Encoding *arg4 = (Encoding *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("InterpolateFont",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("InterpolateFont",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("InterpolateFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("InterpolateFont",3,"float");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("InterpolateFont",4,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("InterpolateFont",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("InterpolateFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("InterpolateFont",4,SWIGTYPE_p_enc);
  }
  
  result = (SplineFont *)InterpolateFont(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSerifHeight(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  double result;
  
  SWIG_check_num_args("SFSerifHeight",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSerifHeight",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSerifHeight",1,SWIGTYPE_p_splinefont);
  }
  
  result = (double)SFSerifHeight(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DumpPfaEditEncodings(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("DumpPfaEditEncodings",0,0)
  DumpPfaEditEncodings();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ParseEncodingFile(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("ParseEncodingFile",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ParseEncodingFile",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)ParseEncodingFile(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadPfaEditEncodings(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("LoadPfaEditEncodings",0,0)
  LoadPfaEditEncodings();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GenerateScript(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int arg5 ;
  char *arg6 = (char *) 0 ;
  struct sflist *arg7 = (struct sflist *) 0 ;
  EncMap *arg8 = (EncMap *) 0 ;
  NameList *arg9 = (NameList *) 0 ;
  int arg10 ;
  int result;
  
  SWIG_check_num_args("GenerateScript",10,10)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GenerateScript",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("GenerateScript",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("GenerateScript",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("GenerateScript",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("GenerateScript",5,"int");
  if(!SWIG_lua_isnilstring(L,6)) SWIG_fail_arg("GenerateScript",6,"char *");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("GenerateScript",7,"struct sflist *");
  if(!SWIG_isptrtype(L,8)) SWIG_fail_arg("GenerateScript",8,"EncMap *");
  if(!SWIG_isptrtype(L,9)) SWIG_fail_arg("GenerateScript",9,"NameList *");
  if(!lua_isnumber(L,10)) SWIG_fail_arg("GenerateScript",10,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("GenerateScript",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (char *)lua_tostring(L, 6);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_sflist,0))){
    SWIG_fail_ptr("GenerateScript",7,SWIGTYPE_p_sflist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,8,(void**)&arg8,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("GenerateScript",8,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,9,(void**)&arg9,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("GenerateScript",9,SWIGTYPE_p_namelist);
  }
  
  arg10 = (int)lua_tonumber(L, 10);
  result = (int)GenerateScript(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SCAutoTrace(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  
  SWIG_check_num_args("_SCAutoTrace",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_SCAutoTrace",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_SCAutoTrace",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("_SCAutoTrace",3,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_SCAutoTrace",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("_SCAutoTrace",3,SWIGTYPE_p_p_char);
  }
  
  _SCAutoTrace(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AutoTraceArgs(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char **result = 0 ;
  
  SWIG_check_num_args("AutoTraceArgs",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("AutoTraceArgs",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (char **)AutoTraceArgs(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCurvature(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  double arg2 ;
  double result;
  
  SWIG_check_num_args("SplineCurvature",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCurvature",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCurvature",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineCurvature",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  result = (double)SplineCurvature(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CheckExtremaForSingleBitErrors(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double arg2 ;
  double arg3 ;
  double result;
  
  SWIG_check_num_args("CheckExtremaForSingleBitErrors",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CheckExtremaForSingleBitErrors",1,"Spline1D const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CheckExtremaForSingleBitErrors",2,"double");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CheckExtremaForSingleBitErrors",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("CheckExtremaForSingleBitErrors",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  arg3 = (double)lua_tonumber(L, 3);
  result = (double)CheckExtremaForSingleBitErrors((struct spline1d const *)arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline2DFindExtrema(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  double *arg2 ;
  int result;
  
  SWIG_check_num_args("Spline2DFindExtrema",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Spline2DFindExtrema",1,"Spline const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Spline2DFindExtrema",2,"double [4]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline2DFindExtrema",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Spline2DFindExtrema",2,SWIGTYPE_p_double);
  }
  
  result = (int)Spline2DFindExtrema((struct spline const *)arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline2DFindPointsOfInflection(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  double *arg2 ;
  int result;
  
  SWIG_check_num_args("Spline2DFindPointsOfInflection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Spline2DFindPointsOfInflection",1,"Spline const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Spline2DFindPointsOfInflection",2,"double [2]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline2DFindPointsOfInflection",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("Spline2DFindPointsOfInflection",2,SWIGTYPE_p_double);
  }
  
  result = (int)Spline2DFindPointsOfInflection((struct spline const *)arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineAtInflection(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double arg2 ;
  int result;
  
  SWIG_check_num_args("SplineAtInflection",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineAtInflection",1,"Spline1D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineAtInflection",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("SplineAtInflection",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  result = (int)SplineAtInflection(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineAtMinMax(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double arg2 ;
  int result;
  
  SWIG_check_num_args("SplineAtMinMax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineAtMinMax",1,"Spline1D *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineAtMinMax",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("SplineAtMinMax",1,SWIGTYPE_p_spline1d);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  result = (int)SplineAtMinMax(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineRemoveExtremaTooClose(lua_State* L) {
  int SWIG_arg = 0;
  Spline1D *arg1 = (Spline1D *) 0 ;
  double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ;
  
  SWIG_check_num_args("SplineRemoveExtremaTooClose",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineRemoveExtremaTooClose",1,"Spline1D *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineRemoveExtremaTooClose",2,"double *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineRemoveExtremaTooClose",3,"double *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline1d,0))){
    SWIG_fail_ptr("SplineRemoveExtremaTooClose",1,SWIGTYPE_p_spline1d);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SplineRemoveExtremaTooClose",2,SWIGTYPE_p_double);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SplineRemoveExtremaTooClose",3,SWIGTYPE_p_double);
  }
  
  SplineRemoveExtremaTooClose(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NearSpline(lua_State* L) {
  int SWIG_arg = 0;
  struct findsel *arg1 = (struct findsel *) 0 ;
  Spline *arg2 = (Spline *) 0 ;
  int result;
  
  SWIG_check_num_args("NearSpline",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NearSpline",1,"struct findsel *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("NearSpline",2,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_findsel,0))){
    SWIG_fail_ptr("NearSpline",1,SWIGTYPE_p_findsel);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("NearSpline",2,SWIGTYPE_p_spline);
  }
  
  result = (int)NearSpline(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineNearPoint(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  float arg3 ;
  float result;
  
  SWIG_check_num_args("SplineNearPoint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineNearPoint",1,"Spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineNearPoint",2,"BasePoint *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineNearPoint",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineNearPoint",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SplineNearPoint",2,SWIGTYPE_p_basepoint);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  result = (float)SplineNearPoint(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineT2SpiroIndex(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  double arg2 ;
  SplineSet *arg3 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineT2SpiroIndex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineT2SpiroIndex",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineT2SpiroIndex",2,"double");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineT2SpiroIndex",3,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineT2SpiroIndex",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineT2SpiroIndex",3,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SplineT2SpiroIndex(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCMakeDependent(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCMakeDependent",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCMakeDependent",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCMakeDependent",2,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCMakeDependent",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCMakeDependent",2,SWIGTYPE_p_splinechar);
  }
  
  SCMakeDependent(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineBisect(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  double arg2 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("SplineBisect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineBisect",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineBisect",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineBisect",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  result = (SplinePoint *)SplineBisect(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSplit(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  double *arg2 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("SplineSplit",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSplit",1,"Spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSplit",2,"double [3]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineSplit",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("SplineSplit",2,SWIGTYPE_p_double);
  }
  
  result = (Spline *)SplineSplit(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ApproximateSplineFromPoints(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  TPoint *arg3 = (TPoint *) 0 ;
  int arg4 ;
  int arg5 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("ApproximateSplineFromPoints",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ApproximateSplineFromPoints",1,"SplinePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ApproximateSplineFromPoints",2,"SplinePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ApproximateSplineFromPoints",3,"TPoint *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ApproximateSplineFromPoints",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ApproximateSplineFromPoints",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("ApproximateSplineFromPoints",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("ApproximateSplineFromPoints",2,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("ApproximateSplineFromPoints",3,SWIGTYPE_p_tpoint);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (Spline *)ApproximateSplineFromPoints(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ApproximateSplineFromPointsSlopes(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  TPoint *arg3 = (TPoint *) 0 ;
  int arg4 ;
  int arg5 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("ApproximateSplineFromPointsSlopes",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ApproximateSplineFromPointsSlopes",1,"SplinePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ApproximateSplineFromPointsSlopes",2,"SplinePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ApproximateSplineFromPointsSlopes",3,"TPoint *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ApproximateSplineFromPointsSlopes",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ApproximateSplineFromPointsSlopes",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("ApproximateSplineFromPointsSlopes",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("ApproximateSplineFromPointsSlopes",2,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_tpoint,0))){
    SWIG_fail_ptr("ApproximateSplineFromPointsSlopes",3,SWIGTYPE_p_tpoint);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (Spline *)ApproximateSplineFromPointsSlopes(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineLength(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  double result;
  
  SWIG_check_num_args("SplineLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineLength",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineLength",1,SWIGTYPE_p_spline);
  }
  
  result = (double)SplineLength(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineLengthRange(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  float arg2 ;
  float arg3 ;
  double result;
  
  SWIG_check_num_args("SplineLengthRange",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineLengthRange",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineLengthRange",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineLengthRange",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineLengthRange",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (double)SplineLengthRange(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathLength(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  double result;
  
  SWIG_check_num_args("PathLength",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PathLength",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("PathLength",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (double)PathLength(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PathFindDistance(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  double arg2 ;
  double *arg3 = (double *) 0 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("PathFindDistance",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PathFindDistance",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PathFindDistance",2,"double");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PathFindDistance",3,"double *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("PathFindDistance",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_double,0))){
    SWIG_fail_ptr("PathFindDistance",3,SWIGTYPE_p_double);
  }
  
  result = (Spline *)PathFindDistance(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetBindToPath(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  float arg5 ;
  SplineSet *arg6 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetBindToPath",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetBindToPath",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineSetBindToPath",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSetBindToPath",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineSetBindToPath",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplineSetBindToPath",5,"float");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("SplineSetBindToPath",6,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetBindToPath",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetBindToPath",6,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SplineSetBindToPath(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineIsLinear(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineIsLinear",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineIsLinear",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineIsLinear",1,SWIGTYPE_p_spline);
  }
  
  result = (int)SplineIsLinear(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineIsLinearMake(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineIsLinearMake",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineIsLinearMake",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineIsLinearMake",1,SWIGTYPE_p_spline);
  }
  
  result = (int)SplineIsLinearMake(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineInSplineSet(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineInSplineSet",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineInSplineSet",1,"Spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineInSplineSet",2,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineInSplineSet",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineInSplineSet",2,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SplineInSplineSet(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSPointWithin(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("SSPointWithin",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSPointWithin",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SSPointWithin",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSPointWithin",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SSPointWithin",2,SWIGTYPE_p_basepoint);
  }
  
  result = (int)SSPointWithin(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSRemoveZeroLengthSplines(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SSRemoveZeroLengthSplines",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSRemoveZeroLengthSplines",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSRemoveZeroLengthSplines",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SSRemoveZeroLengthSplines(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSRemoveStupidControlPoints(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("SSRemoveStupidControlPoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSRemoveStupidControlPoints",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSRemoveStupidControlPoints",1,SWIGTYPE_p_splinepointlist);
  }
  
  SSRemoveStupidControlPoints(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSOverlapClusterCpAngles(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("SSOverlapClusterCpAngles",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSOverlapClusterCpAngles",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SSOverlapClusterCpAngles",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSOverlapClusterCpAngles",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  SSOverlapClusterCpAngles(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinesRemoveBetween(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  SplinePoint *arg3 = (SplinePoint *) 0 ;
  int arg4 ;
  
  SWIG_check_num_args("SplinesRemoveBetween",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinesRemoveBetween",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinesRemoveBetween",2,"SplinePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplinesRemoveBetween",3,"SplinePoint *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplinesRemoveBetween",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplinesRemoveBetween",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinesRemoveBetween",2,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinesRemoveBetween",3,SWIGTYPE_p_splinepoint);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  SplinesRemoveBetween(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharMerge(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet **arg2 = (SplineSet **) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("SplineCharMerge",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharMerge",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharMerge",2,"SplineSet **");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineCharMerge",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharMerge",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineCharMerge",2,SWIGTYPE_p_p_splinepointlist);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  SplineCharMerge(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLNearlyHvCps(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  double arg3 ;
  
  SWIG_check_num_args("SPLNearlyHvCps",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLNearlyHvCps",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SPLNearlyHvCps",2,"SplineSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SPLNearlyHvCps",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLNearlyHvCps",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SPLNearlyHvCps",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (double)lua_tonumber(L, 3);
  SPLNearlyHvCps(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLNearlyHvLines(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  double arg3 ;
  
  SWIG_check_num_args("SPLNearlyHvLines",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLNearlyHvLines",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SPLNearlyHvLines",2,"SplineSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SPLNearlyHvLines",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLNearlyHvLines",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SPLNearlyHvLines",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (double)lua_tonumber(L, 3);
  SPLNearlyHvLines(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLNearlyLines(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  double arg3 ;
  int result;
  
  SWIG_check_num_args("SPLNearlyLines",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLNearlyLines",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SPLNearlyLines",2,"SplineSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SPLNearlyLines",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLNearlyLines",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SPLNearlyLines",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (double)lua_tonumber(L, 3);
  result = (int)SPLNearlyLines(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPInterpolate(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("SPInterpolate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPInterpolate",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SPInterpolate",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (int)SPInterpolate(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListSimplify(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  struct simplifyinfo *arg3 = (struct simplifyinfo *) 0 ;
  
  SWIG_check_num_args("SplinePointListSimplify",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListSimplify",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplinePointListSimplify",2,"SplinePointList *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplinePointListSimplify",3,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplinePointListSimplify",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListSimplify",2,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("SplinePointListSimplify",3,SWIGTYPE_p_simplifyinfo);
  }
  
  SplinePointListSimplify(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharSimplify(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  struct simplifyinfo *arg3 = (struct simplifyinfo *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineCharSimplify",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharSimplify",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharSimplify",2,"SplineSet *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineCharSimplify",3,"struct simplifyinfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharSimplify",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineCharSimplify",2,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_simplifyinfo,0))){
    SWIG_fail_ptr("SplineCharSimplify",3,SWIGTYPE_p_simplifyinfo);
  }
  
  result = (SplineSet *)SplineCharSimplify(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLStartToLeftmost(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplinePointList *arg2 = (SplinePointList *) 0 ;
  int *arg3 = (int *) 0 ;
  
  SWIG_check_num_args("SPLStartToLeftmost",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLStartToLeftmost",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SPLStartToLeftmost",2,"SplinePointList *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SPLStartToLeftmost",3,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLStartToLeftmost",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SPLStartToLeftmost",2,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SPLStartToLeftmost",3,SWIGTYPE_p_int);
  }
  
  SPLStartToLeftmost(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLsStartToLeftmost(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SPLsStartToLeftmost",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLsStartToLeftmost",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SPLsStartToLeftmost",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SPLsStartToLeftmost",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SPLsStartToLeftmost(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CanonicalContours(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("CanonicalContours",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CanonicalContours",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CanonicalContours",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("CanonicalContours",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  CanonicalContours(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetJoinCpFixup(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplineSetJoinCpFixup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetJoinCpFixup",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineSetJoinCpFixup",1,SWIGTYPE_p_splinepoint);
  }
  
  SplineSetJoinCpFixup(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetJoin(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int arg2 ;
  float arg3 ;
  int *arg4 = (int *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetJoin",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetJoin",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineSetJoin",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSetJoin",3,"float");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SplineSetJoin",4,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetJoin",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SplineSetJoin",4,SWIGTYPE_p_int);
  }
  
  result = (SplineSet *)SplineSetJoin(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpIsExtremum(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("SpIsExtremum",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SpIsExtremum",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SpIsExtremum",1,SWIGTYPE_p_splinepoint);
  }
  
  result = (int)SpIsExtremum(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1DCantExtremeX(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  int result;
  
  SWIG_check_num_args("Spline1DCantExtremeX",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Spline1DCantExtremeX",1,"Spline const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline1DCantExtremeX",1,SWIGTYPE_p_spline);
  }
  
  result = (int)Spline1DCantExtremeX((struct spline const *)arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Spline1DCantExtremeY(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  int result;
  
  SWIG_check_num_args("Spline1DCantExtremeY",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("Spline1DCantExtremeY",1,"Spline const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("Spline1DCantExtremeY",1,SWIGTYPE_p_spline);
  }
  
  result = (int)Spline1DCantExtremeY((struct spline const *)arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineAddExtrema(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  int arg2 ;
  float arg3 ;
  float arg4 ;
  DBounds *arg5 = (DBounds *) 0 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("SplineAddExtrema",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineAddExtrema",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineAddExtrema",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineAddExtrema",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineAddExtrema",4,"float");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("SplineAddExtrema",5,"DBounds *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineAddExtrema",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_dbounds,0))){
    SWIG_fail_ptr("SplineAddExtrema",5,SWIGTYPE_p_dbounds);
  }
  
  result = (Spline *)SplineAddExtrema(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetAddExtrema(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  enum ae_type arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("SplineSetAddExtrema",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetAddExtrema",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetAddExtrema",2,"SplineSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSetAddExtrema",3,"enum ae_type");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineSetAddExtrema",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineSetAddExtrema",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetAddExtrema",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (enum ae_type)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SplineSetAddExtrema(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharAddExtrema(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  enum ae_type arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("SplineCharAddExtrema",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharAddExtrema",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharAddExtrema",2,"SplineSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineCharAddExtrema",3,"enum ae_type");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineCharAddExtrema",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharAddExtrema",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineCharAddExtrema",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (enum ae_type)(int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SplineCharAddExtrema(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharRemoveTiny(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineCharRemoveTiny",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharRemoveTiny",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineCharRemoveTiny",2,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharRemoveTiny",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineCharRemoveTiny",2,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SplineCharRemoveTiny(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontNew(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontNew",0,0)
  result = (SplineFont *)SplineFontNew();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GetNextUntitledName(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("GetNextUntitledName",0,0)
  result = (char *)GetNextUntitledName();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontEmpty(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontEmpty",0,0)
  result = (SplineFont *)SplineFontEmpty();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontBlank(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontBlank",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("SplineFontBlank",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (SplineFont *)SplineFontBlank(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFIncrementXUID(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFIncrementXUID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFIncrementXUID",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFIncrementXUID",1,SWIGTYPE_p_splinefont);
  }
  
  SFIncrementXUID(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRandomChangeXUID(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFRandomChangeXUID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRandomChangeXUID",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRandomChangeXUID",1,SWIGTYPE_p_splinefont);
  }
  
  SFRandomChangeXUID(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetReverse(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetReverse",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetReverse",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetReverse",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SplineSetReverse(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsExtractOpen(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet **arg1 = (SplineSet **) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsExtractOpen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsExtractOpen",1,"SplineSet **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsExtractOpen",1,SWIGTYPE_p_p_splinepointlist);
  }
  
  result = (SplineSet *)SplineSetsExtractOpen(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsInsertOpen(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet **arg1 = (SplineSet **) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("SplineSetsInsertOpen",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsInsertOpen",1,"SplineSet **");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetsInsertOpen",2,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsInsertOpen",1,SWIGTYPE_p_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsInsertOpen",2,SWIGTYPE_p_splinepointlist);
  }
  
  SplineSetsInsertOpen(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsCorrect(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int *arg2 = (int *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsCorrect",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsCorrect",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetsCorrect",2,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsCorrect",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SplineSetsCorrect",2,SWIGTYPE_p_int);
  }
  
  result = (SplineSet *)SplineSetsCorrect(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsAntiCorrect(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsAntiCorrect",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsAntiCorrect",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsAntiCorrect",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SplineSetsAntiCorrect(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsDetectDir(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet **arg1 = (SplineSet **) 0 ;
  int *arg2 = (int *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsDetectDir",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsDetectDir",1,"SplineSet **");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetsDetectDir",2,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsDetectDir",1,SWIGTYPE_p_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SplineSetsDetectDir",2,SWIGTYPE_p_int);
  }
  
  result = (SplineSet *)SplineSetsDetectDir(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPAverageCps(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SPAverageCps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPAverageCps",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SPAverageCps",1,SWIGTYPE_p_splinepoint);
  }
  
  SPAverageCps(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPLAverageCps(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("SPLAverageCps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPLAverageCps",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SPLAverageCps",1,SWIGTYPE_p_splinepointlist);
  }
  
  SPLAverageCps(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPWeightedAverageCps(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SPWeightedAverageCps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPWeightedAverageCps",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SPWeightedAverageCps",1,SWIGTYPE_p_splinepoint);
  }
  
  SPWeightedAverageCps(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BP_HVForce(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  
  SWIG_check_num_args("BP_HVForce",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BP_HVForce",1,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BP_HVForce",1,SWIGTYPE_p_basepoint);
  }
  
  BP_HVForce(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharDefaultPrevCP(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplineCharDefaultPrevCP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharDefaultPrevCP",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineCharDefaultPrevCP",1,SWIGTYPE_p_splinepoint);
  }
  
  SplineCharDefaultPrevCP(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharDefaultNextCP(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplineCharDefaultNextCP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharDefaultNextCP",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineCharDefaultNextCP",1,SWIGTYPE_p_splinepoint);
  }
  
  SplineCharDefaultNextCP(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharTangentNextCP(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplineCharTangentNextCP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharTangentNextCP",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineCharTangentNextCP",1,SWIGTYPE_p_splinepoint);
  }
  
  SplineCharTangentNextCP(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharTangentPrevCP(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplineCharTangentPrevCP",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharTangentPrevCP",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineCharTangentPrevCP",1,SWIGTYPE_p_splinepoint);
  }
  
  SplineCharTangentPrevCP(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPAdjustControl(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  int arg4 ;
  
  SWIG_check_num_args("SPAdjustControl",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPAdjustControl",1,"SplinePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SPAdjustControl",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SPAdjustControl",3,"BasePoint *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SPAdjustControl",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SPAdjustControl",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SPAdjustControl",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("SPAdjustControl",3,SWIGTYPE_p_basepoint);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  SPAdjustControl(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPHVCurveForce(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SPHVCurveForce",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPHVCurveForce",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SPHVCurveForce",1,SWIGTYPE_p_splinepoint);
  }
  
  SPHVCurveForce(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SPSmoothJoint(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SPSmoothJoint",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SPSmoothJoint",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SPSmoothJoint",1,SWIGTYPE_p_splinepoint);
  }
  
  SPSmoothJoint(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PointListIsSelected(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  int result;
  
  SWIG_check_num_args("PointListIsSelected",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PointListIsSelected",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("PointListIsSelected",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)PointListIsSelected(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCSplinePointsUntick(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCSplinePointsUntick",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCSplinePointsUntick",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCSplinePointsUntick",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCSplinePointsUntick",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCSplinePointsUntick(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsUntick(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("SplineSetsUntick",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsUntick",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsUntick",1,SWIGTYPE_p_splinepointlist);
  }
  
  SplineSetsUntick(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFOrderBitmapList(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFOrderBitmapList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFOrderBitmapList",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFOrderBitmapList",1,SWIGTYPE_p_splinefont);
  }
  
  SFOrderBitmapList(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KernThreshold(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("KernThreshold",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("KernThreshold",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("KernThreshold",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("KernThreshold",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)KernThreshold(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGuessItalicAngle(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  float result;
  
  SWIG_check_num_args("SFGuessItalicAngle",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGuessItalicAngle",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGuessItalicAngle",1,SWIGTYPE_p_splinefont);
  }
  
  result = (float)SFGuessItalicAngle(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineTtfApprox(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  SplinePoint *result = 0 ;
  
  SWIG_check_num_args("SplineTtfApprox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineTtfApprox",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineTtfApprox",1,SWIGTYPE_p_spline);
  }
  
  result = (SplinePoint *)SplineTtfApprox(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepoint,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSttfApprox(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SSttfApprox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSttfApprox",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSttfApprox",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SSttfApprox(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsTTFApprox(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsTTFApprox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsTTFApprox",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsTTFApprox",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SplineSetsTTFApprox(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSPSApprox(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SSPSApprox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSPSApprox",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSPSApprox",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SSPSApprox(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsPSApprox(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsPSApprox",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsPSApprox",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsPSApprox",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (SplineSet *)SplineSetsPSApprox(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsConvertOrder(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int arg2 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetsConvertOrder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsConvertOrder",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineSetsConvertOrder",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsConvertOrder",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (SplineSet *)SplineSetsConvertOrder(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineRefigure2(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  
  SWIG_check_num_args("SplineRefigure2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineRefigure2",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineRefigure2",1,SWIGTYPE_p_spline);
  }
  
  SplineRefigure2(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineRefigureFixup(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  
  SWIG_check_num_args("SplineRefigureFixup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineRefigureFixup",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineRefigureFixup",1,SWIGTYPE_p_spline);
  }
  
  SplineRefigureFixup(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineMake2(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("SplineMake2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineMake2",1,"SplinePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineMake2",2,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineMake2",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineMake2",2,SWIGTYPE_p_splinepoint);
  }
  
  result = (Spline *)SplineMake2(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineMake(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  SplinePoint *arg2 = (SplinePoint *) 0 ;
  int arg3 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("SplineMake",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineMake",1,"SplinePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineMake",2,"SplinePoint *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineMake",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineMake",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplineMake",2,SWIGTYPE_p_splinepoint);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (Spline *)SplineMake(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCConvertToOrder2(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCConvertToOrder2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCConvertToOrder2",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCConvertToOrder2",1,SWIGTYPE_p_splinechar);
  }
  
  SCConvertToOrder2(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFConvertToOrder2(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFConvertToOrder2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFConvertToOrder2",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFConvertToOrder2",1,SWIGTYPE_p_splinefont);
  }
  
  SFConvertToOrder2(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCConvertToOrder3(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCConvertToOrder3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCConvertToOrder3",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCConvertToOrder3",1,SWIGTYPE_p_splinechar);
  }
  
  SCConvertToOrder3(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFConvertToOrder3(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFConvertToOrder3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFConvertToOrder3",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFConvertToOrder3",1,SWIGTYPE_p_splinefont);
  }
  
  SFConvertToOrder3(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFConvertGridToOrder2(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFConvertGridToOrder2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFConvertGridToOrder2",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFConvertGridToOrder2",1,SWIGTYPE_p_splinefont);
  }
  
  SFConvertGridToOrder2(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCConvertLayerToOrder2(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCConvertLayerToOrder2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCConvertLayerToOrder2",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCConvertLayerToOrder2",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCConvertLayerToOrder2",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCConvertLayerToOrder2(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFConvertLayerToOrder2(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFConvertLayerToOrder2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFConvertLayerToOrder2",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFConvertLayerToOrder2",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFConvertLayerToOrder2",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFConvertLayerToOrder2(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFConvertGridToOrder3(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFConvertGridToOrder3",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFConvertGridToOrder3",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFConvertGridToOrder3",1,SWIGTYPE_p_splinefont);
  }
  
  SFConvertGridToOrder3(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCConvertLayerToOrder3(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCConvertLayerToOrder3",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCConvertLayerToOrder3",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCConvertLayerToOrder3",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCConvertLayerToOrder3",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCConvertLayerToOrder3(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFConvertLayerToOrder3(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFConvertLayerToOrder3",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFConvertLayerToOrder3",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFConvertLayerToOrder3",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFConvertLayerToOrder3",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFConvertLayerToOrder3(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCConvertOrder(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCConvertOrder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCConvertOrder",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCConvertOrder",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCConvertOrder",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCConvertOrder(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointPrevCPChanged2(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplinePointPrevCPChanged2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointPrevCPChanged2",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePointPrevCPChanged2",1,SWIGTYPE_p_splinepoint);
  }
  
  SplinePointPrevCPChanged2(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointNextCPChanged2(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  
  SWIG_check_num_args("SplinePointNextCPChanged2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointNextCPChanged2",1,"SplinePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePointNextCPChanged2",1,SWIGTYPE_p_splinepoint);
  }
  
  SplinePointNextCPChanged2(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntersectLinesSlopes(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  BasePoint *arg4 = (BasePoint *) 0 ;
  BasePoint *arg5 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("IntersectLinesSlopes",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IntersectLinesSlopes",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("IntersectLinesSlopes",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("IntersectLinesSlopes",3,"BasePoint *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("IntersectLinesSlopes",4,"BasePoint *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("IntersectLinesSlopes",5,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesSlopes",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesSlopes",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesSlopes",3,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesSlopes",4,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesSlopes",5,SWIGTYPE_p_basepoint);
  }
  
  result = (int)IntersectLinesSlopes(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntersectLines(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  BasePoint *arg4 = (BasePoint *) 0 ;
  BasePoint *arg5 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("IntersectLines",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IntersectLines",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("IntersectLines",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("IntersectLines",3,"BasePoint *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("IntersectLines",4,"BasePoint *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("IntersectLines",5,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLines",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLines",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLines",3,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLines",4,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLines",5,SWIGTYPE_p_basepoint);
  }
  
  result = (int)IntersectLines(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IntersectLinesClip(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  BasePoint *arg4 = (BasePoint *) 0 ;
  BasePoint *arg5 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("IntersectLinesClip",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IntersectLinesClip",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("IntersectLinesClip",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("IntersectLinesClip",3,"BasePoint *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("IntersectLinesClip",4,"BasePoint *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("IntersectLinesClip",5,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesClip",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesClip",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesClip",3,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesClip",4,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("IntersectLinesClip",5,SWIGTYPE_p_basepoint);
  }
  
  result = (int)IntersectLinesClip(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSRemoveBacktracks(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("SSRemoveBacktracks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSRemoveBacktracks",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSRemoveBacktracks",1,SWIGTYPE_p_splinepointlist);
  }
  
  SSRemoveBacktracks(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PolygonIsConvex(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  enum PolyType result;
  
  SWIG_check_num_args("PolygonIsConvex",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PolygonIsConvex",1,"BasePoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PolygonIsConvex",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PolygonIsConvex",3,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("PolygonIsConvex",1,SWIGTYPE_p_basepoint);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("PolygonIsConvex",3,SWIGTYPE_p_int);
  }
  
  result = (enum PolyType)PolygonIsConvex(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UnitShape(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("UnitShape",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("UnitShape",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (SplineSet *)UnitShape(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetStroke(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  StrokeInfo *arg2 = (StrokeInfo *) 0 ;
  int arg3 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetStroke",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetStroke",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetStroke",2,"StrokeInfo *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSetStroke",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetStroke",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_strokeinfo,0))){
    SWIG_fail_ptr("SplineSetStroke",2,SWIGTYPE_p_strokeinfo);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (SplineSet *)SplineSetStroke(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetRemoveOverlap(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  enum overlap_type arg3 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplineSetRemoveOverlap",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetRemoveOverlap",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSetRemoveOverlap",2,"SplineSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSetRemoveOverlap",3,"enum overlap_type");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineSetRemoveOverlap",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetRemoveOverlap",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (enum overlap_type)(int)lua_tonumber(L, 3);
  result = (SplineSet *)SplineSetRemoveOverlap(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSShadow(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  float arg2 ;
  float arg3 ;
  float arg4 ;
  SplineChar *arg5 = (SplineChar *) 0 ;
  int arg6 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SSShadow",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSShadow",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SSShadow",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SSShadow",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SSShadow",4,"float");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("SSShadow",5,"SplineChar *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SSShadow",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSShadow",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SSShadow",5,SWIGTYPE_p_splinechar);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  result = (SplineSet *)SSShadow(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueScaleFigureForced(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  float *arg2 ;
  float *arg3 ;
  double result;
  
  SWIG_check_num_args("BlueScaleFigureForced",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BlueScaleFigureForced",1,"struct psdict *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BlueScaleFigureForced",2,"float []");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BlueScaleFigureForced",3,"float []");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("BlueScaleFigureForced",1,SWIGTYPE_p_psdict);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("BlueScaleFigureForced",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("BlueScaleFigureForced",3,SWIGTYPE_p_float);
  }
  
  result = (double)BlueScaleFigureForced(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueScaleFigure(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  float *arg2 ;
  float *arg3 ;
  double result;
  
  SWIG_check_num_args("BlueScaleFigure",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BlueScaleFigure",1,"struct psdict *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BlueScaleFigure",2,"float []");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BlueScaleFigure",3,"float []");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("BlueScaleFigure",1,SWIGTYPE_p_psdict);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("BlueScaleFigure",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("BlueScaleFigure",3,SWIGTYPE_p_float);
  }
  
  result = (double)BlueScaleFigure(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindBlues(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  float *arg3 ;
  float *arg4 ;
  
  SWIG_check_num_args("FindBlues",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FindBlues",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FindBlues",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FindBlues",3,"float [14]");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("FindBlues",4,"float [10]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FindBlues",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FindBlues",3,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FindBlues",4,SWIGTYPE_p_float);
  }
  
  FindBlues(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_QuickBlues(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  BlueData *arg3 = (BlueData *) 0 ;
  
  SWIG_check_num_args("QuickBlues",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("QuickBlues",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("QuickBlues",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("QuickBlues",3,"BlueData *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("QuickBlues",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("QuickBlues",3,SWIGTYPE_p_bluedata);
  }
  
  QuickBlues(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindHStems(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  float *arg2 ;
  float *arg3 ;
  
  SWIG_check_num_args("FindHStems",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FindHStems",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FindHStems",2,"float [12]");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FindHStems",3,"float [12]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FindHStems",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FindHStems",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FindHStems",3,SWIGTYPE_p_float);
  }
  
  FindHStems(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindVStems(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  float *arg2 ;
  float *arg3 ;
  
  SWIG_check_num_args("FindVStems",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FindVStems",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FindVStems",2,"float [12]");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FindVStems",3,"float [12]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FindVStems",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FindVStems",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("FindVStems",3,SWIGTYPE_p_float);
  }
  
  FindVStems(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFStdVW(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  double result;
  
  SWIG_check_num_args("SFStdVW",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFStdVW",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFStdVW",1,SWIGTYPE_p_splinefont);
  }
  
  result = (double)SFStdVW(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharIsFlexible(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("SplineCharIsFlexible",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharIsFlexible",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharIsFlexible",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharIsFlexible",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)SplineCharIsFlexible(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCGuessHintInstancesList(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  StemInfo *arg3 = (StemInfo *) 0 ;
  StemInfo *arg4 = (StemInfo *) 0 ;
  DStemInfo *arg5 = (DStemInfo *) 0 ;
  int arg6 ;
  int arg7 ;
  
  SWIG_check_num_args("SCGuessHintInstancesList",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCGuessHintInstancesList",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCGuessHintInstancesList",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCGuessHintInstancesList",3,"StemInfo *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SCGuessHintInstancesList",4,"StemInfo *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("SCGuessHintInstancesList",5,"DStemInfo *");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SCGuessHintInstancesList",6,"int");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("SCGuessHintInstancesList",7,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCGuessHintInstancesList",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("SCGuessHintInstancesList",3,SWIGTYPE_p_steminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("SCGuessHintInstancesList",4,SWIGTYPE_p_steminfo);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("SCGuessHintInstancesList",5,SWIGTYPE_p_dsteminfo);
  }
  
  arg6 = (int)lua_tonumber(L, 6);
  arg7 = (int)lua_tonumber(L, 7);
  SCGuessHintInstancesList(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCGuessDHintInstances(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  DStemInfo *arg3 = (DStemInfo *) 0 ;
  
  SWIG_check_num_args("SCGuessDHintInstances",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCGuessDHintInstances",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCGuessDHintInstances",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCGuessDHintInstances",3,"DStemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCGuessDHintInstances",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_dsteminfo,0))){
    SWIG_fail_ptr("SCGuessDHintInstances",3,SWIGTYPE_p_dsteminfo);
  }
  
  SCGuessDHintInstances(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCGuessHHintInstancesAndAdd(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  StemInfo *arg3 = (StemInfo *) 0 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("SCGuessHHintInstancesAndAdd",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCGuessHHintInstancesAndAdd",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCGuessHHintInstancesAndAdd",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCGuessHHintInstancesAndAdd",3,"StemInfo *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCGuessHHintInstancesAndAdd",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCGuessHHintInstancesAndAdd",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCGuessHHintInstancesAndAdd",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("SCGuessHHintInstancesAndAdd",3,SWIGTYPE_p_steminfo);
  }
  
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  SCGuessHHintInstancesAndAdd(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCGuessVHintInstancesAndAdd(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  StemInfo *arg3 = (StemInfo *) 0 ;
  float arg4 ;
  float arg5 ;
  
  SWIG_check_num_args("SCGuessVHintInstancesAndAdd",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCGuessVHintInstancesAndAdd",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCGuessVHintInstancesAndAdd",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCGuessVHintInstancesAndAdd",3,"StemInfo *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCGuessVHintInstancesAndAdd",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCGuessVHintInstancesAndAdd",5,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCGuessVHintInstancesAndAdd",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("SCGuessVHintInstancesAndAdd",3,SWIGTYPE_p_steminfo);
  }
  
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  SCGuessVHintInstancesAndAdd(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCGuessHHintInstancesList(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCGuessHHintInstancesList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCGuessHHintInstancesList",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCGuessHHintInstancesList",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCGuessHHintInstancesList",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCGuessHHintInstancesList(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCGuessVHintInstancesList(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCGuessVHintInstancesList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCGuessVHintInstancesList",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCGuessVHintInstancesList",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCGuessVHintInstancesList",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCGuessVHintInstancesList(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HIlen(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo *arg1 = (StemInfo *) 0 ;
  float result;
  
  SWIG_check_num_args("HIlen",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HIlen",1,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("HIlen",1,SWIGTYPE_p_steminfo);
  }
  
  result = (float)HIlen(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HIoverlap(lua_State* L) {
  int SWIG_arg = 0;
  HintInstance *arg1 = (HintInstance *) 0 ;
  HintInstance *arg2 = (HintInstance *) 0 ;
  float result;
  
  SWIG_check_num_args("HIoverlap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HIoverlap",1,"HintInstance *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("HIoverlap",2,"HintInstance *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HIoverlap",1,SWIGTYPE_p_hintinstance);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HIoverlap",2,SWIGTYPE_p_hintinstance);
  }
  
  result = (float)HIoverlap(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemInfoAnyOverlaps(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo *arg1 = (StemInfo *) 0 ;
  int result;
  
  SWIG_check_num_args("StemInfoAnyOverlaps",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemInfoAnyOverlaps",1,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemInfoAnyOverlaps",1,SWIGTYPE_p_steminfo);
  }
  
  result = (int)StemInfoAnyOverlaps(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StemListAnyConflicts(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo *arg1 = (StemInfo *) 0 ;
  int result;
  
  SWIG_check_num_args("StemListAnyConflicts",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("StemListAnyConflicts",1,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("StemListAnyConflicts",1,SWIGTYPE_p_steminfo);
  }
  
  result = (int)StemListAnyConflicts(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HICopyTrans(lua_State* L) {
  int SWIG_arg = 0;
  HintInstance *arg1 = (HintInstance *) 0 ;
  float arg2 ;
  float arg3 ;
  HintInstance *result = 0 ;
  
  SWIG_check_num_args("HICopyTrans",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HICopyTrans",1,"HintInstance *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("HICopyTrans",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("HICopyTrans",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_hintinstance,0))){
    SWIG_fail_ptr("HICopyTrans",1,SWIGTYPE_p_hintinstance);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  result = (HintInstance *)HICopyTrans(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_hintinstance,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFNeedsAutoHint(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("SFNeedsAutoHint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFNeedsAutoHint",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFNeedsAutoHint",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFNeedsAutoHint",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)SFNeedsAutoHint(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluezone::base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::base",1,"struct bluezone *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluezone::base",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_base_set",1,SWIGTYPE_p_bluezone);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  float result;
  
  SWIG_check_num_args("bluezone::base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::base",1,"struct bluezone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_base_get",1,SWIGTYPE_p_bluezone);
  }
  
  result = (float) ((arg1)->base);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_cvtindex_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bluezone::cvtindex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::cvtindex",1,"struct bluezone *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluezone::cvtindex",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_cvtindex_set",1,SWIGTYPE_p_bluezone);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cvtindex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_cvtindex_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int result;
  
  SWIG_check_num_args("bluezone::cvtindex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::cvtindex",1,"struct bluezone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_cvtindex_get",1,SWIGTYPE_p_bluezone);
  }
  
  result = (int) ((arg1)->cvtindex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_family_base_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluezone::family_base",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::family_base",1,"struct bluezone *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluezone::family_base",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_family_base_set",1,SWIGTYPE_p_bluezone);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->family_base = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_family_base_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  float result;
  
  SWIG_check_num_args("bluezone::family_base",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::family_base",1,"struct bluezone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_family_base_get",1,SWIGTYPE_p_bluezone);
  }
  
  result = (float) ((arg1)->family_base);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_family_cvtindex_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bluezone::family_cvtindex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::family_cvtindex",1,"struct bluezone *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluezone::family_cvtindex",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_family_cvtindex_set",1,SWIGTYPE_p_bluezone);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->family_cvtindex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_family_cvtindex_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int result;
  
  SWIG_check_num_args("bluezone::family_cvtindex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::family_cvtindex",1,"struct bluezone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_family_cvtindex_get",1,SWIGTYPE_p_bluezone);
  }
  
  result = (int) ((arg1)->family_cvtindex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_overshoot_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("bluezone::overshoot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::overshoot",1,"struct bluezone *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluezone::overshoot",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_overshoot_set",1,SWIGTYPE_p_bluezone);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->overshoot = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_overshoot_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  float result;
  
  SWIG_check_num_args("bluezone::overshoot",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::overshoot",1,"struct bluezone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_overshoot_get",1,SWIGTYPE_p_bluezone);
  }
  
  result = (float) ((arg1)->overshoot);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_highest_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bluezone::highest",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::highest",1,"struct bluezone *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluezone::highest",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_highest_set",1,SWIGTYPE_p_bluezone);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->highest = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_highest_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int result;
  
  SWIG_check_num_args("bluezone::highest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::highest",1,"struct bluezone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_highest_get",1,SWIGTYPE_p_bluezone);
  }
  
  result = (int) ((arg1)->highest);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_lowest_set(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("bluezone::lowest",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::lowest",1,"struct bluezone *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("bluezone::lowest",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_lowest_set",1,SWIGTYPE_p_bluezone);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lowest = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BlueZone_lowest_get(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *arg1 = (struct bluezone *) 0 ;
  int result;
  
  SWIG_check_num_args("bluezone::lowest",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("bluezone::lowest",1,"struct bluezone *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("BlueZone_lowest_get",1,SWIGTYPE_p_bluezone);
  }
  
  result = (int) ((arg1)->lowest);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_BlueZone(lua_State* L) {
  int SWIG_arg = 0;
  struct bluezone *result = 0 ;
  
  SWIG_check_num_args("bluezone::bluezone",0,0)
  result = (struct bluezone *)calloc(1, sizeof(struct bluezone));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bluezone,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_BlueZone(void *obj) {
struct bluezone *arg1 = (struct bluezone *) obj;
free((char *) arg1);
}
static swig_lua_method swig_bluezone_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_bluezone_attributes[] = {
    { "base", _wrap_BlueZone_base_get, _wrap_BlueZone_base_set},
    { "cvtindex", _wrap_BlueZone_cvtindex_get, _wrap_BlueZone_cvtindex_set},
    { "family_base", _wrap_BlueZone_family_base_get, _wrap_BlueZone_family_base_set},
    { "family_cvtindex", _wrap_BlueZone_family_cvtindex_get, _wrap_BlueZone_family_cvtindex_set},
    { "overshoot", _wrap_BlueZone_overshoot_get, _wrap_BlueZone_overshoot_set},
    { "highest", _wrap_BlueZone_highest_get, _wrap_BlueZone_highest_set},
    { "lowest", _wrap_BlueZone_lowest_get, _wrap_BlueZone_lowest_set},
    {0,0,0}
};
static swig_lua_class *swig_bluezone_bases[] = {0};
static const char *swig_bluezone_base_names[] = {0};
static swig_lua_class _wrap_class_bluezone = { "BlueZone", &SWIGTYPE_p_bluezone,_wrap_new_BlueZone, swig_delete_BlueZone, swig_bluezone_methods, swig_bluezone_attributes, swig_bluezone_bases, swig_bluezone_base_names };

static int _wrap_StdStem_width_set(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("stdstem::width",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::width",1,"struct stdstem *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("stdstem::width",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_width_set",1,SWIGTYPE_p_stdstem);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  if (arg1) (arg1)->width = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdStem_width_get(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  float result;
  
  SWIG_check_num_args("stdstem::width",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::width",1,"struct stdstem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_width_get",1,SWIGTYPE_p_stdstem);
  }
  
  result = (float) ((arg1)->width);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdStem_cvtindex_set(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("stdstem::cvtindex",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::cvtindex",1,"struct stdstem *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("stdstem::cvtindex",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_cvtindex_set",1,SWIGTYPE_p_stdstem);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cvtindex = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdStem_cvtindex_get(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  int result;
  
  SWIG_check_num_args("stdstem::cvtindex",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::cvtindex",1,"struct stdstem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_cvtindex_get",1,SWIGTYPE_p_stdstem);
  }
  
  result = (int) ((arg1)->cvtindex);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdStem_snapto_set(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  struct stdstem *arg2 = (struct stdstem *) 0 ;
  
  SWIG_check_num_args("stdstem::snapto",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::snapto",1,"struct stdstem *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("stdstem::snapto",2,"struct stdstem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_snapto_set",1,SWIGTYPE_p_stdstem);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_stdstem,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("StdStem_snapto_set",2,SWIGTYPE_p_stdstem);
  }
  
  if (arg1) (arg1)->snapto = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdStem_snapto_get(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  struct stdstem *result = 0 ;
  
  SWIG_check_num_args("stdstem::snapto",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::snapto",1,"struct stdstem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_snapto_get",1,SWIGTYPE_p_stdstem);
  }
  
  result = (struct stdstem *) ((arg1)->snapto);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_stdstem,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdStem_stopat_set(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("stdstem::stopat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::stopat",1,"struct stdstem *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("stdstem::stopat",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_stopat_set",1,SWIGTYPE_p_stdstem);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->stopat = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdStem_stopat_get(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *arg1 = (struct stdstem *) 0 ;
  int result;
  
  SWIG_check_num_args("stdstem::stopat",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("stdstem::stopat",1,"struct stdstem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("StdStem_stopat_get",1,SWIGTYPE_p_stdstem);
  }
  
  result = (int) ((arg1)->stopat);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_StdStem(lua_State* L) {
  int SWIG_arg = 0;
  struct stdstem *result = 0 ;
  
  SWIG_check_num_args("stdstem::stdstem",0,0)
  result = (struct stdstem *)calloc(1, sizeof(struct stdstem));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_stdstem,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_StdStem(void *obj) {
struct stdstem *arg1 = (struct stdstem *) obj;
free((char *) arg1);
}
static swig_lua_method swig_stdstem_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_stdstem_attributes[] = {
    { "width", _wrap_StdStem_width_get, _wrap_StdStem_width_set},
    { "cvtindex", _wrap_StdStem_cvtindex_get, _wrap_StdStem_cvtindex_set},
    { "snapto", _wrap_StdStem_snapto_get, _wrap_StdStem_snapto_set},
    { "stopat", _wrap_StdStem_stopat_get, _wrap_StdStem_stopat_set},
    {0,0,0}
};
static swig_lua_class *swig_stdstem_bases[] = {0};
static const char *swig_stdstem_base_names[] = {0};
static swig_lua_class _wrap_class_stdstem = { "StdStem", &SWIGTYPE_p_stdstem,_wrap_new_StdStem, swig_delete_StdStem, swig_stdstem_methods, swig_stdstem_attributes, swig_stdstem_bases, swig_stdstem_base_names };

static int _wrap_GlobalInstrCt_sf_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("globalinstrct::sf",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::sf",1,"struct globalinstrct *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("globalinstrct::sf",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_sf_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("GlobalInstrCt_sf_set",2,SWIGTYPE_p_splinefont);
  }
  
  if (arg1) (arg1)->sf = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_sf_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::sf",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::sf",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_sf_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (SplineFont *) ((arg1)->sf);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_layer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("globalinstrct::layer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::layer",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::layer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_layer_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->layer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_layer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int result;
  
  SWIG_check_num_args("globalinstrct::layer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::layer",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_layer_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (int) ((arg1)->layer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_bd_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  BlueData *arg2 = (BlueData *) 0 ;
  
  SWIG_check_num_args("globalinstrct::bd",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::bd",1,"struct globalinstrct *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("globalinstrct::bd",2,"BlueData *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_bd_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bluedata,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("GlobalInstrCt_bd_set",2,SWIGTYPE_p_bluedata);
  }
  
  if (arg1) (arg1)->bd = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_bd_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  BlueData *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::bd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::bd",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_bd_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (BlueData *) ((arg1)->bd);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bluedata,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_fudge_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  double arg2 ;
  
  SWIG_check_num_args("globalinstrct::fudge",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::fudge",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::fudge",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_fudge_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  if (arg1) (arg1)->fudge = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_fudge_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  double result;
  
  SWIG_check_num_args("globalinstrct::fudge",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::fudge",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_fudge_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (double) ((arg1)->fudge);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_cvt_done_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("globalinstrct::cvt_done",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::cvt_done",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::cvt_done",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_cvt_done_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cvt_done = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_cvt_done_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int result;
  
  SWIG_check_num_args("globalinstrct::cvt_done",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::cvt_done",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_cvt_done_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (int) ((arg1)->cvt_done);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_fpgm_done_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("globalinstrct::fpgm_done",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::fpgm_done",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::fpgm_done",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_fpgm_done_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->fpgm_done = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_fpgm_done_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int result;
  
  SWIG_check_num_args("globalinstrct::fpgm_done",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::fpgm_done",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_fpgm_done_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (int) ((arg1)->fpgm_done);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_prep_done_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("globalinstrct::prep_done",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::prep_done",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::prep_done",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_prep_done_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->prep_done = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_prep_done_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int result;
  
  SWIG_check_num_args("globalinstrct::prep_done",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::prep_done",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_prep_done_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (int) ((arg1)->prep_done);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_blues_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  BlueZone *arg2 ;
  
  SWIG_check_num_args("globalinstrct::blues",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::blues",1,"struct globalinstrct *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("globalinstrct::blues",2,"BlueZone [12]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_blues_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bluezone,0))){
    SWIG_fail_ptr("GlobalInstrCt_blues_set",2,SWIGTYPE_p_bluezone);
  }
  
  {
    size_t ii;
    BlueZone *b = (BlueZone *) arg1->blues;
    for (ii = 0; ii < (size_t)12; ii++) b[ii] = *((BlueZone *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_blues_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  BlueZone *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::blues",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::blues",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_blues_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (BlueZone *)(BlueZone *) ((arg1)->blues);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bluezone,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_bluecnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("globalinstrct::bluecnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::bluecnt",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::bluecnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_bluecnt_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->bluecnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_bluecnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int result;
  
  SWIG_check_num_args("globalinstrct::bluecnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::bluecnt",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_bluecnt_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (int) ((arg1)->bluecnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stdhw_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *arg2 = (StdStem *) 0 ;
  
  SWIG_check_num_args("globalinstrct::stdhw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stdhw",1,"struct globalinstrct *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("globalinstrct::stdhw",2,"StdStem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stdhw_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("GlobalInstrCt_stdhw_set",2,SWIGTYPE_p_stdstem);
  }
  
  if (arg1) (arg1)->stdhw = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stdhw_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::stdhw",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stdhw",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stdhw_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (StdStem *)& ((arg1)->stdhw);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_stdstem,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnaph_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *arg2 = (StdStem *) 0 ;
  
  SWIG_check_num_args("globalinstrct::stemsnaph",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnaph",1,"struct globalinstrct *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("globalinstrct::stemsnaph",2,"StdStem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnaph_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_stdstem,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnaph_set",2,SWIGTYPE_p_stdstem);
  }
  
  if (arg1) (arg1)->stemsnaph = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnaph_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::stemsnaph",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnaph",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnaph_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (StdStem *) ((arg1)->stemsnaph);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_stdstem,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnaphcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("globalinstrct::stemsnaphcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnaphcnt",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::stemsnaphcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnaphcnt_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->stemsnaphcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnaphcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int result;
  
  SWIG_check_num_args("globalinstrct::stemsnaphcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnaphcnt",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnaphcnt_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (int) ((arg1)->stemsnaphcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stdvw_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *arg2 = (StdStem *) 0 ;
  
  SWIG_check_num_args("globalinstrct::stdvw",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stdvw",1,"struct globalinstrct *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("globalinstrct::stdvw",2,"StdStem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stdvw_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_stdstem,0))){
    SWIG_fail_ptr("GlobalInstrCt_stdvw_set",2,SWIGTYPE_p_stdstem);
  }
  
  if (arg1) (arg1)->stdvw = *arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stdvw_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::stdvw",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stdvw",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stdvw_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (StdStem *)& ((arg1)->stdvw);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_stdstem,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnapv_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *arg2 = (StdStem *) 0 ;
  
  SWIG_check_num_args("globalinstrct::stemsnapv",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnapv",1,"struct globalinstrct *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("globalinstrct::stemsnapv",2,"StdStem *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnapv_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_stdstem,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnapv_set",2,SWIGTYPE_p_stdstem);
  }
  
  if (arg1) (arg1)->stemsnapv = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnapv_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  StdStem *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::stemsnapv",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnapv",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnapv_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (StdStem *) ((arg1)->stemsnapv);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_stdstem,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnapvcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("globalinstrct::stemsnapvcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnapvcnt",1,"struct globalinstrct *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("globalinstrct::stemsnapvcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnapvcnt_set",1,SWIGTYPE_p_globalinstrct);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->stemsnapvcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlobalInstrCt_stemsnapvcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *arg1 = (struct globalinstrct *) 0 ;
  int result;
  
  SWIG_check_num_args("globalinstrct::stemsnapvcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("globalinstrct::stemsnapvcnt",1,"struct globalinstrct *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("GlobalInstrCt_stemsnapvcnt_get",1,SWIGTYPE_p_globalinstrct);
  }
  
  result = (int) ((arg1)->stemsnapvcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_GlobalInstrCt(lua_State* L) {
  int SWIG_arg = 0;
  struct globalinstrct *result = 0 ;
  
  SWIG_check_num_args("globalinstrct::globalinstrct",0,0)
  result = (struct globalinstrct *)calloc(1, sizeof(struct globalinstrct));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_globalinstrct,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_GlobalInstrCt(void *obj) {
struct globalinstrct *arg1 = (struct globalinstrct *) obj;
free((char *) arg1);
}
static swig_lua_method swig_globalinstrct_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_globalinstrct_attributes[] = {
    { "sf", _wrap_GlobalInstrCt_sf_get, _wrap_GlobalInstrCt_sf_set},
    { "layer", _wrap_GlobalInstrCt_layer_get, _wrap_GlobalInstrCt_layer_set},
    { "bd", _wrap_GlobalInstrCt_bd_get, _wrap_GlobalInstrCt_bd_set},
    { "fudge", _wrap_GlobalInstrCt_fudge_get, _wrap_GlobalInstrCt_fudge_set},
    { "cvt_done", _wrap_GlobalInstrCt_cvt_done_get, _wrap_GlobalInstrCt_cvt_done_set},
    { "fpgm_done", _wrap_GlobalInstrCt_fpgm_done_get, _wrap_GlobalInstrCt_fpgm_done_set},
    { "prep_done", _wrap_GlobalInstrCt_prep_done_get, _wrap_GlobalInstrCt_prep_done_set},
    { "blues", _wrap_GlobalInstrCt_blues_get, _wrap_GlobalInstrCt_blues_set},
    { "bluecnt", _wrap_GlobalInstrCt_bluecnt_get, _wrap_GlobalInstrCt_bluecnt_set},
    { "stdhw", _wrap_GlobalInstrCt_stdhw_get, _wrap_GlobalInstrCt_stdhw_set},
    { "stemsnaph", _wrap_GlobalInstrCt_stemsnaph_get, _wrap_GlobalInstrCt_stemsnaph_set},
    { "stemsnaphcnt", _wrap_GlobalInstrCt_stemsnaphcnt_get, _wrap_GlobalInstrCt_stemsnaphcnt_set},
    { "stdvw", _wrap_GlobalInstrCt_stdvw_get, _wrap_GlobalInstrCt_stdvw_set},
    { "stemsnapv", _wrap_GlobalInstrCt_stemsnapv_get, _wrap_GlobalInstrCt_stemsnapv_set},
    { "stemsnapvcnt", _wrap_GlobalInstrCt_stemsnapvcnt_get, _wrap_GlobalInstrCt_stemsnapvcnt_set},
    {0,0,0}
};
static swig_lua_class *swig_globalinstrct_bases[] = {0};
static const char *swig_globalinstrct_base_names[] = {0};
static swig_lua_class _wrap_class_globalinstrct = { "GlobalInstrCt", &SWIGTYPE_p_globalinstrct,_wrap_new_GlobalInstrCt, swig_delete_GlobalInstrCt, swig_globalinstrct_methods, swig_globalinstrct_attributes, swig_globalinstrct_bases, swig_globalinstrct_base_names };

static int _wrap_InitGlobalInstrCt(lua_State* L) {
  int SWIG_arg = 0;
  GlobalInstrCt *arg1 = (GlobalInstrCt *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int arg3 ;
  BlueData *arg4 = (BlueData *) 0 ;
  
  SWIG_check_num_args("InitGlobalInstrCt",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("InitGlobalInstrCt",1,"GlobalInstrCt *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("InitGlobalInstrCt",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("InitGlobalInstrCt",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("InitGlobalInstrCt",4,"BlueData *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("InitGlobalInstrCt",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("InitGlobalInstrCt",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("InitGlobalInstrCt",4,SWIGTYPE_p_bluedata);
  }
  
  InitGlobalInstrCt(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeGlobalInstrCt(lua_State* L) {
  int SWIG_arg = 0;
  GlobalInstrCt *arg1 = (GlobalInstrCt *) 0 ;
  
  SWIG_check_num_args("FreeGlobalInstrCt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FreeGlobalInstrCt",1,"GlobalInstrCt *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("FreeGlobalInstrCt",1,SWIGTYPE_p_globalinstrct);
  }
  
  FreeGlobalInstrCt(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NowakowskiSCAutoInstr(lua_State* L) {
  int SWIG_arg = 0;
  GlobalInstrCt *arg1 = (GlobalInstrCt *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("NowakowskiSCAutoInstr",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NowakowskiSCAutoInstr",1,"GlobalInstrCt *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("NowakowskiSCAutoInstr",2,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_globalinstrct,0))){
    SWIG_fail_ptr("NowakowskiSCAutoInstr",1,SWIGTYPE_p_globalinstrct);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("NowakowskiSCAutoInstr",2,SWIGTYPE_p_splinechar);
  }
  
  NowakowskiSCAutoInstr(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCModifyHintMasksAdd(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  StemInfo *arg3 = (StemInfo *) 0 ;
  
  SWIG_check_num_args("SCModifyHintMasksAdd",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCModifyHintMasksAdd",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCModifyHintMasksAdd",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCModifyHintMasksAdd",3,"StemInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCModifyHintMasksAdd",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("SCModifyHintMasksAdd",3,SWIGTYPE_p_steminfo);
  }
  
  SCModifyHintMasksAdd(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearHints(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCClearHints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearHints",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearHints",1,SWIGTYPE_p_splinechar);
  }
  
  SCClearHints(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearHintMasks(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("SCClearHintMasks",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearHintMasks",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCClearHintMasks",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCClearHintMasks",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearHintMasks",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  SCClearHintMasks(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCFigureVerticalCounterMasks(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCFigureVerticalCounterMasks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCFigureVerticalCounterMasks",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCFigureVerticalCounterMasks",1,SWIGTYPE_p_splinechar);
  }
  
  SCFigureVerticalCounterMasks(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCFigureCounterMasks(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCFigureCounterMasks",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCFigureCounterMasks",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCFigureCounterMasks",1,SWIGTYPE_p_splinechar);
  }
  
  SCFigureCounterMasks(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCFigureHintMasks(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCFigureHintMasks",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCFigureHintMasks",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCFigureHintMasks",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCFigureHintMasks",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCFigureHintMasks(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SplineCharAutoHint(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  BlueData *arg3 = (BlueData *) 0 ;
  struct glyphdata *arg4 = (struct glyphdata *) 0 ;
  int arg5 ;
  
  SWIG_check_num_args("_SplineCharAutoHint",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_SplineCharAutoHint",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_SplineCharAutoHint",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("_SplineCharAutoHint",3,"BlueData *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("_SplineCharAutoHint",4,"struct glyphdata *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("_SplineCharAutoHint",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_SplineCharAutoHint",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("_SplineCharAutoHint",3,SWIGTYPE_p_bluedata);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_glyphdata,0))){
    SWIG_fail_ptr("_SplineCharAutoHint",4,SWIGTYPE_p_glyphdata);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  _SplineCharAutoHint(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharAutoHint(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  BlueData *arg3 = (BlueData *) 0 ;
  
  SWIG_check_num_args("SplineCharAutoHint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharAutoHint",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharAutoHint",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineCharAutoHint",3,"BlueData *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharAutoHint",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("SplineCharAutoHint",3,SWIGTYPE_p_bluedata);
  }
  
  SplineCharAutoHint(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSCAutoHint(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  BlueData *arg3 = (BlueData *) 0 ;
  
  SWIG_check_num_args("SFSCAutoHint",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSCAutoHint",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFSCAutoHint",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFSCAutoHint",3,"BlueData *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFSCAutoHint",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_bluedata,0))){
    SWIG_fail_ptr("SFSCAutoHint",3,SWIGTYPE_p_bluedata);
  }
  
  SFSCAutoHint(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontAutoHint(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SplineFontAutoHint",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontAutoHint",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontAutoHint",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontAutoHint",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SplineFontAutoHint(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontAutoHintRefs(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SplineFontAutoHintRefs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontAutoHintRefs",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontAutoHintRefs",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontAutoHintRefs",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SplineFontAutoHintRefs(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HintCleanup(lua_State* L) {
  int SWIG_arg = 0;
  StemInfo *arg1 = (StemInfo *) 0 ;
  int arg2 ;
  int arg3 ;
  StemInfo *result = 0 ;
  
  SWIG_check_num_args("HintCleanup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HintCleanup",1,"StemInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("HintCleanup",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("HintCleanup",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_steminfo,0))){
    SWIG_fail_ptr("HintCleanup",1,SWIGTYPE_p_steminfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (StemInfo *)HintCleanup(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_steminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontIsFlexible(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("SplineFontIsFlexible",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontIsFlexible",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontIsFlexible",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFontIsFlexible",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontIsFlexible",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)SplineFontIsFlexible(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCDrawsSomething(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int result;
  
  SWIG_check_num_args("SCDrawsSomething",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCDrawsSomething",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCDrawsSomething",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int)SCDrawsSomething(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCWorthOutputting(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int result;
  
  SWIG_check_num_args("SCWorthOutputting",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCWorthOutputting",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCWorthOutputting",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int)SCWorthOutputting(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindNotdef(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("SFFindNotdef",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindNotdef",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFFindNotdef",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindNotdef",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)SFFindNotdef(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_doesGlyphExpandHorizontally(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int result;
  
  SWIG_check_num_args("doesGlyphExpandHorizontally",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("doesGlyphExpandHorizontally",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("doesGlyphExpandHorizontally",1,SWIGTYPE_p_splinechar);
  }
  
  result = (int)doesGlyphExpandHorizontally(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_IsntBDFChar(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  int result;
  
  SWIG_check_num_args("IsntBDFChar",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("IsntBDFChar",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("IsntBDFChar",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (int)IsntBDFChar(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CIDWorthOutputting(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("CIDWorthOutputting",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CIDWorthOutputting",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CIDWorthOutputting",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CIDWorthOutputting",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)CIDWorthOutputting(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AmfmSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  MMSet *arg2 = (MMSet *) 0 ;
  int arg3 ;
  EncMap *arg4 = (EncMap *) 0 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("AmfmSplineFont",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AmfmSplineFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AmfmSplineFont",2,"MMSet *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("AmfmSplineFont",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("AmfmSplineFont",4,"EncMap *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("AmfmSplineFont",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("AmfmSplineFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("AmfmSplineFont",2,SWIGTYPE_p_mmset);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("AmfmSplineFont",4,SWIGTYPE_p_encmap);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)AmfmSplineFont(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AfmSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int arg3 ;
  EncMap *arg4 = (EncMap *) 0 ;
  int arg5 ;
  SplineFont *arg6 = (SplineFont *) 0 ;
  int arg7 ;
  int result;
  
  SWIG_check_num_args("AfmSplineFont",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AfmSplineFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AfmSplineFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("AfmSplineFont",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("AfmSplineFont",4,"EncMap *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("AfmSplineFont",5,"int");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("AfmSplineFont",6,"SplineFont *");
  if(!lua_isnumber(L,7)) SWIG_fail_arg("AfmSplineFont",7,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("AfmSplineFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("AfmSplineFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("AfmSplineFont",4,SWIGTYPE_p_encmap);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("AfmSplineFont",6,SWIGTYPE_p_splinefont);
  }
  
  arg7 = (int)lua_tonumber(L, 7);
  result = (int)AfmSplineFont(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PfmSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int arg3 ;
  EncMap *arg4 = (EncMap *) 0 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("PfmSplineFont",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PfmSplineFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PfmSplineFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("PfmSplineFont",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("PfmSplineFont",4,"EncMap *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("PfmSplineFont",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("PfmSplineFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("PfmSplineFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("PfmSplineFont",4,SWIGTYPE_p_encmap);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)PfmSplineFont(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TfmSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int arg3 ;
  EncMap *arg4 = (EncMap *) 0 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("TfmSplineFont",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TfmSplineFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("TfmSplineFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("TfmSplineFont",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("TfmSplineFont",4,"EncMap *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("TfmSplineFont",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("TfmSplineFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("TfmSplineFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("TfmSplineFont",4,SWIGTYPE_p_encmap);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)TfmSplineFont(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OfmSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int arg3 ;
  EncMap *arg4 = (EncMap *) 0 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("OfmSplineFont",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OfmSplineFont",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OfmSplineFont",2,"SplineFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("OfmSplineFont",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("OfmSplineFont",4,"EncMap *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("OfmSplineFont",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("OfmSplineFont",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("OfmSplineFont",2,SWIGTYPE_p_splinefont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("OfmSplineFont",4,SWIGTYPE_p_encmap);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)OfmSplineFont(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncodingName(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *arg1 = (Encoding *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("EncodingName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("EncodingName",1,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("EncodingName",1,SWIGTYPE_p_enc);
  }
  
  result = (char *)EncodingName(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFEncodingName(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("SFEncodingName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFEncodingName",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFEncodingName",2,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFEncodingName",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFEncodingName",2,SWIGTYPE_p_encmap);
  }
  
  result = (char *)SFEncodingName(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFLigaturePrepare(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFLigaturePrepare",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFLigaturePrepare",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFLigaturePrepare",1,SWIGTYPE_p_splinefont);
  }
  
  SFLigaturePrepare(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFLigatureCleanup(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFLigatureCleanup",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFLigatureCleanup",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFLigatureCleanup",1,SWIGTYPE_p_splinefont);
  }
  
  SFLigatureCleanup(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFKernClassTempDecompose(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFKernClassTempDecompose",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFKernClassTempDecompose",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFKernClassTempDecompose",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFKernClassTempDecompose",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFKernClassTempDecompose(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFKernCleanup(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFKernCleanup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFKernCleanup",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFKernCleanup",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFKernCleanup",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFKernCleanup(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCSetMetaData(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SCSetMetaData",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCSetMetaData",1,"SplineChar *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SCSetMetaData",2,"char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCSetMetaData",3,"int");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SCSetMetaData",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCSetMetaData",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (int)SCSetMetaData(arg1,arg2,arg3,(char const *)arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_interp_from_encoding(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *arg1 = (Encoding *) 0 ;
  enum uni_interp arg2 ;
  enum uni_interp result;
  
  SWIG_check_num_args("interp_from_encoding",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("interp_from_encoding",1,"Encoding *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("interp_from_encoding",2,"enum uni_interp");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("interp_from_encoding",1,SWIGTYPE_p_enc);
  }
  
  arg2 = (enum uni_interp)(int)lua_tonumber(L, 2);
  result = (enum uni_interp)interp_from_encoding(arg1,arg2);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncName(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *arg1 = (Encoding *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("EncName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("EncName",1,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("EncName",1,SWIGTYPE_p_enc);
  }
  
  result = (char *)EncName(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindUnicharName(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("FindUnicharName",0,0)
  result = (char *)FindUnicharName();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__FindOrMakeEncoding(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  Encoding *result = 0 ;
  
  SWIG_check_num_args("_FindOrMakeEncoding",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("_FindOrMakeEncoding",1,"char const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_FindOrMakeEncoding",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (Encoding *)_FindOrMakeEncoding((char const *)arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindOrMakeEncoding(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  Encoding *result = 0 ;
  
  SWIG_check_num_args("FindOrMakeEncoding",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("FindOrMakeEncoding",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (Encoding *)FindOrMakeEncoding((char const *)arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDDumpMacFeat(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  MacFeat *arg2 = (MacFeat *) 0 ;
  
  SWIG_check_num_args("SFDDumpMacFeat",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDDumpMacFeat",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFDDumpMacFeat",2,"MacFeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SFDDumpMacFeat",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("SFDDumpMacFeat",2,SWIGTYPE_p_macfeat);
  }
  
  SFDDumpMacFeat(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDParseMacFeatures(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  char *arg2 = (char *) 0 ;
  MacFeat *result = 0 ;
  
  SWIG_check_num_args("SFDParseMacFeatures",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDParseMacFeatures",1,"FILE *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFDParseMacFeatures",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SFDParseMacFeatures",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (MacFeat *)SFDParseMacFeatures(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macfeat,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDWrite(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  EncMap *arg4 = (EncMap *) 0 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("SFDWrite",5,5)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFDWrite",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFDWrite",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFDWrite",3,"EncMap *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SFDWrite",4,"EncMap *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SFDWrite",5,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDWrite",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFDWrite",3,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFDWrite",4,SWIGTYPE_p_encmap);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)SFDWrite(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDWriteBak(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int result;
  
  SWIG_check_num_args("SFDWriteBak",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDWriteBak",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFDWriteBak",2,"EncMap *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFDWriteBak",3,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDWriteBak",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFDWriteBak",2,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFDWriteBak",3,SWIGTYPE_p_encmap);
  }
  
  result = (int)SFDWriteBak(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDRead(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFDRead",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFDRead",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (SplineFont *)SFDRead(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SFDRead(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("_SFDRead",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("_SFDRead",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_SFDRead",2,"FILE *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_SFDRead",2,SWIGTYPE_p_FILE);
  }
  
  result = (SplineFont *)_SFDRead(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDirRead(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFDirRead",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFDirRead",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (SplineFont *)SFDirRead(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDReadOneChar(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SFDReadOneChar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDReadOneChar",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFDReadOneChar",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDReadOneChar",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (SplineChar *)SFDReadOneChar(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TTFGetFontName(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int32 arg2 ;
  int32 arg3 ;
  char *result = 0 ;
  
  SWIG_check_num_args("TTFGetFontName",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TTFGetFontName",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("TTFGetFontName",2,"int32");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("TTFGetFontName",3,"int32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("TTFGetFontName",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (int32)lua_tonumber(L, 2);
  arg3 = (int32)lua_tonumber(L, 3);
  result = (char *)TTFGetFontName(arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TTFLoadBitmaps(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  struct ttfinfo *arg2 = (struct ttfinfo *) 0 ;
  int arg3 ;
  
  SWIG_check_num_args("TTFLoadBitmaps",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TTFLoadBitmaps",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("TTFLoadBitmaps",2,"struct ttfinfo *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("TTFLoadBitmaps",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("TTFLoadBitmaps",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_ttfinfo,0))){
    SWIG_fail_ptr("TTFLoadBitmaps",2,SWIGTYPE_p_ttfinfo);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  TTFLoadBitmaps(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SFReadWOFF(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int arg2 ;
  enum openflags arg3 ;
  char *arg4 = (char *) 0 ;
  struct fontdict *arg5 = (struct fontdict *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("_SFReadWOFF",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_SFReadWOFF",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_SFReadWOFF",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_SFReadWOFF",3,"enum openflags");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("_SFReadWOFF",4,"char *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("_SFReadWOFF",5,"struct fontdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_SFReadWOFF",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (enum openflags)(int)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_fontdict,0))){
    SWIG_fail_ptr("_SFReadWOFF",5,SWIGTYPE_p_fontdict);
  }
  
  result = (SplineFont *)_SFReadWOFF(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SFReadTTF(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int arg2 ;
  enum openflags arg3 ;
  char *arg4 = (char *) 0 ;
  struct fontdict *arg5 = (struct fontdict *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("_SFReadTTF",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_SFReadTTF",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_SFReadTTF",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_SFReadTTF",3,"enum openflags");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("_SFReadTTF",4,"char *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("_SFReadTTF",5,"struct fontdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_SFReadTTF",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (enum openflags)(int)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_fontdict,0))){
    SWIG_fail_ptr("_SFReadTTF",5,SWIGTYPE_p_fontdict);
  }
  
  result = (SplineFont *)_SFReadTTF(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadTTF(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  enum openflags arg3 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadTTF",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadTTF",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadTTF",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFReadTTF",3,"enum openflags");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (enum openflags)(int)lua_tonumber(L, 3);
  result = (SplineFont *)SFReadTTF(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadSVG(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadSVG",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadSVG",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadSVG",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (SplineFont *)SFReadSVG(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadSVGMem(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadSVGMem",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadSVGMem",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadSVGMem",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (SplineFont *)SFReadSVGMem(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadUFO(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadUFO",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadUFO",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadUFO",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (SplineFont *)SFReadUFO(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__CFFParse(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("_CFFParse",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_CFFParse",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_CFFParse",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("_CFFParse",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_CFFParse",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (SplineFont *)_CFFParse(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CFFParse(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("CFFParse",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("CFFParse",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (SplineFont *)CFFParse(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadMacBinary(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  enum openflags arg3 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadMacBinary",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadMacBinary",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadMacBinary",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFReadMacBinary",3,"enum openflags");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (enum openflags)(int)lua_tonumber(L, 3);
  result = (SplineFont *)SFReadMacBinary(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadWinFON(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadWinFON",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadWinFON",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadWinFON",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (SplineFont *)SFReadWinFON(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadPalmPdb(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadPalmPdb",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadPalmPdb",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadPalmPdb",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (SplineFont *)SFReadPalmPdb(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  enum openflags arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("LoadSplineFont",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("LoadSplineFont",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("LoadSplineFont",2,"enum openflags");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (enum openflags)(int)lua_tonumber(L, 2);
  result = (SplineFont *)LoadSplineFont(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__ReadSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  char *arg2 = (char *) 0 ;
  enum openflags arg3 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("_ReadSplineFont",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_ReadSplineFont",1,"FILE *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("_ReadSplineFont",2,"char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_ReadSplineFont",3,"enum openflags");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_ReadSplineFont",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (enum openflags)(int)lua_tonumber(L, 3);
  result = (SplineFont *)_ReadSplineFont(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ReadSplineFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  enum openflags arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("ReadSplineFont",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ReadSplineFont",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ReadSplineFont",2,"enum openflags");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (enum openflags)(int)lua_tonumber(L, 2);
  result = (SplineFont *)ReadSplineFont(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_URLToTempFile(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  void *arg2 = (void *) 0 ;
  FILE *result = 0 ;
  
  SWIG_check_num_args("URLToTempFile",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("URLToTempFile",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("URLToTempFile",2,"void *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"URLToTempFile");
  result = (FILE *)URLToTempFile(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_FILE,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_URLFromFile(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  int result;
  
  SWIG_check_num_args("URLFromFile",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("URLFromFile",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("URLFromFile",2,"FILE *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("URLFromFile",2,SWIGTYPE_p_FILE);
  }
  
  result = (int)URLFromFile(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HttpGetBuf(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int *arg3 = (int *) 0 ;
  void *arg4 = (void *) 0 ;
  int result;
  
  SWIG_check_num_args("HttpGetBuf",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("HttpGetBuf",1,"char *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("HttpGetBuf",2,"char *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("HttpGetBuf",3,"int *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("HttpGetBuf",4,"void *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("HttpGetBuf",3,SWIGTYPE_p_int);
  }
  
  arg4=(void *)SWIG_MustGetPtr(L,4,0,0,4,"HttpGetBuf");
  result = (int)HttpGetBuf(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ArchiveCleanup(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("ArchiveCleanup",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ArchiveCleanup",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  ArchiveCleanup(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Unarchive(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **arg2 = (char **) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("Unarchive",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("Unarchive",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("Unarchive",2,"char **");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("Unarchive",2,SWIGTYPE_p_p_char);
  }
  
  result = (char *)Unarchive(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Decompress(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  SWIG_check_num_args("Decompress",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("Decompress",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Decompress",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (char *)Decompress(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFromBDF(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFFromBDF",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFFromBDF",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFFromBDF",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFFromBDF",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (SplineFont *)SFFromBDF(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFromMF(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFFromMF",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFFromMF",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (SplineFont *)SFFromMF(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFCheckPSBitmap(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFCheckPSBitmap",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFCheckPSBitmap",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFCheckPSBitmap",1,SWIGTYPE_p_splinefont);
  }
  
  SFCheckPSBitmap(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__MacStyleCode(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  uint16 *arg3 = (uint16 *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("_MacStyleCode",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("_MacStyleCode",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_MacStyleCode",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("_MacStyleCode",3,"uint16 *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_MacStyleCode",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("_MacStyleCode",3,SWIGTYPE_p_unsigned_short);
  }
  
  result = (uint16)_MacStyleCode(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacStyleCode(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("MacStyleCode",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MacStyleCode",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MacStyleCode",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("MacStyleCode",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("MacStyleCode",2,SWIGTYPE_p_unsigned_short);
  }
  
  result = (uint16)MacStyleCode(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadIkarus(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadIkarus",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadIkarus",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (SplineFont *)SFReadIkarus(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SFReadPdfFont(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  enum openflags arg4 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("_SFReadPdfFont",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_SFReadPdfFont",1,"FILE *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("_SFReadPdfFont",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("_SFReadPdfFont",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("_SFReadPdfFont",4,"enum openflags");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_SFReadPdfFont",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (enum openflags)(int)lua_tonumber(L, 4);
  result = (SplineFont *)_SFReadPdfFont(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFReadPdfFont(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  enum openflags arg2 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFReadPdfFont",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFReadPdfFont",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFReadPdfFont",2,"enum openflags");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (enum openflags)(int)lua_tonumber(L, 2);
  result = (SplineFont *)SFReadPdfFont(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GetFontNames(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("GetFontNames",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("GetFontNames",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)GetFontNames(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadPDF(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadPDF",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadPDF",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadPDF(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadSFD(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadSFD",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadSFD",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadSFD(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadTTF(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadTTF",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadTTF",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadTTF(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadCFF(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadCFF",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadCFF",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadCFF(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadPostScript(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadPostScript",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadPostScript",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadPostScript(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__NamesReadPostScript(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("_NamesReadPostScript",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_NamesReadPostScript",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_NamesReadPostScript",1,SWIGTYPE_p_FILE);
  }
  
  result = (char **)_NamesReadPostScript(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadSVG(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadSVG",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadSVG",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadSVG(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadUFO(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadUFO",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadUFO",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadUFO(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NamesReadMacBinary(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("NamesReadMacBinary",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NamesReadMacBinary",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char **)NamesReadMacBinary(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSetOrder(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFSetOrder",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSetOrder",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFSetOrder",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSetOrder",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFSetOrder(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindOrder(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int result;
  
  SWIG_check_num_args("SFFindOrder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindOrder",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindOrder",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int)SFFindOrder(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UnicodeRange(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char *result = 0 ;
  
  SWIG_check_num_args("UnicodeRange",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("UnicodeRange",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (char *)UnicodeRange(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCBuildDummy(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int arg4 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SCBuildDummy",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCBuildDummy",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCBuildDummy",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCBuildDummy",3,"EncMap *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCBuildDummy",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCBuildDummy",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SCBuildDummy",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SCBuildDummy",3,SWIGTYPE_p_encmap);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (SplineChar *)SCBuildDummy(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFMakeChar(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SFMakeChar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFMakeChar",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFMakeChar",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFMakeChar",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFMakeChar",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFMakeChar",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (SplineChar *)SFMakeChar(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFMakeGID(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  int arg2 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("BDFMakeGID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFMakeGID",1,"BDFFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BDFMakeGID",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFMakeGID",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (BDFChar *)BDFMakeGID(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFMakeChar(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("BDFMakeChar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFMakeChar",1,"BDFFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BDFMakeChar",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BDFMakeChar",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFMakeChar",1,SWIGTYPE_p_bdffont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("BDFMakeChar",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (BDFChar *)BDFMakeChar(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefCharsCopyState(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  RefChar *result = 0 ;
  
  SWIG_check_num_args("RefCharsCopyState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefCharsCopyState",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RefCharsCopyState",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("RefCharsCopyState",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (RefChar *)RefCharsCopyState(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCWasEmpty(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("SCWasEmpty",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCWasEmpty",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCWasEmpty",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCWasEmpty",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)SCWasEmpty(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCUndoSetLBearingChange(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCUndoSetLBearingChange",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCUndoSetLBearingChange",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCUndoSetLBearingChange",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCUndoSetLBearingChange",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCUndoSetLBearingChange(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCPreserveHints(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("SCPreserveHints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCPreserveHints",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCPreserveHints",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCPreserveHints",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Undoes *)SCPreserveHints(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCPreserveLayer(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("SCPreserveLayer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCPreserveLayer",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCPreserveLayer",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCPreserveLayer",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCPreserveLayer",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (Undoes *)SCPreserveLayer(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__SCPreserveLayer(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("_SCPreserveLayer",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_SCPreserveLayer",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_SCPreserveLayer",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_SCPreserveLayer",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_SCPreserveLayer",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (Undoes *)_SCPreserveLayer(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCPreserveState(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("SCPreserveState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCPreserveState",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCPreserveState",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCPreserveState",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (Undoes *)SCPreserveState(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCPreserveBackground(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("SCPreserveBackground",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCPreserveBackground",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCPreserveBackground",1,SWIGTYPE_p_splinechar);
  }
  
  result = (Undoes *)SCPreserveBackground(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFPreserveGuide(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("SFPreserveGuide",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFPreserveGuide",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFPreserveGuide",1,SWIGTYPE_p_splinefont);
  }
  
  result = (Undoes *)SFPreserveGuide(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCPreserveWidth(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("SCPreserveWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCPreserveWidth",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCPreserveWidth",1,SWIGTYPE_p_splinechar);
  }
  
  result = (Undoes *)SCPreserveWidth(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCPreserveVWidth(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("SCPreserveVWidth",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCPreserveVWidth",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCPreserveVWidth",1,SWIGTYPE_p_splinechar);
  }
  
  result = (Undoes *)SCPreserveVWidth(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCPreserveState(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  Undoes *result = 0 ;
  
  SWIG_check_num_args("BCPreserveState",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCPreserveState",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCPreserveState",1,SWIGTYPE_p_bdfchar);
  }
  
  result = (Undoes *)BCPreserveState(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_undoes,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCDoRedo(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCDoRedo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCDoRedo",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCDoRedo",1,SWIGTYPE_p_bdfchar);
  }
  
  BCDoRedo(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCDoUndo(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCDoUndo",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCDoUndo",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCDoUndo",1,SWIGTYPE_p_bdfchar);
  }
  
  BCDoUndo(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_isaccent(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int result;
  
  SWIG_check_num_args("isaccent",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("isaccent",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (int)isaccent(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFIsCompositBuildable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("SFIsCompositBuildable",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFIsCompositBuildable",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFIsCompositBuildable",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFIsCompositBuildable",3,"SplineChar *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFIsCompositBuildable",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFIsCompositBuildable",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFIsCompositBuildable",3,SWIGTYPE_p_splinechar);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)SFIsCompositBuildable(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFIsSomethingBuildable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("SFIsSomethingBuildable",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFIsSomethingBuildable",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFIsSomethingBuildable",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFIsSomethingBuildable",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFIsSomethingBuildable",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFIsSomethingBuildable",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFIsSomethingBuildable",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)SFIsSomethingBuildable(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFIsRotatable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("SFIsRotatable",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFIsRotatable",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFIsRotatable",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFIsRotatable",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFIsRotatable",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFIsRotatable",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)SFIsRotatable(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCBuildComposit(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  BDFFont *arg4 = (BDFFont *) 0 ;
  int arg5 ;
  
  SWIG_check_num_args("SCBuildComposit",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCBuildComposit",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCBuildComposit",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCBuildComposit",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SCBuildComposit",4,"BDFFont *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCBuildComposit",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SCBuildComposit",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCBuildComposit",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("SCBuildComposit",4,SWIGTYPE_p_bdffont);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  SCBuildComposit(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCAppendAccent(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("SCAppendAccent",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCAppendAccent",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCAppendAccent",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SCAppendAccent",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCAppendAccent",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCAppendAccent",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCAppendAccent",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)SCAppendAccent(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGetAlternate(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  int arg4 ;
  unichar_t *result = 0 ;
  
  SWIG_check_num_args("SFGetAlternate",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGetAlternate",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFGetAlternate",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFGetAlternate",3,"SplineChar *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFGetAlternate",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGetAlternate",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFGetAlternate",3,SWIGTYPE_p_splinechar);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (unichar_t *)SFGetAlternate(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getAdobeEnc(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("getAdobeEnc",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("getAdobeEnc",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (int)getAdobeEnc(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSplinesFromLayers(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFSplinesFromLayers",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSplinesFromLayers",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFSplinesFromLayers",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSplinesFromLayers",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFSplinesFromLayers(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListInterpretSVG(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplinePointListInterpretSVG",6,6)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SplinePointListInterpretSVG",1,"char *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SplinePointListInterpretSVG",2,"char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplinePointListInterpretSVG",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplinePointListInterpretSVG",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplinePointListInterpretSVG",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SplinePointListInterpretSVG",6,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (SplineSet *)SplinePointListInterpretSVG(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListInterpretGlif(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SplinePointListInterpretGlif",6,6)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SplinePointListInterpretGlif",1,"char *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SplinePointListInterpretGlif",2,"char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplinePointListInterpretGlif",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplinePointListInterpretGlif",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplinePointListInterpretGlif",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SplinePointListInterpretGlif",6,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (SplineSet *)SplinePointListInterpretGlif(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListInterpretPS(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int arg2 ;
  int arg3 ;
  int *arg4 = (int *) 0 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("SplinePointListInterpretPS",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListInterpretPS",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplinePointListInterpretPS",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplinePointListInterpretPS",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SplinePointListInterpretPS",4,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SplinePointListInterpretPS",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SplinePointListInterpretPS",4,SWIGTYPE_p_int);
  }
  
  result = (SplinePointList *)SplinePointListInterpretPS(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSFontInterpretPS(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  struct charprocs *arg2 = (struct charprocs *) 0 ;
  char **arg3 = (char **) 0 ;
  
  SWIG_check_num_args("PSFontInterpretPS",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSFontInterpretPS",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PSFontInterpretPS",2,"struct charprocs *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PSFontInterpretPS",3,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("PSFontInterpretPS",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_charprocs,0))){
    SWIG_fail_ptr("PSFontInterpretPS",2,SWIGTYPE_p_charprocs);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("PSFontInterpretPS",3,SWIGTYPE_p_p_char);
  }
  
  PSFontInterpretPS(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSSlurpEncodings(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  struct enc *result = 0 ;
  
  SWIG_check_num_args("PSSlurpEncodings",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSSlurpEncodings",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("PSSlurpEncodings",1,SWIGTYPE_p_FILE);
  }
  
  result = (struct enc *)PSSlurpEncodings(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EvaluatePS(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  float *arg2 = (float *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("EvaluatePS",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("EvaluatePS",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("EvaluatePS",2,"float *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("EvaluatePS",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("EvaluatePS",2,SWIGTYPE_p_float);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)EvaluatePS(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_is_type2_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pscontext::is_type2",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::is_type2",1,"struct pscontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pscontext::is_type2",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_is_type2_set",1,SWIGTYPE_p_pscontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->is_type2 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_is_type2_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int result;
  
  SWIG_check_num_args("pscontext::is_type2",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::is_type2",1,"struct pscontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_is_type2_get",1,SWIGTYPE_p_pscontext);
  }
  
  result = (int) ((arg1)->is_type2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_painttype_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pscontext::painttype",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::painttype",1,"struct pscontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pscontext::painttype",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_painttype_set",1,SWIGTYPE_p_pscontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->painttype = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_painttype_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int result;
  
  SWIG_check_num_args("pscontext::painttype",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::painttype",1,"struct pscontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_painttype_get",1,SWIGTYPE_p_pscontext);
  }
  
  result = (int) ((arg1)->painttype);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_instance_count_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pscontext::instance_count",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::instance_count",1,"struct pscontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pscontext::instance_count",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_instance_count_set",1,SWIGTYPE_p_pscontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->instance_count = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_instance_count_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int result;
  
  SWIG_check_num_args("pscontext::instance_count",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::instance_count",1,"struct pscontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_instance_count_get",1,SWIGTYPE_p_pscontext);
  }
  
  result = (int) ((arg1)->instance_count);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_blend_values_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  float *arg2 ;
  
  SWIG_check_num_args("pscontext::blend_values",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::blend_values",1,"struct pscontext *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("pscontext::blend_values",2,"float [17]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_blend_values_set",1,SWIGTYPE_p_pscontext);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("pscontext_blend_values_set",2,SWIGTYPE_p_float);
  }
  
  {
    size_t ii;
    float *b = (float *) arg1->blend_values;
    for (ii = 0; ii < (size_t)17; ii++) b[ii] = *((float *) arg2 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_blend_values_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  float *result = 0 ;
  
  SWIG_check_num_args("pscontext::blend_values",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::blend_values",1,"struct pscontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_blend_values_get",1,SWIGTYPE_p_pscontext);
  }
  
  result = (float *)(float *) ((arg1)->blend_values);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_float,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_blend_warn_set(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("pscontext::blend_warn",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::blend_warn",1,"struct pscontext *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("pscontext::blend_warn",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_blend_warn_set",1,SWIGTYPE_p_pscontext);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->blend_warn = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pscontext_blend_warn_get(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *arg1 = (struct pscontext *) 0 ;
  int result;
  
  SWIG_check_num_args("pscontext::blend_warn",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("pscontext::blend_warn",1,"struct pscontext *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("pscontext_blend_warn_get",1,SWIGTYPE_p_pscontext);
  }
  
  result = (int) ((arg1)->blend_warn);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_pscontext(lua_State* L) {
  int SWIG_arg = 0;
  struct pscontext *result = 0 ;
  
  SWIG_check_num_args("pscontext::pscontext",0,0)
  result = (struct pscontext *)calloc(1, sizeof(struct pscontext));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pscontext,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_pscontext(void *obj) {
struct pscontext *arg1 = (struct pscontext *) obj;
free((char *) arg1);
}
static swig_lua_method swig_pscontext_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_pscontext_attributes[] = {
    { "is_type2", _wrap_pscontext_is_type2_get, _wrap_pscontext_is_type2_set},
    { "painttype", _wrap_pscontext_painttype_get, _wrap_pscontext_painttype_set},
    { "instance_count", _wrap_pscontext_instance_count_get, _wrap_pscontext_instance_count_set},
    { "blend_values", _wrap_pscontext_blend_values_get, _wrap_pscontext_blend_values_set},
    { "blend_warn", _wrap_pscontext_blend_warn_get, _wrap_pscontext_blend_warn_set},
    {0,0,0}
};
static swig_lua_class *swig_pscontext_bases[] = {0};
static const char *swig_pscontext_base_names[] = {0};
static swig_lua_class _wrap_class_pscontext = { "pscontext", &SWIGTYPE_p_pscontext,_wrap_new_pscontext, swig_delete_pscontext, swig_pscontext_methods, swig_pscontext_attributes, swig_pscontext_bases, swig_pscontext_base_names };

static int _wrap_UnblendedCompare(lua_State* L) {
  int SWIG_arg = 0;
  float *arg1 ;
  float *arg2 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("UnblendedCompare",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("UnblendedCompare",1,"float [16]");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("UnblendedCompare",2,"float [16]");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("UnblendedCompare",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("UnblendedCompare",1,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("UnblendedCompare",2,SWIGTYPE_p_float);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)UnblendedCompare(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSCharStringToSplines(lua_State* L) {
  int SWIG_arg = 0;
  uint8 *arg1 = (uint8 *) 0 ;
  int arg2 ;
  struct pscontext *arg3 = (struct pscontext *) 0 ;
  struct pschars *arg4 = (struct pschars *) 0 ;
  struct pschars *arg5 = (struct pschars *) 0 ;
  char *arg6 = (char *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("PSCharStringToSplines",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSCharStringToSplines",1,"uint8 *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("PSCharStringToSplines",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PSCharStringToSplines",3,"struct pscontext *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("PSCharStringToSplines",4,"struct pschars *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("PSCharStringToSplines",5,"struct pschars *");
  if(!SWIG_lua_isnilstring(L,6)) SWIG_fail_arg("PSCharStringToSplines",6,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_unsigned_char,0))){
    SWIG_fail_ptr("PSCharStringToSplines",1,SWIGTYPE_p_unsigned_char);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_pscontext,0))){
    SWIG_fail_ptr("PSCharStringToSplines",3,SWIGTYPE_p_pscontext);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("PSCharStringToSplines",4,SWIGTYPE_p_pschars);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("PSCharStringToSplines",5,SWIGTYPE_p_pschars);
  }
  
  arg6 = (char *)lua_tostring(L, 6);
  result = (SplineChar *)PSCharStringToSplines(arg1,arg2,arg3,arg4,arg5,(char const *)arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MatMultiply(lua_State* L) {
  int SWIG_arg = 0;
  float *arg1 ;
  float *arg2 ;
  float *arg3 ;
  
  SWIG_check_num_args("MatMultiply",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MatMultiply",1,"float [6]");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MatMultiply",2,"float [6]");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("MatMultiply",3,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("MatMultiply",1,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("MatMultiply",2,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("MatMultiply",3,SWIGTYPE_p_float);
  }
  
  MatMultiply(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MatIsIdentity(lua_State* L) {
  int SWIG_arg = 0;
  float *arg1 ;
  int result;
  
  SWIG_check_num_args("MatIsIdentity",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MatIsIdentity",1,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("MatIsIdentity",1,SWIGTYPE_p_float);
  }
  
  result = (int)MatIsIdentity(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameToEncoding(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("NameToEncoding",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NameToEncoding",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("NameToEncoding",2,"EncMap *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("NameToEncoding",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("NameToEncoding",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("NameToEncoding",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)NameToEncoding(arg1,arg2,(char const *)arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlyphHashFree(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("GlyphHashFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GlyphHashFree",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("GlyphHashFree",1,SWIGTYPE_p_splinefont);
  }
  
  GlyphHashFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFHashGlyph(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SFHashGlyph",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFHashGlyph",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFHashGlyph",2,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFHashGlyph",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFHashGlyph",2,SWIGTYPE_p_splinechar);
  }
  
  SFHashGlyph(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFHashName(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SFHashName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFHashName",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFHashName",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFHashName",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (SplineChar *)SFHashName(arg1,(char const *)arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindGID(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SFFindGID",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindGID",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFFindGID",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFFindGID",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindGID",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)SFFindGID(arg1,arg2,(char const *)arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindSlot(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SFFindSlot",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindSlot",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFFindSlot",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFFindSlot",3,"int");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SFFindSlot",4,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindSlot",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFFindSlot",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (int)SFFindSlot(arg1,arg2,arg3,(char const *)arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFCIDFindCID(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SFCIDFindCID",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFCIDFindCID",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFCIDFindCID",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFCIDFindCID",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFCIDFindCID",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)SFCIDFindCID(arg1,arg2,(char const *)arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGetChar(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SFGetChar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGetChar",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFGetChar",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFGetChar",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGetChar",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (SplineChar *)SFGetChar(arg1,arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFHasChar(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SFHasChar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFHasChar",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFHasChar",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFHasChar",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFHasChar",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)SFHasChar(arg1,arg2,(char const *)arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGetOrMakeChar(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SFGetOrMakeChar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGetOrMakeChar",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFGetOrMakeChar",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFGetOrMakeChar",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGetOrMakeChar",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (SplineChar *)SFGetOrMakeChar(arg1,arg2,(char const *)arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindExistingSlot(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SFFindExistingSlot",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindExistingSlot",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFFindExistingSlot",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFFindExistingSlot",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindExistingSlot",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)SFFindExistingSlot(arg1,arg2,(char const *)arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFCIDFindExistingChar(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SFCIDFindExistingChar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFCIDFindExistingChar",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFCIDFindExistingChar",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFCIDFindExistingChar",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFCIDFindExistingChar",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)SFCIDFindExistingChar(arg1,arg2,(char const *)arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFHasCID(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("SFHasCID",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFHasCID",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFHasCID",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFHasCID",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)SFHasCID(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getPfaEditDir(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("getPfaEditDir",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("getPfaEditDir",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)getPfaEditDir(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__DoAutoSaves(lua_State* L) {
  int SWIG_arg = 0;
  struct fontviewbase *arg1 = (struct fontviewbase *) 0 ;
  
  SWIG_check_num_args("_DoAutoSaves",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_DoAutoSaves",1,"struct fontviewbase *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_fontviewbase,0))){
    SWIG_fail_ptr("_DoAutoSaves",1,SWIGTYPE_p_fontviewbase);
  }
  
  _DoAutoSaves(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CleanAutoRecovery(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("CleanAutoRecovery",0,0)
  CleanAutoRecovery();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DoAutoRecovery(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int result;
  
  SWIG_check_num_args("DoAutoRecovery",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("DoAutoRecovery",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (int)DoAutoRecovery(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRecoverFile(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int *arg3 = (int *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("SFRecoverFile",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("SFRecoverFile",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFRecoverFile",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFRecoverFile",3,"int *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SFRecoverFile",3,SWIGTYPE_p_int);
  }
  
  result = (SplineFont *)SFRecoverFile(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFAutoSave(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  
  SWIG_check_num_args("SFAutoSave",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFAutoSave",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFAutoSave",2,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFAutoSave",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFAutoSave",2,SWIGTYPE_p_encmap);
  }
  
  SFAutoSave(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFClearAutoSave(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFClearAutoSave",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFClearAutoSave",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFClearAutoSave",1,SWIGTYPE_p_splinefont);
  }
  
  SFClearAutoSave(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSCharsFree(lua_State* L) {
  int SWIG_arg = 0;
  struct pschars *arg1 = (struct pschars *) 0 ;
  
  SWIG_check_num_args("PSCharsFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSCharsFree",1,"struct pschars *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pschars,0))){
    SWIG_fail_ptr("PSCharsFree",1,SWIGTYPE_p_pschars);
  }
  
  PSCharsFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSDictFree(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  
  SWIG_check_num_args("PSDictFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSDictFree",1,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictFree",1,SWIGTYPE_p_psdict);
  }
  
  PSDictFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSDictCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  struct psdict *result = 0 ;
  
  SWIG_check_num_args("PSDictCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSDictCopy",1,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictCopy",1,SWIGTYPE_p_psdict);
  }
  
  result = (struct psdict *)PSDictCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_psdict,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSDictFindEntry(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("PSDictFindEntry",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSDictFindEntry",1,"struct psdict *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PSDictFindEntry",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictFindEntry",1,SWIGTYPE_p_psdict);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)PSDictFindEntry(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSDictHasEntry(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("PSDictHasEntry",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSDictHasEntry",1,"struct psdict *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PSDictHasEntry",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictHasEntry",1,SWIGTYPE_p_psdict);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (char *)PSDictHasEntry(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSDictSame(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  struct psdict *arg2 = (struct psdict *) 0 ;
  int result;
  
  SWIG_check_num_args("PSDictSame",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSDictSame",1,"struct psdict *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PSDictSame",2,"struct psdict *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictSame",1,SWIGTYPE_p_psdict);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictSame",2,SWIGTYPE_p_psdict);
  }
  
  result = (int)PSDictSame(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSDictRemoveEntry(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("PSDictRemoveEntry",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSDictRemoveEntry",1,"struct psdict *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PSDictRemoveEntry",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictRemoveEntry",1,SWIGTYPE_p_psdict);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)PSDictRemoveEntry(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PSDictChangeEntry(lua_State* L) {
  int SWIG_arg = 0;
  struct psdict *arg1 = (struct psdict *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("PSDictChangeEntry",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PSDictChangeEntry",1,"struct psdict *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("PSDictChangeEntry",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("PSDictChangeEntry",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("PSDictChangeEntry",1,SWIGTYPE_p_psdict);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)PSDictChangeEntry(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFPrivateGuess(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  struct psdict *arg3 = (struct psdict *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("SFPrivateGuess",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFPrivateGuess",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFPrivateGuess",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFPrivateGuess",3,"struct psdict *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SFPrivateGuess",4,"char *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SFPrivateGuess",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFPrivateGuess",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_psdict,0))){
    SWIG_fail_ptr("SFPrivateGuess",3,SWIGTYPE_p_psdict);
  }
  
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)SFPrivateGuess(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveLayer(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFRemoveLayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveLayer",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFRemoveLayer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveLayer",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFRemoveLayer(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFAddLayer(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("SFAddLayer",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFAddLayer",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFAddLayer",2,"char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFAddLayer",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFAddLayer",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFAddLayer",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SFAddLayer(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFLayerSetBackground(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("SFLayerSetBackground",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFLayerSetBackground",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFLayerSetBackground",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFLayerSetBackground",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFLayerSetBackground",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  SFLayerSetBackground(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsRound2Int(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  float arg2 ;
  int arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("SplineSetsRound2Int",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsRound2Int",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineSetsRound2Int",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineSetsRound2Int",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineSetsRound2Int",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsRound2Int",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SplineSetsRound2Int(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCRound2Int(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  float arg3 ;
  
  SWIG_check_num_args("SCRound2Int",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCRound2Int",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCRound2Int",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCRound2Int",3,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCRound2Int",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  SCRound2Int(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCRoundToCluster(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  double arg4 ;
  double arg5 ;
  int result;
  
  SWIG_check_num_args("SCRoundToCluster",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCRoundToCluster",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCRoundToCluster",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCRoundToCluster",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCRoundToCluster",4,"double");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCRoundToCluster",5,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCRoundToCluster",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (double)lua_tonumber(L, 4);
  arg5 = (double)lua_tonumber(L, 5);
  result = (int)SCRoundToCluster(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSetsRemoveAnnoyingExtrema(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  double arg2 ;
  int result;
  
  SWIG_check_num_args("SplineSetsRemoveAnnoyingExtrema",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSetsRemoveAnnoyingExtrema",1,"SplineSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineSetsRemoveAnnoyingExtrema",2,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSetsRemoveAnnoyingExtrema",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (double)lua_tonumber(L, 2);
  result = (int)SplineSetsRemoveAnnoyingExtrema(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hascomposing(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  int result;
  
  SWIG_check_num_args("hascomposing",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("hascomposing",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("hascomposing",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("hascomposing",3,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("hascomposing",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("hascomposing",3,SWIGTYPE_p_splinechar);
  }
  
  result = (int)hascomposing(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CIDFromName(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  int result;
  
  SWIG_check_num_args("CIDFromName",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("CIDFromName",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CIDFromName",2,"SplineFont *");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CIDFromName",2,SWIGTYPE_p_splinefont);
  }
  
  result = (int)CIDFromName(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CID2Uni(lua_State* L) {
  int SWIG_arg = 0;
  struct cidmap *arg1 = (struct cidmap *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("CID2Uni",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CID2Uni",1,"struct cidmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CID2Uni",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_cidmap,0))){
    SWIG_fail_ptr("CID2Uni",1,SWIGTYPE_p_cidmap);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)CID2Uni(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CID2NameUni(lua_State* L) {
  int SWIG_arg = 0;
  struct cidmap *arg1 = (struct cidmap *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("CID2NameUni",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CID2NameUni",1,"struct cidmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CID2NameUni",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("CID2NameUni",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("CID2NameUni",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_cidmap,0))){
    SWIG_fail_ptr("CID2NameUni",1,SWIGTYPE_p_cidmap);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)CID2NameUni(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameUni2CID(lua_State* L) {
  int SWIG_arg = 0;
  struct cidmap *arg1 = (struct cidmap *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("NameUni2CID",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NameUni2CID",1,"struct cidmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("NameUni2CID",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("NameUni2CID",3,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_cidmap,0))){
    SWIG_fail_ptr("NameUni2CID",1,SWIGTYPE_p_cidmap);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (int)NameUni2CID(arg1,arg2,(char const *)arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CIDSetAltUnis(lua_State* L) {
  int SWIG_arg = 0;
  struct cidmap *arg1 = (struct cidmap *) 0 ;
  int arg2 ;
  struct altuni *result = 0 ;
  
  SWIG_check_num_args("CIDSetAltUnis",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CIDSetAltUnis",1,"struct cidmap *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("CIDSetAltUnis",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_cidmap,0))){
    SWIG_fail_ptr("CIDSetAltUnis",1,SWIGTYPE_p_cidmap);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (struct altuni *)CIDSetAltUnis(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_altuni,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MaxCID(lua_State* L) {
  int SWIG_arg = 0;
  struct cidmap *arg1 = (struct cidmap *) 0 ;
  int result;
  
  SWIG_check_num_args("MaxCID",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MaxCID",1,"struct cidmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_cidmap,0))){
    SWIG_fail_ptr("MaxCID",1,SWIGTYPE_p_cidmap);
  }
  
  result = (int)MaxCID(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadMapFromFile(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  struct cidmap *result = 0 ;
  
  SWIG_check_num_args("LoadMapFromFile",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("LoadMapFromFile",1,"char *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("LoadMapFromFile",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("LoadMapFromFile",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("LoadMapFromFile",4,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (struct cidmap *)LoadMapFromFile(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_cidmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindCidMap(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  SplineFont *arg4 = (SplineFont *) 0 ;
  struct cidmap *result = 0 ;
  
  SWIG_check_num_args("FindCidMap",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("FindCidMap",1,"char *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("FindCidMap",2,"char *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FindCidMap",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("FindCidMap",4,"SplineFont *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FindCidMap",4,SWIGTYPE_p_splinefont);
  }
  
  result = (struct cidmap *)FindCidMap(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_cidmap,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFEncodeToMap(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct cidmap *arg2 = (struct cidmap *) 0 ;
  
  SWIG_check_num_args("SFEncodeToMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFEncodeToMap",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFEncodeToMap",2,"struct cidmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFEncodeToMap",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_cidmap,0))){
    SWIG_fail_ptr("SFEncodeToMap",2,SWIGTYPE_p_cidmap);
  }
  
  SFEncodeToMap(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CIDFlatten(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar **arg2 = (SplineChar **) 0 ;
  int arg3 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("CIDFlatten",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CIDFlatten",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CIDFlatten",2,"SplineChar **");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("CIDFlatten",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CIDFlatten",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_splinechar,0))){
    SWIG_fail_ptr("CIDFlatten",2,SWIGTYPE_p_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (SplineFont *)CIDFlatten(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFlatten(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFFlatten",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFlatten",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFlatten",1,SWIGTYPE_p_splinefont);
  }
  
  SFFlatten(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFlattenByCMap(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("SFFlattenByCMap",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFlattenByCMap",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFFlattenByCMap",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFlattenByCMap",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (int)SFFlattenByCMap(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MakeCIDMaster(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  struct cidmap *arg5 = (struct cidmap *) 0 ;
  SplineFont *result = 0 ;
  
  SWIG_check_num_args("MakeCIDMaster",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MakeCIDMaster",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MakeCIDMaster",2,"EncMap *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("MakeCIDMaster",3,"int");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("MakeCIDMaster",4,"char *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("MakeCIDMaster",5,"struct cidmap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("MakeCIDMaster",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("MakeCIDMaster",2,SWIGTYPE_p_encmap);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_cidmap,0))){
    SWIG_fail_ptr("MakeCIDMaster",5,SWIGTYPE_p_cidmap);
  }
  
  result = (SplineFont *)MakeCIDMaster(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinefont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getushort(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int result;
  
  SWIG_check_num_args("getushort",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getushort",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("getushort",1,SWIGTYPE_p_FILE);
  }
  
  result = (int)getushort(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getlong(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int32 result;
  
  SWIG_check_num_args("getlong",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getlong",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("getlong",1,SWIGTYPE_p_FILE);
  }
  
  result = (int32)getlong(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_get3byte(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int result;
  
  SWIG_check_num_args("get3byte",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("get3byte",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("get3byte",1,SWIGTYPE_p_FILE);
  }
  
  result = (int)get3byte(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_getfixed(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  float result;
  
  SWIG_check_num_args("getfixed",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("getfixed",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("getfixed",1,SWIGTYPE_p_FILE);
  }
  
  result = (float)getfixed(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_get2dot14(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  float result;
  
  SWIG_check_num_args("get2dot14",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("get2dot14",1,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("get2dot14",1,SWIGTYPE_p_FILE);
  }
  
  result = (float)get2dot14(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_putshort(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("putshort",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("putshort",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("putshort",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("putshort",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  putshort(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_putlong(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("putlong",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("putlong",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("putlong",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("putlong",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  putlong(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_putfixed(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("putfixed",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("putfixed",1,"FILE *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("putfixed",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("putfixed",1,SWIGTYPE_p_FILE);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  putfixed(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttfcopyfile(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("ttfcopyfile",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttfcopyfile",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ttfcopyfile",2,"FILE *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ttfcopyfile",3,"int");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("ttfcopyfile",4,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("ttfcopyfile",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("ttfcopyfile",2,SWIGTYPE_p_FILE);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  result = (int)ttfcopyfile(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCCopyLayerToLayer(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("SCCopyLayerToLayer",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCCopyLayerToLayer",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCCopyLayerToLayer",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCCopyLayerToLayer",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCCopyLayerToLayer",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCCopyLayerToLayer",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SCCopyLayerToLayer(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hasFreeType(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("hasFreeType",0,0)
  result = (int)hasFreeType();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hasFreeTypeDebugger(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("hasFreeTypeDebugger",0,0)
  result = (int)hasFreeTypeDebugger();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hasFreeTypeByteCode(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("hasFreeTypeByteCode",0,0)
  result = (int)hasFreeTypeByteCode();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeTypeAtLeast(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("FreeTypeAtLeast",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("FreeTypeAtLeast",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FreeTypeAtLeast",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FreeTypeAtLeast",3,"int");
  arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)FreeTypeAtLeast(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeTypeStringVersion(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("FreeTypeStringVersion",0,0)
  result = (char *)FreeTypeStringVersion();
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_doneFreeType(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("doneFreeType",0,0)
  doneFreeType();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__FreeTypeFontContext(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  struct fontviewbase *arg3 = (struct fontviewbase *) 0 ;
  int arg4 ;
  enum fontformat arg5 ;
  int arg6 ;
  void *arg7 = (void *) 0 ;
  void *result = 0 ;
  
  SWIG_check_num_args("_FreeTypeFontContext",7,7)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_FreeTypeFontContext",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_FreeTypeFontContext",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("_FreeTypeFontContext",3,"struct fontviewbase *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("_FreeTypeFontContext",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("_FreeTypeFontContext",5,"enum fontformat");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("_FreeTypeFontContext",6,"int");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("_FreeTypeFontContext",7,"void *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("_FreeTypeFontContext",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_FreeTypeFontContext",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_fontviewbase,0))){
    SWIG_fail_ptr("_FreeTypeFontContext",3,SWIGTYPE_p_fontviewbase);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (enum fontformat)(int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  arg7=(void *)SWIG_MustGetPtr(L,7,0,0,7,"_FreeTypeFontContext");
  result = (void *)_FreeTypeFontContext(arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeTypeFontContext(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  struct fontviewbase *arg3 = (struct fontviewbase *) 0 ;
  int arg4 ;
  void *result = 0 ;
  
  SWIG_check_num_args("FreeTypeFontContext",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FreeTypeFontContext",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FreeTypeFontContext",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FreeTypeFontContext",3,"struct fontviewbase *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("FreeTypeFontContext",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FreeTypeFontContext",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("FreeTypeFontContext",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_fontviewbase,0))){
    SWIG_fail_ptr("FreeTypeFontContext",3,SWIGTYPE_p_fontviewbase);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  result = (void *)FreeTypeFontContext(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_void,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontFreeTypeRasterize(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  int arg3 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontFreeTypeRasterize",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontFreeTypeRasterize",1,"void *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontFreeTypeRasterize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFontFreeTypeRasterize",3,"int");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"SplineFontFreeTypeRasterize");
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (BDFFont *)SplineFontFreeTypeRasterize(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharFreeTypeRasterize(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharFreeTypeRasterize",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharFreeTypeRasterize",1,"void *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharFreeTypeRasterize",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineCharFreeTypeRasterize",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineCharFreeTypeRasterize",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplineCharFreeTypeRasterize",5,"int");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"SplineCharFreeTypeRasterize");
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (BDFChar *)SplineCharFreeTypeRasterize(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeTypeFreeContext(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  
  SWIG_check_num_args("FreeTypeFreeContext",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FreeTypeFreeContext",1,"void *");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"FreeTypeFreeContext");
  FreeTypeFreeContext(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeType_GridFitChar(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  float arg3 ;
  float arg4 ;
  int arg5 ;
  uint16 *arg6 = (uint16 *) 0 ;
  SplineChar *arg7 = (SplineChar *) 0 ;
  int arg8 ;
  int arg9 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("FreeType_GridFitChar",9,9)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FreeType_GridFitChar",1,"void *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FreeType_GridFitChar",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FreeType_GridFitChar",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("FreeType_GridFitChar",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("FreeType_GridFitChar",5,"int");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("FreeType_GridFitChar",6,"uint16 *");
  if(!SWIG_isptrtype(L,7)) SWIG_fail_arg("FreeType_GridFitChar",7,"SplineChar *");
  if(!lua_isnumber(L,8)) SWIG_fail_arg("FreeType_GridFitChar",8,"int");
  if(!lua_isnumber(L,9)) SWIG_fail_arg("FreeType_GridFitChar",9,"int");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"FreeType_GridFitChar");
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("FreeType_GridFitChar",6,SWIGTYPE_p_unsigned_short);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,7,(void**)&arg7,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("FreeType_GridFitChar",7,SWIGTYPE_p_splinechar);
  }
  
  arg8 = (int)lua_tonumber(L, 8);
  arg9 = (int)lua_tonumber(L, 9);
  result = (SplineSet *)FreeType_GridFitChar(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeType_GetRaster(lua_State* L) {
  int SWIG_arg = 0;
  void *arg1 = (void *) 0 ;
  int arg2 ;
  float arg3 ;
  float arg4 ;
  int arg5 ;
  int arg6 ;
  struct freetype_raster *result = 0 ;
  
  SWIG_check_num_args("FreeType_GetRaster",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FreeType_GetRaster",1,"void *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FreeType_GetRaster",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FreeType_GetRaster",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("FreeType_GetRaster",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("FreeType_GetRaster",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("FreeType_GetRaster",6,"int");
  arg1=(void *)SWIG_MustGetPtr(L,1,0,0,1,"FreeType_GetRaster");
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (struct freetype_raster *)FreeType_GetRaster(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_freetype_raster,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharFreeTypeRasterizeNoHints(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  BDFChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharFreeTypeRasterizeNoHints",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharFreeTypeRasterizeNoHints",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharFreeTypeRasterizeNoHints",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineCharFreeTypeRasterizeNoHints",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineCharFreeTypeRasterizeNoHints",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SplineCharFreeTypeRasterizeNoHints",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharFreeTypeRasterizeNoHints",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  result = (BDFChar *)SplineCharFreeTypeRasterizeNoHints(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdfchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineFontFreeTypeRasterizeNoHints(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  int arg4 ;
  BDFFont *result = 0 ;
  
  SWIG_check_num_args("SplineFontFreeTypeRasterizeNoHints",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineFontFreeTypeRasterizeNoHints",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineFontFreeTypeRasterizeNoHints",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SplineFontFreeTypeRasterizeNoHints",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SplineFontFreeTypeRasterizeNoHints",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SplineFontFreeTypeRasterizeNoHints",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (BDFFont *)SplineFontFreeTypeRasterizeNoHints(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_bdffont,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FreeType_FreeRaster(lua_State* L) {
  int SWIG_arg = 0;
  struct freetype_raster *arg1 = (struct freetype_raster *) 0 ;
  
  SWIG_check_num_args("FreeType_FreeRaster",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FreeType_FreeRaster",1,"struct freetype_raster *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_freetype_raster,0))){
    SWIG_fail_ptr("FreeType_FreeRaster",1,SWIGTYPE_p_freetype_raster);
  }
  
  FreeType_FreeRaster(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UniFromName(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  enum uni_interp arg2 ;
  Encoding *arg3 = (Encoding *) 0 ;
  int result;
  
  SWIG_check_num_args("UniFromName",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("UniFromName",1,"char const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("UniFromName",2,"enum uni_interp");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("UniFromName",3,"Encoding *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (enum uni_interp)(int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("UniFromName",3,SWIGTYPE_p_enc);
  }
  
  result = (int)UniFromName((char const *)arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_StdGlyphName(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  enum uni_interp arg3 ;
  NameList *arg4 = (NameList *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("StdGlyphName",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("StdGlyphName",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("StdGlyphName",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("StdGlyphName",3,"enum uni_interp");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("StdGlyphName",4,"NameList *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (enum uni_interp)(int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("StdGlyphName",4,SWIGTYPE_p_namelist);
  }
  
  result = (char *)StdGlyphName(arg1,arg2,arg3,arg4);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AllGlyphNames(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  NameList *arg2 = (NameList *) 0 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("AllGlyphNames",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("AllGlyphNames",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AllGlyphNames",2,"NameList *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("AllGlyphNames",3,"SplineChar *");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("AllGlyphNames",2,SWIGTYPE_p_namelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("AllGlyphNames",3,SWIGTYPE_p_splinechar);
  }
  
  result = (char **)AllGlyphNames(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AllNamelistNames(lua_State* L) {
  int SWIG_arg = 0;
  char **result = 0 ;
  
  SWIG_check_num_args("AllNamelistNames",0,0)
  result = (char **)AllNamelistNames();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DefaultNameListForNewFonts(lua_State* L) {
  int SWIG_arg = 0;
  NameList *result = 0 ;
  
  SWIG_check_num_args("DefaultNameListForNewFonts",0,0)
  result = (NameList *)DefaultNameListForNewFonts();
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_namelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameListByName(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  NameList *result = 0 ;
  
  SWIG_check_num_args("NameListByName",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("NameListByName",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (NameList *)NameListByName(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_namelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadNamelist(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  NameList *result = 0 ;
  
  SWIG_check_num_args("LoadNamelist",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("LoadNamelist",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (NameList *)LoadNamelist(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_namelist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LoadNamelistDir(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("LoadNamelistDir",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("LoadNamelistDir",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  LoadNamelistDir(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RenameGlyphToNamelist(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  NameList *arg3 = (NameList *) 0 ;
  NameList *arg4 = (NameList *) 0 ;
  char **arg5 = (char **) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("RenameGlyphToNamelist",5,5)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("RenameGlyphToNamelist",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RenameGlyphToNamelist",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("RenameGlyphToNamelist",3,"NameList *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("RenameGlyphToNamelist",4,"NameList *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("RenameGlyphToNamelist",5,"char **");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("RenameGlyphToNamelist",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("RenameGlyphToNamelist",3,SWIGTYPE_p_namelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("RenameGlyphToNamelist",4,SWIGTYPE_p_namelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("RenameGlyphToNamelist",5,SWIGTYPE_p_p_char);
  }
  
  result = (char *)RenameGlyphToNamelist(arg1,arg2,arg3,arg4,arg5);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRenameGlyphsToNamelist(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  NameList *arg2 = (NameList *) 0 ;
  
  SWIG_check_num_args("SFRenameGlyphsToNamelist",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRenameGlyphsToNamelist",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFRenameGlyphsToNamelist",2,"NameList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRenameGlyphsToNamelist",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("SFRenameGlyphsToNamelist",2,SWIGTYPE_p_namelist);
  }
  
  SFRenameGlyphsToNamelist(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFTemporaryRenameGlyphsToNamelist(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  NameList *arg2 = (NameList *) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("SFTemporaryRenameGlyphsToNamelist",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFTemporaryRenameGlyphsToNamelist",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFTemporaryRenameGlyphsToNamelist",2,"NameList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFTemporaryRenameGlyphsToNamelist",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_namelist,0))){
    SWIG_fail_ptr("SFTemporaryRenameGlyphsToNamelist",2,SWIGTYPE_p_namelist);
  }
  
  result = (char **)SFTemporaryRenameGlyphsToNamelist(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFTemporaryRestoreGlyphNames(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char **arg2 = (char **) 0 ;
  
  SWIG_check_num_args("SFTemporaryRestoreGlyphNames",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFTemporaryRestoreGlyphNames",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFTemporaryRestoreGlyphNames",2,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFTemporaryRestoreGlyphNames",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("SFTemporaryRestoreGlyphNames",2,SWIGTYPE_p_p_char);
  }
  
  SFTemporaryRestoreGlyphNames(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_doversion(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("doversion",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("doversion",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  doversion((char const *)arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSTtfNumberPoints(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SSTtfNumberPoints",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSTtfNumberPoints",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSTtfNumberPoints",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SSTtfNumberPoints(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCNumberPoints(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("SCNumberPoints",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCNumberPoints",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCNumberPoints",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCNumberPoints",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)SCNumberPoints(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCPointsNumberedProperly(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("SCPointsNumberedProperly",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCPointsNumberedProperly",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCPointsNumberedProperly",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCPointsNumberedProperly",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)SCPointsNumberedProperly(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ttfFindPointInSC(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  BasePoint *arg4 = (BasePoint *) 0 ;
  RefChar *arg5 = (RefChar *) 0 ;
  int result;
  
  SWIG_check_num_args("ttfFindPointInSC",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ttfFindPointInSC",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ttfFindPointInSC",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ttfFindPointInSC",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("ttfFindPointInSC",4,"BasePoint *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("ttfFindPointInSC",5,"RefChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ttfFindPointInSC",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("ttfFindPointInSC",4,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("ttfFindPointInSC",5,SWIGTYPE_p_refchar);
  }
  
  result = (int)ttfFindPointInSC(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFigureDefWidth(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int *arg2 = (int *) 0 ;
  int result;
  
  SWIG_check_num_args("SFFigureDefWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFigureDefWidth",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFFigureDefWidth",2,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFigureDefWidth",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SFFigureDefWidth",2,SWIGTYPE_p_int);
  }
  
  result = (int)SFFigureDefWidth(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ClassesMatch(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char **arg2 = (char **) 0 ;
  int arg3 ;
  char **arg4 = (char **) 0 ;
  int result;
  
  SWIG_check_num_args("ClassesMatch",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ClassesMatch",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ClassesMatch",2,"char **");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ClassesMatch",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("ClassesMatch",4,"char **");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("ClassesMatch",2,SWIGTYPE_p_p_char);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("ClassesMatch",4,SWIGTYPE_p_p_char);
  }
  
  result = (int)ClassesMatch(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTGlyphToClass(lua_State* L) {
  int SWIG_arg = 0;
  FPST *arg1 = (FPST *) 0 ;
  FPST *result = 0 ;
  
  SWIG_check_num_args("FPSTGlyphToClass",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTGlyphToClass",1,"FPST *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPSTGlyphToClass",1,SWIGTYPE_p_generic_fpst);
  }
  
  result = (FPST *)FPSTGlyphToClass(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_fpst,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASMFromOpenTypeForms(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 arg2 ;
  ASM *result = 0 ;
  
  SWIG_check_num_args("ASMFromOpenTypeForms",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASMFromOpenTypeForms",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("ASMFromOpenTypeForms",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ASMFromOpenTypeForms",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  result = (ASM *)ASMFromOpenTypeForms(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_asm,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ASMFromFPST(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  FPST *arg2 = (FPST *) 0 ;
  int arg3 ;
  ASM *result = 0 ;
  
  SWIG_check_num_args("ASMFromFPST",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ASMFromFPST",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ASMFromFPST",2,"FPST *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ASMFromFPST",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ASMFromFPST",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("ASMFromFPST",2,SWIGTYPE_p_generic_fpst);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (ASM *)ASMFromFPST(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_generic_asm,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_utf8_verify_copy(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("utf8_verify_copy",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("utf8_verify_copy",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)utf8_verify_copy((char const *)arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacStrToUtf8(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MacStrToUtf8",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("MacStrToUtf8",1,"char const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MacStrToUtf8",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("MacStrToUtf8",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (char *)MacStrToUtf8((char const *)arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Utf8ToMacStr(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int arg3 ;
  char *result = 0 ;
  
  SWIG_check_num_args("Utf8ToMacStr",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("Utf8ToMacStr",1,"char const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("Utf8ToMacStr",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("Utf8ToMacStr",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (char *)Utf8ToMacStr((char const *)arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacEncFromMacLang(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  uint8 result;
  
  SWIG_check_num_args("MacEncFromMacLang",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("MacEncFromMacLang",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (uint8)MacEncFromMacLang(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WinLangFromMac(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  uint16 result;
  
  SWIG_check_num_args("WinLangFromMac",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("WinLangFromMac",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (uint16)WinLangFromMac(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_WinLangToMac(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  uint16 result;
  
  SWIG_check_num_args("WinLangToMac",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("WinLangToMac",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (uint16)WinLangToMac(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CanEncodingWinLangAsMac(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int result;
  
  SWIG_check_num_args("CanEncodingWinLangAsMac",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("CanEncodingWinLangAsMac",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (int)CanEncodingWinLangAsMac(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacEncToUnicode(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  int arg2 ;
  int32 *result = 0 ;
  
  SWIG_check_num_args("MacEncToUnicode",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("MacEncToUnicode",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MacEncToUnicode",2,"int");
  arg1 = (int)lua_tonumber(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (int32 *)MacEncToUnicode(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacLangFromLocale(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("MacLangFromLocale",0,0)
  result = (int)MacLangFromLocale();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MacLanguageFromCode(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MacLanguageFromCode",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("MacLanguageFromCode",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (char *)MacLanguageFromCode(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindEnglishNameInMacName(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("FindEnglishNameInMacName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FindEnglishNameInMacName",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("FindEnglishNameInMacName",1,SWIGTYPE_p_macname);
  }
  
  result = (char *)FindEnglishNameInMacName(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PickNameFromMacName(lua_State* L) {
  int SWIG_arg = 0;
  struct macname *arg1 = (struct macname *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("PickNameFromMacName",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PickNameFromMacName",1,"struct macname *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macname,0))){
    SWIG_fail_ptr("PickNameFromMacName",1,SWIGTYPE_p_macname);
  }
  
  result = (char *)PickNameFromMacName(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindMacFeature(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  MacFeat **arg3 = (MacFeat **) 0 ;
  MacFeat *result = 0 ;
  
  SWIG_check_num_args("FindMacFeature",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FindMacFeature",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FindMacFeature",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FindMacFeature",3,"MacFeat **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FindMacFeature",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_macfeat,0))){
    SWIG_fail_ptr("FindMacFeature",3,SWIGTYPE_p_p_macfeat);
  }
  
  result = (MacFeat *)FindMacFeature(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macfeat,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindMacSetting(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  struct macsetting **arg4 = (struct macsetting **) 0 ;
  struct macsetting *result = 0 ;
  
  SWIG_check_num_args("FindMacSetting",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FindMacSetting",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FindMacSetting",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FindMacSetting",3,"int");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("FindMacSetting",4,"struct macsetting **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FindMacSetting",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_p_macsetting,0))){
    SWIG_fail_ptr("FindMacSetting",4,SWIGTYPE_p_p_macsetting);
  }
  
  result = (struct macsetting *)FindMacSetting(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macsetting,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindMacSettingName(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  struct macname *result = 0 ;
  
  SWIG_check_num_args("FindMacSettingName",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FindMacSettingName",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FindMacSettingName",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FindMacSettingName",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FindMacSettingName",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (struct macname *)FindMacSettingName(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macname,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_UniFromEnc(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  Encoding *arg2 = (Encoding *) 0 ;
  int32 result;
  
  SWIG_check_num_args("UniFromEnc",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("UniFromEnc",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("UniFromEnc",2,"Encoding *");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("UniFromEnc",2,SWIGTYPE_p_enc);
  }
  
  result = (int32)UniFromEnc(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncFromUni(lua_State* L) {
  int SWIG_arg = 0;
  int32 arg1 ;
  Encoding *arg2 = (Encoding *) 0 ;
  int32 result;
  
  SWIG_check_num_args("EncFromUni",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("EncFromUni",1,"int32");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("EncFromUni",2,"Encoding *");
  arg1 = (int32)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("EncFromUni",2,SWIGTYPE_p_enc);
  }
  
  result = (int32)EncFromUni(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EncFromName(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  enum uni_interp arg2 ;
  Encoding *arg3 = (Encoding *) 0 ;
  int32 result;
  
  SWIG_check_num_args("EncFromName",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("EncFromName",1,"char const *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("EncFromName",2,"enum uni_interp");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("EncFromName",3,"Encoding *");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (enum uni_interp)(int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("EncFromName",3,SWIGTYPE_p_enc);
  }
  
  result = (int32)EncFromName((char const *)arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MatInverse(lua_State* L) {
  int SWIG_arg = 0;
  float *arg1 ;
  float *arg2 ;
  
  SWIG_check_num_args("MatInverse",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MatInverse",1,"float [6]");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MatInverse",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("MatInverse",1,SWIGTYPE_p_float);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("MatInverse",2,SWIGTYPE_p_float);
  }
  
  MatInverse(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BpColinear(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("BpColinear",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BpColinear",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BpColinear",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BpColinear",3,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpColinear",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpColinear",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpColinear",3,SWIGTYPE_p_basepoint);
  }
  
  result = (int)BpColinear(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BpWithin(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  BasePoint *arg3 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("BpWithin",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BpWithin",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BpWithin",2,"BasePoint *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BpWithin",3,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpWithin",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpWithin",2,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BpWithin",3,SWIGTYPE_p_basepoint);
  }
  
  result = (int)BpWithin(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMAxisAbrev(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MMAxisAbrev",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("MMAxisAbrev",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)MMAxisAbrev(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMMakeMasterFontname(lua_State* L) {
  int SWIG_arg = 0;
  MMSet *arg1 = (MMSet *) 0 ;
  int arg2 ;
  char **arg3 = (char **) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MMMakeMasterFontname",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMMakeMasterFontname",1,"MMSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMMakeMasterFontname",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("MMMakeMasterFontname",3,"char **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMMakeMasterFontname",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("MMMakeMasterFontname",3,SWIGTYPE_p_p_char);
  }
  
  result = (char *)MMMakeMasterFontname(arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMGuessWeight(lua_State* L) {
  int SWIG_arg = 0;
  MMSet *arg1 = (MMSet *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MMGuessWeight",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMGuessWeight",1,"MMSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMGuessWeight",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("MMGuessWeight",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMGuessWeight",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  result = (char *)MMGuessWeight(arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMExtractNth(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MMExtractNth",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("MMExtractNth",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMExtractNth",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (char *)MMExtractNth(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMExtractArrayNth(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MMExtractArrayNth",2,2)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("MMExtractArrayNth",1,"char *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMExtractArrayNth",2,"int");
  arg1 = (char *)lua_tostring(L, 1);
  arg2 = (int)lua_tonumber(L, 2);
  result = (char *)MMExtractArrayNth(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMValid(lua_State* L) {
  int SWIG_arg = 0;
  MMSet *arg1 = (MMSet *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("MMValid",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMValid",1,"MMSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMValid",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMValid",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)MMValid(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMKern(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  int arg4 ;
  struct lookup_subtable *arg5 = (struct lookup_subtable *) 0 ;
  KernPair *arg6 = (KernPair *) 0 ;
  
  SWIG_check_num_args("MMKern",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMKern",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MMKern",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("MMKern",3,"SplineChar *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("MMKern",4,"int");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("MMKern",5,"struct lookup_subtable *");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("MMKern",6,"KernPair *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("MMKern",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("MMKern",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("MMKern",3,SWIGTYPE_p_splinechar);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_lookup_subtable,0))){
    SWIG_fail_ptr("MMKern",5,SWIGTYPE_p_lookup_subtable);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_kernpair,0))){
    SWIG_fail_ptr("MMKern",6,SWIGTYPE_p_kernpair);
  }
  
  MMKern(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MMBlendChar(lua_State* L) {
  int SWIG_arg = 0;
  MMSet *arg1 = (MMSet *) 0 ;
  int arg2 ;
  char *result = 0 ;
  
  SWIG_check_num_args("MMBlendChar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MMBlendChar",1,"MMSet *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("MMBlendChar",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_mmset,0))){
    SWIG_fail_ptr("MMBlendChar",1,SWIGTYPE_p_mmset);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (char *)MMBlendChar(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_EnforcePostScriptName(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("EnforcePostScriptName",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("EnforcePostScriptName",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)EnforcePostScriptName(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ToAbsolute(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("ToAbsolute",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ToAbsolute",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)ToAbsolute(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BitmapCompare(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  BDFChar *arg2 = (BDFChar *) 0 ;
  int arg3 ;
  int arg4 ;
  enum Compare_Ret result;
  
  SWIG_check_num_args("BitmapCompare",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BitmapCompare",1,"BDFChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BitmapCompare",2,"BDFChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BitmapCompare",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("BitmapCompare",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BitmapCompare",1,SWIGTYPE_p_bdfchar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BitmapCompare",2,SWIGTYPE_p_bdfchar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (enum Compare_Ret)BitmapCompare(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSsCompare(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  float arg3 ;
  float arg4 ;
  SplinePoint **arg5 = (SplinePoint **) 0 ;
  enum Compare_Ret result;
  
  SWIG_check_num_args("SSsCompare",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSsCompare",1,"SplineSet const *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SSsCompare",2,"SplineSet const *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SSsCompare",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SSsCompare",4,"float");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("SSsCompare",5,"SplinePoint **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSsCompare",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSsCompare",2,SWIGTYPE_p_splinepointlist);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_p_splinepoint,0))){
    SWIG_fail_ptr("SSsCompare",5,SWIGTYPE_p_p_splinepoint);
  }
  
  result = (enum Compare_Ret)SSsCompare((struct splinepointlist const *)arg1,(struct splinepointlist const *)arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number)(int)(result)); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CompareFonts(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  EncMap *arg2 = (EncMap *) 0 ;
  SplineFont *arg3 = (SplineFont *) 0 ;
  FILE *arg4 = (FILE *) 0 ;
  int arg5 ;
  int result;
  
  SWIG_check_num_args("CompareFonts",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("CompareFonts",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CompareFonts",2,"EncMap *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("CompareFonts",3,"SplineFont *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("CompareFonts",4,"FILE *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("CompareFonts",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CompareFonts",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("CompareFonts",2,SWIGTYPE_p_encmap);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("CompareFonts",3,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("CompareFonts",4,SWIGTYPE_p_FILE);
  }
  
  arg5 = (int)lua_tonumber(L, 5);
  result = (int)CompareFonts(arg1,arg2,arg3,arg4,arg5);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayersSimilar(lua_State* L) {
  int SWIG_arg = 0;
  Layer *arg1 = (Layer *) 0 ;
  Layer *arg2 = (Layer *) 0 ;
  double arg3 ;
  int result;
  
  SWIG_check_num_args("LayersSimilar",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayersSimilar",1,"Layer *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("LayersSimilar",2,"Layer *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("LayersSimilar",3,"double");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayersSimilar",1,SWIGTYPE_p_layer);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayersSimilar",2,SWIGTYPE_p_layer);
  }
  
  arg3 = (double)lua_tonumber(L, 3);
  result = (int)LayersSimilar(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DefaultOtherSubrs(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("DefaultOtherSubrs",0,0)
  DefaultOtherSubrs();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ReadOtherSubrsFile(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("ReadOtherSubrsFile",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ReadOtherSubrsFile",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (int)ReadOtherSubrsFile(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_utf8toutf7_copy(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("utf8toutf7_copy",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("utf8toutf7_copy",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)utf8toutf7_copy((char const *)arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_utf7toutf8_copy(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("utf7toutf8_copy",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("utf7toutf8_copy",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)utf7toutf8_copy((char const *)arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSetModTime(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFSetModTime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSetModTime",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSetModTime",1,SWIGTYPE_p_splinefont);
  }
  
  SFSetModTime(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFTimesFromFile(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  FILE *arg2 = (FILE *) 0 ;
  
  SWIG_check_num_args("SFTimesFromFile",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFTimesFromFile",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFTimesFromFile",2,"FILE *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFTimesFromFile",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SFTimesFromFile",2,SWIGTYPE_p_FILE);
  }
  
  SFTimesFromFile(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFHasInstructions(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int result;
  
  SWIG_check_num_args("SFHasInstructions",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFHasInstructions",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFHasInstructions",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int)SFHasInstructions(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RefDepth(lua_State* L) {
  int SWIG_arg = 0;
  RefChar *arg1 = (RefChar *) 0 ;
  int arg2 ;
  int result;
  
  SWIG_check_num_args("RefDepth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RefDepth",1,"RefChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RefDepth",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_refchar,0))){
    SWIG_fail_ptr("RefDepth",1,SWIGTYPE_p_refchar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (int)RefDepth(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCHasSubs(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  uint32 arg2 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SCHasSubs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCHasSubs",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCHasSubs",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCHasSubs",1,SWIGTYPE_p_splinechar);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  result = (SplineChar *)SCHasSubs(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TagFullName(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 arg2 ;
  int arg3 ;
  int arg4 ;
  char *result = 0 ;
  
  SWIG_check_num_args("TagFullName",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TagFullName",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("TagFullName",2,"uint32");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("TagFullName",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("TagFullName",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("TagFullName",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (char *)TagFullName(arg1,arg2,arg3,arg4);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFScriptsInLookups(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("SFScriptsInLookups",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFScriptsInLookups",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFScriptsInLookups",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFScriptsInLookups",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (uint32 *)SFScriptsInLookups(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFLangsInScript(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  uint32 arg3 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("SFLangsInScript",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFLangsInScript",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFLangsInScript",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFLangsInScript",3,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFLangsInScript",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  result = (uint32 *)SFLangsInScript(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFeaturesInScriptLang(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  uint32 arg3 ;
  uint32 arg4 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("SFFeaturesInScriptLang",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFeaturesInScriptLang",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFFeaturesInScriptLang",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFFeaturesInScriptLang",3,"uint32");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFFeaturesInScriptLang",4,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFeaturesInScriptLang",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (uint32)lua_tonumber(L, 4);
  result = (uint32 *)SFFeaturesInScriptLang(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFLookupsInScriptLangFeature(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  uint32 arg3 ;
  uint32 arg4 ;
  uint32 arg5 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("SFLookupsInScriptLangFeature",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFLookupsInScriptLangFeature",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFLookupsInScriptLangFeature",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFLookupsInScriptLangFeature",3,"uint32");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFLookupsInScriptLangFeature",4,"uint32");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SFLookupsInScriptLangFeature",5,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFLookupsInScriptLangFeature",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (uint32)lua_tonumber(L, 4);
  SWIG_contract_assert((lua_tonumber(L,5)>=0),"number must not be negative")
  arg5 = (uint32)lua_tonumber(L, 5);
  result = (OTLookup **)SFLookupsInScriptLangFeature(arg1,arg2,arg3,arg4,arg5);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGlyphsWithPSTinSubtable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  SplineChar **result = 0 ;
  
  SWIG_check_num_args("SFGlyphsWithPSTinSubtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGlyphsWithPSTinSubtable",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFGlyphsWithPSTinSubtable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGlyphsWithPSTinSubtable",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,0))){
    SWIG_fail_ptr("SFGlyphsWithPSTinSubtable",2,SWIGTYPE_p_lookup_subtable);
  }
  
  result = (SplineChar **)SFGlyphsWithPSTinSubtable(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGlyphsWithLigatureinLookup(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  SplineChar **result = 0 ;
  
  SWIG_check_num_args("SFGlyphsWithLigatureinLookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGlyphsWithLigatureinLookup",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFGlyphsWithLigatureinLookup",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGlyphsWithLigatureinLookup",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,0))){
    SWIG_fail_ptr("SFGlyphsWithLigatureinLookup",2,SWIGTYPE_p_lookup_subtable);
  }
  
  result = (SplineChar **)SFGlyphsWithLigatureinLookup(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindUnusedLookups(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFFindUnusedLookups",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindUnusedLookups",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindUnusedLookups",1,SWIGTYPE_p_splinefont);
  }
  
  SFFindUnusedLookups(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindClearUnusedLookupBits(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFFindClearUnusedLookupBits",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindClearUnusedLookupBits",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindClearUnusedLookupBits",1,SWIGTYPE_p_splinefont);
  }
  
  SFFindClearUnusedLookupBits(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LookupUsedNested(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  int result;
  
  SWIG_check_num_args("LookupUsedNested",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LookupUsedNested",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("LookupUsedNested",2,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("LookupUsedNested",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("LookupUsedNested",2,SWIGTYPE_p_otlookup);
  }
  
  result = (int)LookupUsedNested(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveUnusedLookupSubTables(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("SFRemoveUnusedLookupSubTables",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveUnusedLookupSubTables",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFRemoveUnusedLookupSubTables",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFRemoveUnusedLookupSubTables",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveUnusedLookupSubTables",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  SFRemoveUnusedLookupSubTables(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveLookupSubTable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("SFRemoveLookupSubTable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveLookupSubTable",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFRemoveLookupSubTable",2,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveLookupSubTable",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,0))){
    SWIG_fail_ptr("SFRemoveLookupSubTable",2,SWIGTYPE_p_lookup_subtable);
  }
  
  SFRemoveLookupSubTable(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveLookup(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("SFRemoveLookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveLookup",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFRemoveLookup",2,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveLookup",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("SFRemoveLookup",2,SWIGTYPE_p_otlookup);
  }
  
  SFRemoveLookup(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindLookupSubtable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("SFFindLookupSubtable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindLookupSubtable",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFFindLookupSubtable",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindLookupSubtable",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (struct lookup_subtable *)SFFindLookupSubtable(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindLookupSubtableAndFreeName(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("SFFindLookupSubtableAndFreeName",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindLookupSubtableAndFreeName",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFFindLookupSubtableAndFreeName",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindLookupSubtableAndFreeName",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (struct lookup_subtable *)SFFindLookupSubtableAndFreeName(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFFindLookup(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  OTLookup *result = 0 ;
  
  SWIG_check_num_args("SFFindLookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFFindLookup",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFFindLookup",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFFindLookup",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (OTLookup *)SFFindLookup(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NameOTLookup(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup *arg1 = (OTLookup *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("NameOTLookup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NameOTLookup",1,"OTLookup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("NameOTLookup",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("NameOTLookup",1,SWIGTYPE_p_otlookup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("NameOTLookup",2,SWIGTYPE_p_splinefont);
  }
  
  NameOTLookup(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlyphNameCnt(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  int result;
  
  SWIG_check_num_args("GlyphNameCnt",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("GlyphNameCnt",1,"char const *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (int)GlyphNameCnt((char const *)arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_reverseGlyphNames(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("reverseGlyphNames",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("reverseGlyphNames",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  result = (char *)reverseGlyphNames(arg1);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTRule_From_Str(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  FPST *arg2 = (FPST *) 0 ;
  struct fpst_rule *arg3 = (struct fpst_rule *) 0 ;
  char *arg4 = (char *) 0 ;
  int *arg5 = (int *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("FPSTRule_From_Str",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTRule_From_Str",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPSTRule_From_Str",2,"FPST *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FPSTRule_From_Str",3,"struct fpst_rule *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("FPSTRule_From_Str",4,"char *");
  if(!SWIG_isptrtype(L,5)) SWIG_fail_arg("FPSTRule_From_Str",5,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FPSTRule_From_Str",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPSTRule_From_Str",2,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_fpst_rule,0))){
    SWIG_fail_ptr("FPSTRule_From_Str",3,SWIGTYPE_p_fpst_rule);
  }
  
  arg4 = (char *)lua_tostring(L, 4);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,5,(void**)&arg5,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("FPSTRule_From_Str",5,SWIGTYPE_p_int);
  }
  
  result = (char *)FPSTRule_From_Str(arg1,arg2,arg3,arg4,arg5);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FPSTRule_To_Str(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  FPST *arg2 = (FPST *) 0 ;
  struct fpst_rule *arg3 = (struct fpst_rule *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("FPSTRule_To_Str",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FPSTRule_To_Str",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FPSTRule_To_Str",2,"FPST *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FPSTRule_To_Str",3,"struct fpst_rule *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("FPSTRule_To_Str",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_generic_fpst,0))){
    SWIG_fail_ptr("FPSTRule_To_Str",2,SWIGTYPE_p_generic_fpst);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_fpst_rule,0))){
    SWIG_fail_ptr("FPSTRule_To_Str",3,SWIGTYPE_p_fpst_rule);
  }
  
  result = (char *)FPSTRule_To_Str(arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FListAppendScriptLang(lua_State* L) {
  int SWIG_arg = 0;
  FeatureScriptLangList *arg1 = (FeatureScriptLangList *) 0 ;
  uint32 arg2 ;
  uint32 arg3 ;
  
  SWIG_check_num_args("FListAppendScriptLang",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FListAppendScriptLang",1,"FeatureScriptLangList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FListAppendScriptLang",2,"uint32");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FListAppendScriptLang",3,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FListAppendScriptLang",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  FListAppendScriptLang(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FListsAppendScriptLang(lua_State* L) {
  int SWIG_arg = 0;
  FeatureScriptLangList *arg1 = (FeatureScriptLangList *) 0 ;
  uint32 arg2 ;
  uint32 arg3 ;
  
  SWIG_check_num_args("FListsAppendScriptLang",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FListsAppendScriptLang",1,"FeatureScriptLangList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FListsAppendScriptLang",2,"uint32");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("FListsAppendScriptLang",3,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FListsAppendScriptLang",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  FListsAppendScriptLang(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SLCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  struct scriptlanglist *result = 0 ;
  
  SWIG_check_num_args("SLCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SLCopy",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("SLCopy",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (struct scriptlanglist *)SLCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_scriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SListCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  struct scriptlanglist *result = 0 ;
  
  SWIG_check_num_args("SListCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SListCopy",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("SListCopy",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (struct scriptlanglist *)SListCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_scriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureListCopy(lua_State* L) {
  int SWIG_arg = 0;
  FeatureScriptLangList *arg1 = (FeatureScriptLangList *) 0 ;
  FeatureScriptLangList *result = 0 ;
  
  SWIG_check_num_args("FeatureListCopy",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FeatureListCopy",1,"FeatureScriptLangList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureListCopy",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (FeatureScriptLangList *)FeatureListCopy(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_featurescriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SLMerge(lua_State* L) {
  int SWIG_arg = 0;
  FeatureScriptLangList *arg1 = (FeatureScriptLangList *) 0 ;
  struct scriptlanglist *arg2 = (struct scriptlanglist *) 0 ;
  
  SWIG_check_num_args("SLMerge",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SLMerge",1,"FeatureScriptLangList *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SLMerge",2,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("SLMerge",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("SLMerge",2,SWIGTYPE_p_scriptlanglist);
  }
  
  SLMerge(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FLMerge(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup *arg1 = (OTLookup *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("FLMerge",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FLMerge",1,"OTLookup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FLMerge",2,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("FLMerge",1,SWIGTYPE_p_otlookup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("FLMerge",2,SWIGTYPE_p_otlookup);
  }
  
  FLMerge(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FLOrder(lua_State* L) {
  int SWIG_arg = 0;
  FeatureScriptLangList *arg1 = (FeatureScriptLangList *) 0 ;
  FeatureScriptLangList *result = 0 ;
  
  SWIG_check_num_args("FLOrder",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("FLOrder",1,"FeatureScriptLangList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FLOrder",1,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (FeatureScriptLangList *)FLOrder(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_featurescriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureScriptTagInFeatureScriptList(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  uint32 arg2 ;
  FeatureScriptLangList *arg3 = (FeatureScriptLangList *) 0 ;
  int result;
  
  SWIG_check_num_args("FeatureScriptTagInFeatureScriptList",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("FeatureScriptTagInFeatureScriptList",1,"uint32");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("FeatureScriptTagInFeatureScriptList",2,"uint32");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("FeatureScriptTagInFeatureScriptList",3,"FeatureScriptLangList *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureScriptTagInFeatureScriptList",3,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (int)FeatureScriptTagInFeatureScriptList(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FindFeatureTagInFeatureScriptList(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  FeatureScriptLangList *arg2 = (FeatureScriptLangList *) 0 ;
  FeatureScriptLangList *result = 0 ;
  
  SWIG_check_num_args("FindFeatureTagInFeatureScriptList",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("FindFeatureTagInFeatureScriptList",1,"uint32");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FindFeatureTagInFeatureScriptList",2,"FeatureScriptLangList *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FindFeatureTagInFeatureScriptList",2,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (FeatureScriptLangList *)FindFeatureTagInFeatureScriptList(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_featurescriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureTagInFeatureScriptList(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  FeatureScriptLangList *arg2 = (FeatureScriptLangList *) 0 ;
  int result;
  
  SWIG_check_num_args("FeatureTagInFeatureScriptList",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("FeatureTagInFeatureScriptList",1,"uint32");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FeatureTagInFeatureScriptList",2,"FeatureScriptLangList *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureTagInFeatureScriptList",2,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (int)FeatureTagInFeatureScriptList(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DefaultLangTagInOneScriptList(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  int result;
  
  SWIG_check_num_args("DefaultLangTagInOneScriptList",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DefaultLangTagInOneScriptList",1,"struct scriptlanglist *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("DefaultLangTagInOneScriptList",1,SWIGTYPE_p_scriptlanglist);
  }
  
  result = (int)DefaultLangTagInOneScriptList(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DefaultLangTagInScriptList(lua_State* L) {
  int SWIG_arg = 0;
  struct scriptlanglist *arg1 = (struct scriptlanglist *) 0 ;
  int arg2 ;
  struct scriptlanglist *result = 0 ;
  
  SWIG_check_num_args("DefaultLangTagInScriptList",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("DefaultLangTagInScriptList",1,"struct scriptlanglist *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("DefaultLangTagInScriptList",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_scriptlanglist,0))){
    SWIG_fail_ptr("DefaultLangTagInScriptList",1,SWIGTYPE_p_scriptlanglist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (struct scriptlanglist *)DefaultLangTagInScriptList(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_scriptlanglist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptInFeatureScriptList(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  FeatureScriptLangList *arg2 = (FeatureScriptLangList *) 0 ;
  int result;
  
  SWIG_check_num_args("ScriptInFeatureScriptList",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ScriptInFeatureScriptList",1,"uint32");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ScriptInFeatureScriptList",2,"FeatureScriptLangList *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("ScriptInFeatureScriptList",2,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (int)ScriptInFeatureScriptList(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__FeatureOrderId(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  uint32 arg2 ;
  int result;
  
  SWIG_check_num_args("_FeatureOrderId",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("_FeatureOrderId",1,"int");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("_FeatureOrderId",2,"uint32");
  arg1 = (int)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  result = (int)_FeatureOrderId(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_FeatureOrderId(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  FeatureScriptLangList *arg2 = (FeatureScriptLangList *) 0 ;
  int result;
  
  SWIG_check_num_args("FeatureOrderId",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("FeatureOrderId",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("FeatureOrderId",2,"FeatureScriptLangList *");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_featurescriptlanglist,0))){
    SWIG_fail_ptr("FeatureOrderId",2,SWIGTYPE_p_featurescriptlanglist);
  }
  
  result = (int)FeatureOrderId(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSubTablesMerge(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct lookup_subtable *arg2 = (struct lookup_subtable *) 0 ;
  struct lookup_subtable *arg3 = (struct lookup_subtable *) 0 ;
  
  SWIG_check_num_args("SFSubTablesMerge",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSubTablesMerge",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFSubTablesMerge",2,"struct lookup_subtable *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFSubTablesMerge",3,"struct lookup_subtable *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSubTablesMerge",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_lookup_subtable,0))){
    SWIG_fail_ptr("SFSubTablesMerge",2,SWIGTYPE_p_lookup_subtable);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_lookup_subtable,0))){
    SWIG_fail_ptr("SFSubTablesMerge",3,SWIGTYPE_p_lookup_subtable);
  }
  
  SFSubTablesMerge(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSubTableFindOrMake(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 arg2 ;
  uint32 arg3 ;
  int arg4 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("SFSubTableFindOrMake",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSubTableFindOrMake",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFSubTableFindOrMake",2,"uint32");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFSubTableFindOrMake",3,"uint32");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFSubTableFindOrMake",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSubTableFindOrMake",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (struct lookup_subtable *)SFSubTableFindOrMake(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFSubTableMake(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 arg2 ;
  uint32 arg3 ;
  int arg4 ;
  struct lookup_subtable *result = 0 ;
  
  SWIG_check_num_args("SFSubTableMake",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFSubTableMake",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFSubTableMake",2,"uint32");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFSubTableMake",3,"uint32");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFSubTableMake",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFSubTableMake",1,SWIGTYPE_p_splinefont);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (struct lookup_subtable *)SFSubTableMake(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_lookup_subtable,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookupCopyInto(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  OTLookup *arg3 = (OTLookup *) 0 ;
  OTLookup *result = 0 ;
  
  SWIG_check_num_args("OTLookupCopyInto",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookupCopyInto",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookupCopyInto",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("OTLookupCopyInto",3,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("OTLookupCopyInto",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("OTLookupCopyInto",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookupCopyInto",3,SWIGTYPE_p_otlookup);
  }
  
  result = (OTLookup *)OTLookupCopyInto(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_OTLookupsCopyInto(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  OTLookup **arg3 = (OTLookup **) 0 ;
  OTLookup *arg4 = (OTLookup *) 0 ;
  
  SWIG_check_num_args("OTLookupsCopyInto",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("OTLookupsCopyInto",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("OTLookupsCopyInto",2,"SplineFont *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("OTLookupsCopyInto",3,"OTLookup **");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("OTLookupsCopyInto",4,"OTLookup *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("OTLookupsCopyInto",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("OTLookupsCopyInto",2,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("OTLookupsCopyInto",3,SWIGTYPE_p_p_otlookup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("OTLookupsCopyInto",4,SWIGTYPE_p_otlookup);
  }
  
  OTLookupsCopyInto(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ApplyTickedFeatures(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 *arg2 = (uint32 *) 0 ;
  uint32 arg3 ;
  uint32 arg4 ;
  int arg5 ;
  SplineChar **arg6 = (SplineChar **) 0 ;
  struct opentype_str *result = 0 ;
  
  SWIG_check_num_args("ApplyTickedFeatures",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ApplyTickedFeatures",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ApplyTickedFeatures",2,"uint32 *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ApplyTickedFeatures",3,"uint32");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ApplyTickedFeatures",4,"uint32");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ApplyTickedFeatures",5,"int");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("ApplyTickedFeatures",6,"SplineChar **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ApplyTickedFeatures",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("ApplyTickedFeatures",2,SWIGTYPE_p_unsigned_int);
  }
  
  SWIG_contract_assert((lua_tonumber(L,3)>=0),"number must not be negative")
  arg3 = (uint32)lua_tonumber(L, 3);
  SWIG_contract_assert((lua_tonumber(L,4)>=0),"number must not be negative")
  arg4 = (uint32)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_p_splinechar,0))){
    SWIG_fail_ptr("ApplyTickedFeatures",6,SWIGTYPE_p_p_splinechar);
  }
  
  result = (struct opentype_str *)ApplyTickedFeatures(arg1,arg2,arg3,arg4,arg5,arg6);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_opentype_str,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VerticalKernFeature(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  OTLookup *arg2 = (OTLookup *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("VerticalKernFeature",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("VerticalKernFeature",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("VerticalKernFeature",2,"OTLookup *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("VerticalKernFeature",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("VerticalKernFeature",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("VerticalKernFeature",2,SWIGTYPE_p_otlookup);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)VerticalKernFeature(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFGlyphRenameFixup(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  
  SWIG_check_num_args("SFGlyphRenameFixup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFGlyphRenameFixup",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFGlyphRenameFixup",2,"char *");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SFGlyphRenameFixup",3,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFGlyphRenameFixup",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  SFGlyphRenameFixup(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_script_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  uint32 arg2 ;
  
  SWIG_check_num_args("sllk::script",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::script",1,"struct sllk *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sllk::script",2,"uint32");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_script_set",1,SWIGTYPE_p_sllk);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  if (arg1) (arg1)->script = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_script_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  uint32 result;
  
  SWIG_check_num_args("sllk::script",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::script",1,"struct sllk *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_script_get",1,SWIGTYPE_p_sllk);
  }
  
  result = (uint32) ((arg1)->script);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_cnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sllk::cnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::cnt",1,"struct sllk *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sllk::cnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_cnt_set",1,SWIGTYPE_p_sllk);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->cnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_cnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int result;
  
  SWIG_check_num_args("sllk::cnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::cnt",1,"struct sllk *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_cnt_get",1,SWIGTYPE_p_sllk);
  }
  
  result = (int) ((arg1)->cnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_max_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sllk::max",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::max",1,"struct sllk *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sllk::max",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_max_set",1,SWIGTYPE_p_sllk);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->max = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_max_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int result;
  
  SWIG_check_num_args("sllk::max",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::max",1,"struct sllk *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_max_get",1,SWIGTYPE_p_sllk);
  }
  
  result = (int) ((arg1)->max);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_lookups_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  OTLookup **arg2 = (OTLookup **) 0 ;
  
  SWIG_check_num_args("sllk::lookups",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::lookups",1,"struct sllk *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sllk::lookups",2,"OTLookup **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_lookups_set",1,SWIGTYPE_p_sllk);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_otlookup,0))){
    SWIG_fail_ptr("sllk_lookups_set",2,SWIGTYPE_p_p_otlookup);
  }
  
  if (arg1) (arg1)->lookups = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_lookups_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  OTLookup **result = 0 ;
  
  SWIG_check_num_args("sllk::lookups",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::lookups",1,"struct sllk *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_lookups_get",1,SWIGTYPE_p_sllk);
  }
  
  result = (OTLookup **) ((arg1)->lookups);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_lcnt_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sllk::lcnt",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::lcnt",1,"struct sllk *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sllk::lcnt",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_lcnt_set",1,SWIGTYPE_p_sllk);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lcnt = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_lcnt_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int result;
  
  SWIG_check_num_args("sllk::lcnt",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::lcnt",1,"struct sllk *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_lcnt_get",1,SWIGTYPE_p_sllk);
  }
  
  result = (int) ((arg1)->lcnt);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_lmax_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("sllk::lmax",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::lmax",1,"struct sllk *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("sllk::lmax",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_lmax_set",1,SWIGTYPE_p_sllk);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->lmax = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_lmax_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int result;
  
  SWIG_check_num_args("sllk::lmax",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::lmax",1,"struct sllk *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_lmax_get",1,SWIGTYPE_p_sllk);
  }
  
  result = (int) ((arg1)->lmax);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_langs_set(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  uint32 *arg2 = (uint32 *) 0 ;
  
  SWIG_check_num_args("sllk::langs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::langs",1,"struct sllk *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("sllk::langs",2,"uint32 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_langs_set",1,SWIGTYPE_p_sllk);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,SWIG_POINTER_DISOWN))){
    SWIG_fail_ptr("sllk_langs_set",2,SWIGTYPE_p_unsigned_int);
  }
  
  if (arg1) (arg1)->langs = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_sllk_langs_get(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  uint32 *result = 0 ;
  
  SWIG_check_num_args("sllk::langs",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("sllk::langs",1,"struct sllk *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("sllk_langs_get",1,SWIGTYPE_p_sllk);
  }
  
  result = (uint32 *) ((arg1)->langs);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_sllk(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *result = 0 ;
  
  SWIG_check_num_args("sllk::sllk",0,0)
  result = (struct sllk *)calloc(1, sizeof(struct sllk));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sllk,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_sllk(void *obj) {
struct sllk *arg1 = (struct sllk *) obj;
free((char *) arg1);
}
static swig_lua_method swig_sllk_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_sllk_attributes[] = {
    { "script", _wrap_sllk_script_get, _wrap_sllk_script_set},
    { "cnt", _wrap_sllk_cnt_get, _wrap_sllk_cnt_set},
    { "max", _wrap_sllk_max_get, _wrap_sllk_max_set},
    { "lookups", _wrap_sllk_lookups_get, _wrap_sllk_lookups_set},
    { "lcnt", _wrap_sllk_lcnt_get, _wrap_sllk_lcnt_set},
    { "lmax", _wrap_sllk_lmax_get, _wrap_sllk_lmax_set},
    { "langs", _wrap_sllk_langs_get, _wrap_sllk_langs_set},
    {0,0,0}
};
static swig_lua_class *swig_sllk_bases[] = {0};
static const char *swig_sllk_base_names[] = {0};
static swig_lua_class _wrap_class_sllk = { "sllk", &SWIGTYPE_p_sllk,_wrap_new_sllk, swig_delete_sllk, swig_sllk_methods, swig_sllk_attributes, swig_sllk_bases, swig_sllk_base_names };

static int _wrap_SllkFree(lua_State* L) {
  int SWIG_arg = 0;
  struct sllk *arg1 = (struct sllk *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SllkFree",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SllkFree",1,"struct sllk *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SllkFree",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("SllkFree",1,SWIGTYPE_p_sllk);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SllkFree(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AddOTLToSllks(lua_State* L) {
  int SWIG_arg = 0;
  OTLookup *arg1 = (OTLookup *) 0 ;
  struct sllk *arg2 = (struct sllk *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  struct sllk *result = 0 ;
  
  SWIG_check_num_args("AddOTLToSllks",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddOTLToSllks",1,"OTLookup *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("AddOTLToSllks",2,"struct sllk *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("AddOTLToSllks",3,"int *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("AddOTLToSllks",4,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_otlookup,0))){
    SWIG_fail_ptr("AddOTLToSllks",1,SWIGTYPE_p_otlookup);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("AddOTLToSllks",2,SWIGTYPE_p_sllk);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("AddOTLToSllks",3,SWIGTYPE_p_int);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("AddOTLToSllks",4,SWIGTYPE_p_int);
  }
  
  result = (struct sllk *)AddOTLToSllks(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_sllk,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_NewAALTLookup(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct sllk *arg2 = (struct sllk *) 0 ;
  int arg3 ;
  int arg4 ;
  OTLookup *result = 0 ;
  
  SWIG_check_num_args("NewAALTLookup",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("NewAALTLookup",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("NewAALTLookup",2,"struct sllk *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("NewAALTLookup",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("NewAALTLookup",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("NewAALTLookup",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_sllk,0))){
    SWIG_fail_ptr("NewAALTLookup",2,SWIGTYPE_p_sllk);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (OTLookup *)NewAALTLookup(arg1,arg2,arg3,arg4);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_otlookup,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AddNewAALTFeatures(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("AddNewAALTFeatures",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AddNewAALTFeatures",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("AddNewAALTFeatures",1,SWIGTYPE_p_splinefont);
  }
  
  AddNewAALTFeatures(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointRound(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  float arg2 ;
  
  SWIG_check_num_args("SplinePointRound",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointRound",1,"SplinePoint *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplinePointRound",2,"float");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SplinePointRound",1,SWIGTYPE_p_splinepoint);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  SplinePointRound(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_KCFindName(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  char **arg2 = (char **) 0 ;
  int arg3 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("KCFindName",4,4)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("KCFindName",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("KCFindName",2,"char **");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("KCFindName",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("KCFindName",4,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("KCFindName",2,SWIGTYPE_p_p_char);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)KCFindName(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearRounds(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCClearRounds",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearRounds",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCClearRounds",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearRounds",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCClearRounds(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MDReplace(lua_State* L) {
  int SWIG_arg = 0;
  MinimumDistance *arg1 = (MinimumDistance *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  SplineSet *arg3 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("MDReplace",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("MDReplace",1,"MinimumDistance *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("MDReplace",2,"SplineSet *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("MDReplace",3,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_minimumdistance,0))){
    SWIG_fail_ptr("MDReplace",1,SWIGTYPE_p_minimumdistance);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("MDReplace",2,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("MDReplace",3,SWIGTYPE_p_splinepointlist);
  }
  
  MDReplace(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCSynchronizeWidth(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  float arg2 ;
  float arg3 ;
  struct fontviewbase *arg4 = (struct fontviewbase *) 0 ;
  
  SWIG_check_num_args("SCSynchronizeWidth",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCSynchronizeWidth",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCSynchronizeWidth",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCSynchronizeWidth",3,"float");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("SCSynchronizeWidth",4,"struct fontviewbase *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCSynchronizeWidth",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (float)lua_tonumber(L, 3);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_fontviewbase,0))){
    SWIG_fail_ptr("SCSynchronizeWidth",4,SWIGTYPE_p_fontviewbase);
  }
  
  SCSynchronizeWidth(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HasUseMyMetrics(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  RefChar *result = 0 ;
  
  SWIG_check_num_args("HasUseMyMetrics",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("HasUseMyMetrics",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("HasUseMyMetrics",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("HasUseMyMetrics",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (RefChar *)HasUseMyMetrics(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_refchar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCSynchronizeLBearing(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  float arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("SCSynchronizeLBearing",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCSynchronizeLBearing",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCSynchronizeLBearing",2,"float");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCSynchronizeLBearing",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCSynchronizeLBearing",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (float)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  SCSynchronizeLBearing(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RevertedGlyphReferenceFixup(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  SplineFont *arg2 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("RevertedGlyphReferenceFixup",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("RevertedGlyphReferenceFixup",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RevertedGlyphReferenceFixup",2,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("RevertedGlyphReferenceFixup",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("RevertedGlyphReferenceFixup",2,SWIGTYPE_p_splinefont);
  }
  
  RevertedGlyphReferenceFixup(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFUntickAll(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("SFUntickAll",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFUntickAll",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFUntickAll",1,SWIGTYPE_p_splinefont);
  }
  
  SFUntickAll(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFOrigFixup(lua_State* L) {
  int SWIG_arg = 0;
  BDFFont *arg1 = (BDFFont *) 0 ;
  int arg2 ;
  SplineFont *arg3 = (SplineFont *) 0 ;
  
  SWIG_check_num_args("BDFOrigFixup",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BDFOrigFixup",1,"BDFFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("BDFOrigFixup",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BDFOrigFixup",3,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("BDFOrigFixup",1,SWIGTYPE_p_bdffont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("BDFOrigFixup",3,SWIGTYPE_p_splinefont);
  }
  
  BDFOrigFixup(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HasSVG(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("HasSVG",0,0)
  result = (int)HasSVG();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportSVG(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  
  SWIG_check_num_args("SCImportSVG",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportSVG",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportSVG",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SCImportSVG",3,"char *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SCImportSVG",4,"char *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCImportSVG",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SCImportSVG",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportSVG",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  SCImportSVG(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_HasUFO(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("HasUFO",0,0)
  result = (int)HasUFO();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportGlif(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  int arg5 ;
  int arg6 ;
  
  SWIG_check_num_args("SCImportGlif",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportGlif",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportGlif",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SCImportGlif",3,"char *");
  if(!SWIG_lua_isnilstring(L,4)) SWIG_fail_arg("SCImportGlif",4,"char *");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCImportGlif",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SCImportGlif",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportGlif",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (char *)lua_tostring(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  SCImportGlif(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportPS(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int arg5 ;
  
  SWIG_check_num_args("SCImportPS",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportPS",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportPS",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SCImportPS",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCImportPS",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCImportPS",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportPS",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  SCImportPS(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportPSFile(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  FILE *arg3 = (FILE *) 0 ;
  int arg4 ;
  int arg5 ;
  
  SWIG_check_num_args("SCImportPSFile",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportPSFile",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportPSFile",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCImportPSFile",3,"FILE *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCImportPSFile",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCImportPSFile",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportPSFile",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SCImportPSFile",3,SWIGTYPE_p_FILE);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  SCImportPSFile(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportPDF(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  int arg5 ;
  
  SWIG_check_num_args("SCImportPDF",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportPDF",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportPDF",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SCImportPDF",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCImportPDF",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCImportPDF",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportPDF",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  SCImportPDF(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportPDFFile(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  FILE *arg3 = (FILE *) 0 ;
  int arg4 ;
  int arg5 ;
  
  SWIG_check_num_args("SCImportPDFFile",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportPDFFile",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportPDFFile",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCImportPDFFile",3,"FILE *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCImportPDFFile",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCImportPDFFile",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportPDFFile",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SCImportPDFFile",3,SWIGTYPE_p_FILE);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  SCImportPDFFile(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportPlateFile(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  FILE *arg3 = (FILE *) 0 ;
  int arg4 ;
  int arg5 ;
  
  SWIG_check_num_args("SCImportPlateFile",5,5)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportPlateFile",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportPlateFile",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SCImportPlateFile",3,"FILE *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCImportPlateFile",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCImportPlateFile",5,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportPlateFile",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("SCImportPlateFile",3,SWIGTYPE_p_FILE);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  SCImportPlateFile(arg1,arg2,arg3,arg4,arg5);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCAddScaleImage(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  struct gimage *arg2 = (struct gimage *) 0 ;
  int arg3 ;
  int arg4 ;
  
  SWIG_check_num_args("SCAddScaleImage",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCAddScaleImage",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCAddScaleImage",2,"struct gimage *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCAddScaleImage",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCAddScaleImage",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCAddScaleImage",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gimage,0))){
    SWIG_fail_ptr("SCAddScaleImage",2,SWIGTYPE_p_gimage);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SCAddScaleImage(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCInsertImage(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  struct gimage *arg2 = (struct gimage *) 0 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  int arg6 ;
  
  SWIG_check_num_args("SCInsertImage",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCInsertImage",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCInsertImage",2,"struct gimage *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCInsertImage",3,"float");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCInsertImage",4,"float");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("SCInsertImage",5,"float");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("SCInsertImage",6,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCInsertImage",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_gimage,0))){
    SWIG_fail_ptr("SCInsertImage",2,SWIGTYPE_p_gimage);
  }
  
  arg3 = (float)lua_tonumber(L, 3);
  arg4 = (float)lua_tonumber(L, 4);
  arg5 = (float)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  SCInsertImage(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCImportFig(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  char *arg3 = (char *) 0 ;
  int arg4 ;
  
  SWIG_check_num_args("SCImportFig",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCImportFig",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCImportFig",2,"int");
  if(!SWIG_lua_isnilstring(L,3)) SWIG_fail_arg("SCImportFig",3,"char *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SCImportFig",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCImportFig",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (char *)lua_tostring(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  SCImportFig(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__ExportPlate(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("_ExportPlate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_ExportPlate",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_ExportPlate",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_ExportPlate",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_ExportPlate",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_ExportPlate",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)_ExportPlate(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__ExportPDF(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("_ExportPDF",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_ExportPDF",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_ExportPDF",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_ExportPDF",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_ExportPDF",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_ExportPDF",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)_ExportPDF(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__ExportEPS(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int arg4 ;
  int result;
  
  SWIG_check_num_args("_ExportEPS",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_ExportEPS",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_ExportEPS",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_ExportEPS",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("_ExportEPS",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_ExportEPS",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_ExportEPS",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  result = (int)_ExportEPS(arg1,arg2,arg3,arg4);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__ExportSVG(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("_ExportSVG",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_ExportSVG",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_ExportSVG",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_ExportSVG",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_ExportSVG",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_ExportSVG",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)_ExportSVG(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__ExportGlif(lua_State* L) {
  int SWIG_arg = 0;
  FILE *arg1 = (FILE *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("_ExportGlif",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_ExportGlif",1,"FILE *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("_ExportGlif",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("_ExportGlif",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("_ExportGlif",1,SWIGTYPE_p_FILE);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("_ExportGlif",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)_ExportGlif(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ExportEPS(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("ExportEPS",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ExportEPS",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ExportEPS",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ExportEPS",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ExportEPS",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)ExportEPS(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ExportPDF(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("ExportPDF",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ExportPDF",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ExportPDF",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ExportPDF",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ExportPDF",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)ExportPDF(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ExportPlate(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("ExportPlate",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ExportPlate",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ExportPlate",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ExportPlate",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ExportPlate",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)ExportPlate(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ExportSVG(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("ExportSVG",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ExportSVG",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ExportSVG",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ExportSVG",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ExportSVG",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)ExportSVG(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ExportGlif(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("ExportGlif",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ExportGlif",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ExportGlif",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ExportGlif",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ExportGlif",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)ExportGlif(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ExportFig(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("ExportFig",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ExportFig",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ExportFig",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ExportFig",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ExportFig",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)ExportFig(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCExportXBM(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  BDFChar *arg2 = (BDFChar *) 0 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("BCExportXBM",3,3)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("BCExportXBM",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BCExportXBM",2,"BDFChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("BCExportXBM",3,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCExportXBM",2,SWIGTYPE_p_bdfchar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)BCExportXBM(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ExportImage(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int arg3 ;
  int arg4 ;
  int arg5 ;
  int arg6 ;
  int result;
  
  SWIG_check_num_args("ExportImage",6,6)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("ExportImage",1,"char *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ExportImage",2,"SplineChar *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ExportImage",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ExportImage",4,"int");
  if(!lua_isnumber(L,5)) SWIG_fail_arg("ExportImage",5,"int");
  if(!lua_isnumber(L,6)) SWIG_fail_arg("ExportImage",6,"int");
  arg1 = (char *)lua_tostring(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("ExportImage",2,SWIGTYPE_p_splinechar);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (int)lua_tonumber(L, 5);
  arg6 = (int)lua_tonumber(L, 6);
  result = (int)ExportImage(arg1,arg2,arg3,arg4,arg5,arg6);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ScriptExport(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  BDFFont *arg2 = (BDFFont *) 0 ;
  int arg3 ;
  int arg4 ;
  char *arg5 = (char *) 0 ;
  EncMap *arg6 = (EncMap *) 0 ;
  
  SWIG_check_num_args("ScriptExport",6,6)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ScriptExport",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ScriptExport",2,"BDFFont *");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("ScriptExport",3,"int");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("ScriptExport",4,"int");
  if(!SWIG_lua_isnilstring(L,5)) SWIG_fail_arg("ScriptExport",5,"char *");
  if(!SWIG_isptrtype(L,6)) SWIG_fail_arg("ScriptExport",6,"EncMap *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ScriptExport",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_bdffont,0))){
    SWIG_fail_ptr("ScriptExport",2,SWIGTYPE_p_bdffont);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  arg4 = (int)lua_tonumber(L, 4);
  arg5 = (char *)lua_tostring(L, 5);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,6,(void**)&arg6,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("ScriptExport",6,SWIGTYPE_p_encmap);
  }
  
  ScriptExport(arg1,arg2,arg3,arg4,arg5,arg6);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFRemoveGlyph(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int *arg3 = (int *) 0 ;
  
  SWIG_check_num_args("SFRemoveGlyph",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFRemoveGlyph",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFRemoveGlyph",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFRemoveGlyph",3,"int *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFRemoveGlyph",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFRemoveGlyph",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("SFRemoveGlyph",3,SWIGTYPE_p_int);
  }
  
  SFRemoveGlyph(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFAddEncodingSlot(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SFAddEncodingSlot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFAddEncodingSlot",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFAddEncodingSlot",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFAddEncodingSlot",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SFAddEncodingSlot(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFAddGlyphAndEncode(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  EncMap *arg3 = (EncMap *) 0 ;
  int arg4 ;
  
  SWIG_check_num_args("SFAddGlyphAndEncode",4,4)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFAddGlyphAndEncode",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFAddGlyphAndEncode",2,"SplineChar *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SFAddGlyphAndEncode",3,"EncMap *");
  if(!lua_isnumber(L,4)) SWIG_fail_arg("SFAddGlyphAndEncode",4,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFAddGlyphAndEncode",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFAddGlyphAndEncode",2,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_encmap,0))){
    SWIG_fail_ptr("SFAddGlyphAndEncode",3,SWIGTYPE_p_encmap);
  }
  
  arg4 = (int)lua_tonumber(L, 4);
  SFAddGlyphAndEncode(arg1,arg2,arg3,arg4);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCDoRedo(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCDoRedo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCDoRedo",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCDoRedo",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCDoRedo",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCDoRedo(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCDoUndo(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCDoUndo",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCDoUndo",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCDoUndo",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCDoUndo",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCDoUndo(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCCopyWidth(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  enum undotype arg2 ;
  
  SWIG_check_num_args("SCCopyWidth",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCCopyWidth",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCCopyWidth",2,"enum undotype");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCCopyWidth",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (enum undotype)(int)lua_tonumber(L, 2);
  SCCopyWidth(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearBackground(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SCClearBackground",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearBackground",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearBackground",1,SWIGTYPE_p_splinechar);
  }
  
  SCClearBackground(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BackgroundImageTransform(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  ImageList *arg2 = (ImageList *) 0 ;
  float *arg3 ;
  
  SWIG_check_num_args("BackgroundImageTransform",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BackgroundImageTransform",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BackgroundImageTransform",2,"ImageList *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BackgroundImageTransform",3,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("BackgroundImageTransform",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_imagelist,0))){
    SWIG_fail_ptr("BackgroundImageTransform",2,SWIGTYPE_p_imagelist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("BackgroundImageTransform",3,SWIGTYPE_p_float);
  }
  
  BackgroundImageTransform(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFIsDuplicatable(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  SplineChar *arg2 = (SplineChar *) 0 ;
  int result;
  
  SWIG_check_num_args("SFIsDuplicatable",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFIsDuplicatable",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFIsDuplicatable",2,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFIsDuplicatable",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SFIsDuplicatable",2,SWIGTYPE_p_splinechar);
  }
  
  result = (int)SFIsDuplicatable(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_DoAutoSaves(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("DoAutoSaves",0,0)
  DoAutoSaves();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearLayer(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCClearLayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearLayer",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCClearLayer",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearLayer",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCClearLayer(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearContents(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCClearContents",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearContents",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCClearContents",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearContents",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCClearContents(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearAll(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCClearAll",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearAll",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCClearAll",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearAll",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCClearAll(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BCClearAll(lua_State* L) {
  int SWIG_arg = 0;
  BDFChar *arg1 = (BDFChar *) 0 ;
  
  SWIG_check_num_args("BCClearAll",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BCClearAll",1,"BDFChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_bdfchar,0))){
    SWIG_fail_ptr("BCClearAll",1,SWIGTYPE_p_bdfchar);
  }
  
  BCClearAll(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_doinitFontForgeMain(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("doinitFontForgeMain",0,0)
  doinitFontForgeMain();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_InitSimpleStuff(lua_State* L) {
  int SWIG_arg = 0;
  
  SWIG_check_num_args("InitSimpleStuff",0,0)
  InitSimpleStuff();
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSExistsInLayer(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SSExistsInLayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSExistsInLayer",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SSExistsInLayer",2,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSExistsInLayer",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSExistsInLayer",2,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SSExistsInLayer(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineExistsInSS(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SplineExistsInSS",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineExistsInSS",1,"Spline *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineExistsInSS",2,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineExistsInSS",1,SWIGTYPE_p_spline);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineExistsInSS",2,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SplineExistsInSS(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpExistsInSS(lua_State* L) {
  int SWIG_arg = 0;
  SplinePoint *arg1 = (SplinePoint *) 0 ;
  SplineSet *arg2 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SpExistsInSS",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SpExistsInSS",1,"SplinePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SpExistsInSS",2,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepoint,0))){
    SWIG_fail_ptr("SpExistsInSS",1,SWIGTYPE_p_splinepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SpExistsInSS",2,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SpExistsInSS(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_MSLanguageFromLocale(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("MSLanguageFromLocale",0,0)
  result = (int)MSLanguageFromLocale();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_ui_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("math_constants_descriptor::ui_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::ui_name",1,"struct math_constants_descriptor *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("math_constants_descriptor::ui_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_ui_name_set",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->ui_name);
    if (arg2) {
      arg1->ui_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->ui_name, (const char *)arg2);
    } else {
      arg1->ui_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_ui_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("math_constants_descriptor::ui_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::ui_name",1,"struct math_constants_descriptor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_ui_name_get",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  result = (char *) ((arg1)->ui_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_script_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("math_constants_descriptor::script_name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::script_name",1,"struct math_constants_descriptor *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("math_constants_descriptor::script_name",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_script_name_set",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->script_name);
    if (arg2) {
      arg1->script_name = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->script_name, (const char *)arg2);
    } else {
      arg1->script_name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_script_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("math_constants_descriptor::script_name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::script_name",1,"struct math_constants_descriptor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_script_name_get",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  result = (char *) ((arg1)->script_name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_offset_set(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("math_constants_descriptor::offset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::offset",1,"struct math_constants_descriptor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("math_constants_descriptor::offset",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_offset_set",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->offset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_offset_get(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  int result;
  
  SWIG_check_num_args("math_constants_descriptor::offset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::offset",1,"struct math_constants_descriptor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_offset_get",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  result = (int) ((arg1)->offset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_devtab_offset_set(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("math_constants_descriptor::devtab_offset",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::devtab_offset",1,"struct math_constants_descriptor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("math_constants_descriptor::devtab_offset",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_devtab_offset_set",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->devtab_offset = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_devtab_offset_get(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  int result;
  
  SWIG_check_num_args("math_constants_descriptor::devtab_offset",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::devtab_offset",1,"struct math_constants_descriptor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_devtab_offset_get",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  result = (int) ((arg1)->devtab_offset);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_message_set(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("math_constants_descriptor::message",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::message",1,"struct math_constants_descriptor *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("math_constants_descriptor::message",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_message_set",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->message);
    if (arg2) {
      arg1->message = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->message, (const char *)arg2);
    } else {
      arg1->message = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_message_get(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("math_constants_descriptor::message",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::message",1,"struct math_constants_descriptor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_message_get",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  result = (char *) ((arg1)->message);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_new_page_set(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("math_constants_descriptor::new_page",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::new_page",1,"struct math_constants_descriptor *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("math_constants_descriptor::new_page",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_new_page_set",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->new_page = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_math_constants_descriptor_new_page_get(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) 0 ;
  int result;
  
  SWIG_check_num_args("math_constants_descriptor::new_page",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("math_constants_descriptor::new_page",1,"struct math_constants_descriptor *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_math_constants_descriptor,0))){
    SWIG_fail_ptr("math_constants_descriptor_new_page_get",1,SWIGTYPE_p_math_constants_descriptor);
  }
  
  result = (int) ((arg1)->new_page);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_math_constants_descriptor(lua_State* L) {
  int SWIG_arg = 0;
  struct math_constants_descriptor *result = 0 ;
  
  SWIG_check_num_args("math_constants_descriptor::math_constants_descriptor",0,0)
  result = (struct math_constants_descriptor *)calloc(1, sizeof(struct math_constants_descriptor));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_math_constants_descriptor,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_math_constants_descriptor(void *obj) {
struct math_constants_descriptor *arg1 = (struct math_constants_descriptor *) obj;
free((char *) arg1);
}
static swig_lua_method swig_math_constants_descriptor_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_math_constants_descriptor_attributes[] = {
    { "ui_name", _wrap_math_constants_descriptor_ui_name_get, _wrap_math_constants_descriptor_ui_name_set},
    { "script_name", _wrap_math_constants_descriptor_script_name_get, _wrap_math_constants_descriptor_script_name_set},
    { "offset", _wrap_math_constants_descriptor_offset_get, _wrap_math_constants_descriptor_offset_set},
    { "devtab_offset", _wrap_math_constants_descriptor_devtab_offset_get, _wrap_math_constants_descriptor_devtab_offset_set},
    { "message", _wrap_math_constants_descriptor_message_get, _wrap_math_constants_descriptor_message_set},
    { "new_page", _wrap_math_constants_descriptor_new_page_get, _wrap_math_constants_descriptor_new_page_set},
    {0,0,0}
};
static swig_lua_class *swig_math_constants_descriptor_bases[] = {0};
static const char *swig_math_constants_descriptor_base_names[] = {0};
static swig_lua_class _wrap_class_math_constants_descriptor = { "math_constants_descriptor", &SWIGTYPE_p_math_constants_descriptor,_wrap_new_math_constants_descriptor, swig_delete_math_constants_descriptor, swig_math_constants_descriptor_methods, swig_math_constants_descriptor_attributes, swig_math_constants_descriptor_bases, swig_math_constants_descriptor_base_names };

static int _wrap_BPTooFar(lua_State* L) {
  int SWIG_arg = 0;
  BasePoint *arg1 = (BasePoint *) 0 ;
  BasePoint *arg2 = (BasePoint *) 0 ;
  int result;
  
  SWIG_check_num_args("BPTooFar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BPTooFar",1,"BasePoint *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BPTooFar",2,"BasePoint *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BPTooFar",1,SWIGTYPE_p_basepoint);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_basepoint,0))){
    SWIG_fail_ptr("BPTooFar",2,SWIGTYPE_p_basepoint);
  }
  
  result = (int)BPTooFar(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCHintOverlapInMask(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  HintMask *arg2 = (HintMask *) 0 ;
  StemInfo *result = 0 ;
  
  SWIG_check_num_args("SCHintOverlapInMask",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCHintOverlapInMask",1,"SplineChar *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SCHintOverlapInMask",2,"HintMask *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCHintOverlapInMask",1,SWIGTYPE_p_splinechar);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_a_96_8__unsigned_char,0))){
    SWIG_fail_ptr("SCHintOverlapInMask",2,SWIGTYPE_p_a_96_8__unsigned_char);
  }
  
  result = (StemInfo *)SCHintOverlapInMask(arg1,(unsigned char (*)[96/8])arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_steminfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCValidate(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("SCValidate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCValidate",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCValidate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCValidate",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCValidate",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)SCValidate(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCValidateAnchors(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  AnchorClass *result = 0 ;
  
  SWIG_check_num_args("SCValidateAnchors",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCValidateAnchors",1,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCValidateAnchors",1,SWIGTYPE_p_splinechar);
  }
  
  result = (AnchorClass *)SCValidateAnchors(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_anchorclass,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCTickValidationState(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("SCTickValidationState",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCTickValidationState",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCTickValidationState",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCTickValidationState",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  SCTickValidationState(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ValidatePrivate(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int result;
  
  SWIG_check_num_args("ValidatePrivate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("ValidatePrivate",1,"SplineFont *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("ValidatePrivate",1,SWIGTYPE_p_splinefont);
  }
  
  result = (int)ValidatePrivate(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFValidate(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("SFValidate",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFValidate",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFValidate",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFValidate",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFValidate",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)SFValidate(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_VSMaskFromFormat(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  enum fontformat arg3 ;
  int result;
  
  SWIG_check_num_args("VSMaskFromFormat",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("VSMaskFromFormat",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("VSMaskFromFormat",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("VSMaskFromFormat",3,"enum fontformat");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("VSMaskFromFormat",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (enum fontformat)(int)lua_tonumber(L, 3);
  result = (int)VSMaskFromFormat(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_hasspiro(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("hasspiro",0,0)
  result = (int)hasspiro();
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpiroCP2SplineSet(lua_State* L) {
  int SWIG_arg = 0;
  spiro_cp *arg1 = (spiro_cp *) 0 ;
  SplineSet *result = 0 ;
  
  SWIG_check_num_args("SpiroCP2SplineSet",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SpiroCP2SplineSet",1,"spiro_cp *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spiro_cp,0))){
    SWIG_fail_ptr("SpiroCP2SplineSet",1,SWIGTYPE_p_spiro_cp);
  }
  
  result = (SplineSet *)SpiroCP2SplineSet(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineSet2SpiroCP(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  spiro_cp *result = 0 ;
  
  SWIG_check_num_args("SplineSet2SpiroCP",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineSet2SpiroCP",1,"SplineSet *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SplineSet2SpiroCP",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplineSet2SpiroCP",1,SWIGTYPE_p_splinepointlist);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("SplineSet2SpiroCP",2,SWIGTYPE_p_unsigned_short);
  }
  
  result = (spiro_cp *)SplineSet2SpiroCP(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spiro_cp,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SpiroCPCopy(lua_State* L) {
  int SWIG_arg = 0;
  spiro_cp *arg1 = (spiro_cp *) 0 ;
  uint16 *arg2 = (uint16 *) 0 ;
  spiro_cp *result = 0 ;
  
  SWIG_check_num_args("SpiroCPCopy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SpiroCPCopy",1,"spiro_cp *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SpiroCPCopy",2,"uint16 *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spiro_cp,0))){
    SWIG_fail_ptr("SpiroCPCopy",1,SWIGTYPE_p_spiro_cp);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_short,0))){
    SWIG_fail_ptr("SpiroCPCopy",2,SWIGTYPE_p_unsigned_short);
  }
  
  result = (spiro_cp *)SpiroCPCopy(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spiro_cp,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSRegenerateFromSpiros(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  
  SWIG_check_num_args("SSRegenerateFromSpiros",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSRegenerateFromSpiros",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSRegenerateFromSpiros",1,SWIGTYPE_p_splinepointlist);
  }
  
  SSRegenerateFromSpiros(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PrtBuildDef(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  void *arg2 = (void *) 0 ;
  void (*arg3)(void *,int,uint32,uint32) = (void (*)(void *,int,uint32,uint32)) 0 ;
  unichar_t *result = 0 ;
  
  SWIG_check_num_args("PrtBuildDef",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PrtBuildDef",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PrtBuildDef",2,"void *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PrtBuildDef",3,"void (*)(void *,int,uint32,uint32)");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("PrtBuildDef",1,SWIGTYPE_p_splinefont);
  }
  
  arg2=(void *)SWIG_MustGetPtr(L,2,0,0,2,"PrtBuildDef");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_f_p_void_int_unsigned_int_unsigned_int__void,0))){
    SWIG_fail_ptr("PrtBuildDef",3,SWIGTYPE_p_f_p_void_int_unsigned_int_unsigned_int__void);
  }
  
  result = (unichar_t *)PrtBuildDef(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unsigned_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomParaFromScriptLang(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  uint32 arg2 ;
  SplineFont *arg3 = (SplineFont *) 0 ;
  struct lang_frequencies *arg4 = (struct lang_frequencies *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("RandomParaFromScriptLang",4,4)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("RandomParaFromScriptLang",1,"uint32");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("RandomParaFromScriptLang",2,"uint32");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("RandomParaFromScriptLang",3,"SplineFont *");
  if(!SWIG_isptrtype(L,4)) SWIG_fail_arg("RandomParaFromScriptLang",4,"struct lang_frequencies *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint32)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("RandomParaFromScriptLang",3,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,4,(void**)&arg4,SWIGTYPE_p_lang_frequencies,0))){
    SWIG_fail_ptr("RandomParaFromScriptLang",4,SWIGTYPE_p_lang_frequencies);
  }
  
  result = (char *)RandomParaFromScriptLang(arg1,arg2,arg3,arg4);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_RandomParaFromScript(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  uint32 *arg2 = (uint32 *) 0 ;
  SplineFont *arg3 = (SplineFont *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("RandomParaFromScript",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("RandomParaFromScript",1,"uint32");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("RandomParaFromScript",2,"uint32 *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("RandomParaFromScript",3,"SplineFont *");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("RandomParaFromScript",2,SWIGTYPE_p_unsigned_int);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("RandomParaFromScript",3,SWIGTYPE_p_splinefont);
  }
  
  result = (char *)RandomParaFromScript(arg1,arg2,arg3);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SF2Scripts(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  uint32 *arg2 ;
  int result;
  
  SWIG_check_num_args("SF2Scripts",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SF2Scripts",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SF2Scripts",2,"uint32 [100]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SF2Scripts",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_unsigned_int,0))){
    SWIG_fail_ptr("SF2Scripts",2,SWIGTYPE_p_unsigned_int);
  }
  
  result = (int)SF2Scripts(arg1,arg2);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFScriptLangs(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  struct lang_frequencies ***arg2 = (struct lang_frequencies ***) 0 ;
  char **result = 0 ;
  
  SWIG_check_num_args("SFScriptLangs",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFScriptLangs",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("SFScriptLangs",2,"struct lang_frequencies ***");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFScriptLangs",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_p_lang_frequencies,0))){
    SWIG_fail_ptr("SFScriptLangs",2,SWIGTYPE_p_p_p_lang_frequencies);
  }
  
  result = (char **)SFScriptLangs(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSHasClip(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SSHasClip",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSHasClip",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSHasClip",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SSHasClip(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SSHasDrawn(lua_State* L) {
  int SWIG_arg = 0;
  SplineSet *arg1 = (SplineSet *) 0 ;
  int result;
  
  SWIG_check_num_args("SSHasDrawn",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SSHasDrawn",1,"SplineSet *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SSHasDrawn",1,SWIGTYPE_p_splinepointlist);
  }
  
  result = (int)SSHasDrawn(arg1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GradientCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  float *arg2 ;
  struct gradient *result = 0 ;
  
  SWIG_check_num_args("GradientCopy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GradientCopy",1,"struct gradient *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("GradientCopy",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("GradientCopy",1,SWIGTYPE_p_gradient);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("GradientCopy",2,SWIGTYPE_p_float);
  }
  
  result = (struct gradient *)GradientCopy(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_gradient,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GradientFree(lua_State* L) {
  int SWIG_arg = 0;
  struct gradient *arg1 = (struct gradient *) 0 ;
  
  SWIG_check_num_args("GradientFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GradientFree",1,"struct gradient *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_gradient,0))){
    SWIG_fail_ptr("GradientFree",1,SWIGTYPE_p_gradient);
  }
  
  GradientFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PatternCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  float *arg2 ;
  struct pattern *result = 0 ;
  
  SWIG_check_num_args("PatternCopy",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PatternCopy",1,"struct pattern *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PatternCopy",2,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("PatternCopy",1,SWIGTYPE_p_pattern);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("PatternCopy",2,SWIGTYPE_p_float);
  }
  
  result = (struct pattern *)PatternCopy(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_pattern,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PatternFree(lua_State* L) {
  int SWIG_arg = 0;
  struct pattern *arg1 = (struct pattern *) 0 ;
  
  SWIG_check_num_args("PatternFree",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PatternFree",1,"struct pattern *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pattern,0))){
    SWIG_fail_ptr("PatternFree",1,SWIGTYPE_p_pattern);
  }
  
  PatternFree(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BrushCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct brush *arg1 = (struct brush *) 0 ;
  struct brush *arg2 = (struct brush *) 0 ;
  float *arg3 ;
  
  SWIG_check_num_args("BrushCopy",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("BrushCopy",1,"struct brush *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("BrushCopy",2,"struct brush *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("BrushCopy",3,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("BrushCopy",1,SWIGTYPE_p_brush);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_brush,0))){
    SWIG_fail_ptr("BrushCopy",2,SWIGTYPE_p_brush);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("BrushCopy",3,SWIGTYPE_p_float);
  }
  
  BrushCopy(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_PenCopy(lua_State* L) {
  int SWIG_arg = 0;
  struct pen *arg1 = (struct pen *) 0 ;
  struct pen *arg2 = (struct pen *) 0 ;
  float *arg3 ;
  
  SWIG_check_num_args("PenCopy",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("PenCopy",1,"struct pen *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("PenCopy",2,"struct pen *");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("PenCopy",3,"float [6]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("PenCopy",1,SWIGTYPE_p_pen);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_pen,0))){
    SWIG_fail_ptr("PenCopy",2,SWIGTYPE_p_pen);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_float,0))){
    SWIG_fail_ptr("PenCopy",3,SWIGTYPE_p_float);
  }
  
  PenCopy(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDefaultImage(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char *arg2 = (char *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("SFDefaultImage",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDefaultImage",1,"SplineFont *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("SFDefaultImage",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDefaultImage",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  result = (char *)SFDefaultImage(arg1,arg2);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SCClearInstrsOrMark(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("SCClearInstrsOrMark",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SCClearInstrsOrMark",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SCClearInstrsOrMark",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SCClearInstrsOrMark",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SCClearInstrsOrMark",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  SCClearInstrsOrMark(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_instrcheck(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("instrcheck",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("instrcheck",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("instrcheck",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("instrcheck",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  instrcheck(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TTFPointMatches(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar *arg1 = (SplineChar *) 0 ;
  int arg2 ;
  int arg3 ;
  
  SWIG_check_num_args("TTFPointMatches",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("TTFPointMatches",1,"SplineChar *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("TTFPointMatches",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("TTFPointMatches",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("TTFPointMatches",1,SWIGTYPE_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  TTFPointMatches(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFCapHeight(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  
  SWIG_check_num_args("SFCapHeight",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFCapHeight",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFCapHeight",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFCapHeight",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFCapHeight",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (double)SFCapHeight(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFXHeight(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  
  SWIG_check_num_args("SFXHeight",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFXHeight",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFXHeight",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFXHeight",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFXHeight",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (double)SFXHeight(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFAscender(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  
  SWIG_check_num_args("SFAscender",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFAscender",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFAscender",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFAscender",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFAscender",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (double)SFAscender(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SFDescender(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  int arg2 ;
  int arg3 ;
  double result;
  
  SWIG_check_num_args("SFDescender",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SFDescender",1,"SplineFont *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SFDescender",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("SFDescender",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("SFDescender",1,SWIGTYPE_p_splinefont);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (double)SFDescender(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_GlyphClassesFromNames(lua_State* L) {
  int SWIG_arg = 0;
  SplineFont *arg1 = (SplineFont *) 0 ;
  char **arg2 = (char **) 0 ;
  int arg3 ;
  SplineChar ***result = 0 ;
  
  SWIG_check_num_args("GlyphClassesFromNames",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("GlyphClassesFromNames",1,"SplineFont *");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("GlyphClassesFromNames",2,"char **");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("GlyphClassesFromNames",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinefont,0))){
    SWIG_fail_ptr("GlyphClassesFromNames",1,SWIGTYPE_p_splinefont);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("GlyphClassesFromNames",2,SWIGTYPE_p_p_char);
  }
  
  arg3 = (int)lua_tonumber(L, 3);
  result = (SplineChar ***)GlyphClassesFromNames(arg1,arg2,arg3);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unicode4_size_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("unicode4_size",0,0)
  result = (int)(int)unicode4_size;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_ProcessNativeScript(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char **arg2 ;
  FILE *arg3 = (FILE *) 0 ;
  
  SWIG_check_num_args("ProcessNativeScript",3,3)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("ProcessNativeScript",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("ProcessNativeScript",2,"char *[]");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("ProcessNativeScript",3,"FILE *");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("ProcessNativeScript",2,SWIGTYPE_p_p_char);
  }
  
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_FILE,0))){
    SWIG_fail_ptr("ProcessNativeScript",3,SWIGTYPE_p_FILE);
  }
  
  ProcessNativeScript(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_CheckIsScript(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  char **arg2 ;
  
  SWIG_check_num_args("CheckIsScript",2,2)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("CheckIsScript",1,"int");
  if(!SWIG_isptrtype(L,2)) SWIG_fail_arg("CheckIsScript",2,"char *[]");
  arg1 = (int)lua_tonumber(L, 1);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,2,(void**)&arg2,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("CheckIsScript",2,SWIGTYPE_p_p_char);
  }
  
  CheckIsScript(arg1,arg2);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AdobeStandardEncoding_set(lua_State* L) {
  int SWIG_arg = 0;
  char **arg1 ;
  
  SWIG_check_num_args("AdobeStandardEncoding",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("AdobeStandardEncoding",1,"char *[256]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_char,0))){
    SWIG_fail_ptr("AdobeStandardEncoding_set",1,SWIGTYPE_p_p_char);
  }
  
  {
    size_t ii;
    char * *b = (char * *) AdobeStandardEncoding;
    for (ii = 0; ii < (size_t)256; ii++) b[ii] = *((char * *) arg1 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_AdobeStandardEncoding_get(lua_State* L) {
  int SWIG_arg = 0;
  char **result = 0 ;
  
  SWIG_check_num_args("AdobeStandardEncoding",0,0)
  result = (char **)(char **)AdobeStandardEncoding;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_char,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unicode_from_adobestd_set(lua_State* L) {
  int SWIG_arg = 0;
  int32 *arg1 ;
  
  SWIG_check_num_args("unicode_from_adobestd",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("unicode_from_adobestd",1,"int32 [256]");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_int,0))){
    SWIG_fail_ptr("unicode_from_adobestd_set",1,SWIGTYPE_p_int);
  }
  
  {
    size_t ii;
    int32 *b = (int32 *) unicode_from_adobestd;
    for (ii = 0; ii < (size_t)256; ii++) b[ii] = *((int32 *) arg1 + ii);
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unicode_from_adobestd_get(lua_State* L) {
  int SWIG_arg = 0;
  int32 *result = 0 ;
  
  SWIG_check_num_args("unicode_from_adobestd",0,0)
  result = (int32 *)(int32 *)unicode_from_adobestd;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_int,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unicode_nameannot_name_set(lua_State* L) {
  int SWIG_arg = 0;
  struct unicode_nameannot *arg1 = (struct unicode_nameannot *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("unicode_nameannot::name",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("unicode_nameannot::name",1,"struct unicode_nameannot *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("unicode_nameannot::name",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_unicode_nameannot,0))){
    SWIG_fail_ptr("unicode_nameannot_name_set",1,SWIGTYPE_p_unicode_nameannot);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if (arg2) {
      arg1->name = (char const *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->name, (const char *)arg2);
    } else {
      arg1->name = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unicode_nameannot_name_get(lua_State* L) {
  int SWIG_arg = 0;
  struct unicode_nameannot *arg1 = (struct unicode_nameannot *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("unicode_nameannot::name",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("unicode_nameannot::name",1,"struct unicode_nameannot *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_unicode_nameannot,0))){
    SWIG_fail_ptr("unicode_nameannot_name_get",1,SWIGTYPE_p_unicode_nameannot);
  }
  
  result = (char *) ((arg1)->name);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unicode_nameannot_annot_set(lua_State* L) {
  int SWIG_arg = 0;
  struct unicode_nameannot *arg1 = (struct unicode_nameannot *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("unicode_nameannot::annot",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("unicode_nameannot::annot",1,"struct unicode_nameannot *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("unicode_nameannot::annot",2,"char const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_unicode_nameannot,0))){
    SWIG_fail_ptr("unicode_nameannot_annot_set",1,SWIGTYPE_p_unicode_nameannot);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    if (arg2) {
      arg1->annot = (char const *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->annot, (const char *)arg2);
    } else {
      arg1->annot = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_unicode_nameannot_annot_get(lua_State* L) {
  int SWIG_arg = 0;
  struct unicode_nameannot *arg1 = (struct unicode_nameannot *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("unicode_nameannot::annot",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("unicode_nameannot::annot",1,"struct unicode_nameannot *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_unicode_nameannot,0))){
    SWIG_fail_ptr("unicode_nameannot_annot_get",1,SWIGTYPE_p_unicode_nameannot);
  }
  
  result = (char *) ((arg1)->annot);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_unicode_nameannot(lua_State* L) {
  int SWIG_arg = 0;
  struct unicode_nameannot *result = 0 ;
  
  SWIG_check_num_args("unicode_nameannot::unicode_nameannot",0,0)
  result = (struct unicode_nameannot *)calloc(1, sizeof(struct unicode_nameannot));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_unicode_nameannot,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_unicode_nameannot(void *obj) {
struct unicode_nameannot *arg1 = (struct unicode_nameannot *) obj;
free((char *) arg1);
}
static swig_lua_method swig_unicode_nameannot_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_unicode_nameannot_attributes[] = {
    { "name", _wrap_unicode_nameannot_name_get, _wrap_unicode_nameannot_name_set},
    { "annot", _wrap_unicode_nameannot_annot_get, _wrap_unicode_nameannot_annot_set},
    {0,0,0}
};
static swig_lua_class *swig_unicode_nameannot_bases[] = {0};
static const char *swig_unicode_nameannot_base_names[] = {0};
static swig_lua_class _wrap_class_unicode_nameannot = { "unicode_nameannot", &SWIGTYPE_p_unicode_nameannot,_wrap_new_unicode_nameannot, swig_delete_unicode_nameannot, swig_unicode_nameannot_methods, swig_unicode_nameannot_attributes, swig_unicode_nameannot_bases, swig_unicode_nameannot_base_names };

static int _wrap__UnicodeNameAnnot_set(lua_State* L) {
  int SWIG_arg = 0;
  struct unicode_nameannot ***arg1 = (struct unicode_nameannot ***) 0 ;
  
  SWIG_check_num_args("_UnicodeNameAnnot",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("_UnicodeNameAnnot",1,"struct unicode_nameannot const *const *const *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_p_unicode_nameannot,0))){
    SWIG_fail_ptr("_UnicodeNameAnnot_set",1,SWIGTYPE_p_p_p_unicode_nameannot);
  }
  
  _UnicodeNameAnnot = (struct unicode_nameannot const *const *const *)arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap__UnicodeNameAnnot_get(lua_State* L) {
  int SWIG_arg = 0;
  struct unicode_nameannot ***result = 0 ;
  
  SWIG_check_num_args("_UnicodeNameAnnot",0,0)
  result = (struct unicode_nameannot ***)_UnicodeNameAnnot;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_p_unicode_nameannot,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_fv_font_size_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("default_fv_font_size",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("default_fv_font_size",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  default_fv_font_size = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_fv_font_size_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("default_fv_font_size",0,0)
  result = (int)default_fv_font_size;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_fv_antialias_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("default_fv_antialias",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("default_fv_antialias",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  default_fv_antialias = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_fv_antialias_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("default_fv_antialias",0,0)
  result = (int)default_fv_antialias;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_fv_bbsized_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("default_fv_bbsized",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("default_fv_bbsized",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  default_fv_bbsized = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_fv_bbsized_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("default_fv_bbsized",0,0)
  result = (int)default_fv_bbsized;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_encoding_set(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *arg1 = (Encoding *) 0 ;
  
  SWIG_check_num_args("default_encoding",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("default_encoding",1,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("default_encoding_set",1,SWIGTYPE_p_enc);
  }
  
  default_encoding = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_encoding_get(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *result = 0 ;
  
  SWIG_check_num_args("default_encoding",0,0)
  result = (Encoding *)default_encoding;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_custom_set(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *arg1 = (Encoding *) 0 ;
  
  SWIG_check_num_args("custom",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("custom",1,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("custom_set",1,SWIGTYPE_p_enc);
  }
  
  custom = *arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_custom_get(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *result = 0 ;
  
  SWIG_check_num_args("custom",0,0)
  result = (Encoding *)&custom;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_adjustwidth_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("adjustwidth",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("adjustwidth",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  adjustwidth = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_adjustwidth_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("adjustwidth",0,0)
  result = (int)adjustwidth;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_adjustlbearing_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("adjustlbearing",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("adjustlbearing",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  adjustlbearing = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_adjustlbearing_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("adjustlbearing",0,0)
  result = (int)adjustlbearing;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_autohint_before_generate_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("autohint_before_generate",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("autohint_before_generate",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  autohint_before_generate = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_autohint_before_generate_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("autohint_before_generate",0,0)
  result = (int)autohint_before_generate;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_no_windowing_ui_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("no_windowing_ui",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("no_windowing_ui",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  no_windowing_ui = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_no_windowing_ui_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("no_windowing_ui",0,0)
  result = (int)no_windowing_ui;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_background_set(lua_State* L) {
  int SWIG_arg = 0;
  uint32 arg1 ;
  
  SWIG_check_num_args("default_background",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("default_background",1,"uint32");
  SWIG_contract_assert((lua_tonumber(L,1)>=0),"number must not be negative")
  arg1 = (uint32)lua_tonumber(L, 1);
  default_background = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_background_get(lua_State* L) {
  int SWIG_arg = 0;
  uint32 result;
  
  SWIG_check_num_args("default_background",0,0)
  result = (uint32)default_background;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_use_utf8_in_script_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("use_utf8_in_script",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("use_utf8_in_script",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  use_utf8_in_script = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_use_utf8_in_script_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("use_utf8_in_script",0,0)
  result = (int)use_utf8_in_script;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_em_size_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("new_em_size",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("new_em_size",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  new_em_size = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_em_size_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("new_em_size",0,0)
  result = (int)new_em_size;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_fonts_are_order2_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("new_fonts_are_order2",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("new_fonts_are_order2",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  new_fonts_are_order2 = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_fonts_are_order2_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("new_fonts_are_order2",0,0)
  result = (int)new_fonts_are_order2;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_loaded_fonts_same_as_new_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("loaded_fonts_same_as_new",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("loaded_fonts_same_as_new",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  loaded_fonts_same_as_new = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_loaded_fonts_same_as_new_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("loaded_fonts_same_as_new",0,0)
  result = (int)loaded_fonts_same_as_new;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFoundry_set(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("BDFFoundry",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("BDFFoundry",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  {
    free(BDFFoundry);
    if (arg1) {
      BDFFoundry = (char *) malloc(strlen((const char *)arg1)+1);
      strcpy((char *)BDFFoundry, (const char *)arg1);
    } else {
      BDFFoundry = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_BDFFoundry_get(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("BDFFoundry",0,0)
  result = (char *)BDFFoundry;
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TTFFoundry_set(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("TTFFoundry",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("TTFFoundry",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  {
    free(TTFFoundry);
    if (arg1) {
      TTFFoundry = (char *) malloc(strlen((const char *)arg1)+1);
      strcpy((char *)TTFFoundry, (const char *)arg1);
    } else {
      TTFFoundry = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_TTFFoundry_get(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("TTFFoundry",0,0)
  result = (char *)TTFFoundry;
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xuid_set(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("xuid",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("xuid",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  {
    free(xuid);
    if (arg1) {
      xuid = (char *) malloc(strlen((const char *)arg1)+1);
      strcpy((char *)xuid, (const char *)arg1);
    } else {
      xuid = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_xuid_get(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("xuid",0,0)
  result = (char *)xuid;
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pagewidth_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("pagewidth",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("pagewidth",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  pagewidth = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pagewidth_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("pagewidth",0,0)
  result = (int)pagewidth;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pageheight_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("pageheight",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("pageheight",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  pageheight = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_pageheight_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("pageheight",0,0)
  result = (int)pageheight;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_printtype_set(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  
  SWIG_check_num_args("printtype",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("printtype",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  printtype = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_printtype_get(lua_State* L) {
  int SWIG_arg = 0;
  int result;
  
  SWIG_check_num_args("printtype",0,0)
  result = (int)printtype;
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_printcommand_set(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("printcommand",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("printcommand",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  {
    free(printcommand);
    if (arg1) {
      printcommand = (char *) malloc(strlen((const char *)arg1)+1);
      strcpy((char *)printcommand, (const char *)arg1);
    } else {
      printcommand = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_printcommand_get(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("printcommand",0,0)
  result = (char *)printcommand;
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_printlazyprinter_set(lua_State* L) {
  int SWIG_arg = 0;
  char *arg1 = (char *) 0 ;
  
  SWIG_check_num_args("printlazyprinter",1,1)
  if(!SWIG_lua_isnilstring(L,1)) SWIG_fail_arg("printlazyprinter",1,"char *");
  arg1 = (char *)lua_tostring(L, 1);
  {
    free(printlazyprinter);
    if (arg1) {
      printlazyprinter = (char *) malloc(strlen((const char *)arg1)+1);
      strcpy((char *)printlazyprinter, (const char *)arg1);
    } else {
      printlazyprinter = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_printlazyprinter_get(lua_State* L) {
  int SWIG_arg = 0;
  char *result = 0 ;
  
  SWIG_check_num_args("printlazyprinter",0,0)
  result = (char *)printlazyprinter;
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_enclist_set(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *arg1 = (Encoding *) 0 ;
  
  SWIG_check_num_args("enclist",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("enclist",1,"Encoding *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_enc,0))){
    SWIG_fail_ptr("enclist_set",1,SWIGTYPE_p_enc);
  }
  
  enclist = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_enclist_get(lua_State* L) {
  int SWIG_arg = 0;
  Encoding *result = 0 ;
  
  SWIG_check_num_args("enclist",0,0)
  result = (Encoding *)enclist;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_enc,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_mac_feature_map_set(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat *arg1 = (MacFeat *) 0 ;
  
  SWIG_check_num_args("default_mac_feature_map",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("default_mac_feature_map",1,"MacFeat *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_macfeat,0))){
    SWIG_fail_ptr("default_mac_feature_map_set",1,SWIGTYPE_p_macfeat);
  }
  
  default_mac_feature_map = arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_default_mac_feature_map_get(lua_State* L) {
  int SWIG_arg = 0;
  MacFeat *result = 0 ;
  
  SWIG_check_num_args("default_mac_feature_map",0,0)
  result = (MacFeat *)default_mac_feature_map;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_macfeat,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_major_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::major",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::major",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::major",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_major_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->major = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_major_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::major",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::major",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_major_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->major);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_minor_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::minor",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::minor",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::minor",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_minor_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->minor = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_minor_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::minor",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::minor",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_minor_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->minor);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_library_source_modtime_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  long arg2 ;
  
  SWIG_check_num_args("library_version_configuration::library_source_modtime",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::library_source_modtime",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::library_source_modtime",2,"long");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_library_source_modtime_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  arg2 = (long)lua_tonumber(L, 2);
  if (arg1) (arg1)->library_source_modtime = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_library_source_modtime_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  long result;
  
  SWIG_check_num_args("library_version_configuration::library_source_modtime",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::library_source_modtime",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_library_source_modtime_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (long) ((arg1)->library_source_modtime);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_library_source_modtime_string_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  char *arg2 = (char *) 0 ;
  
  SWIG_check_num_args("library_version_configuration::library_source_modtime_string",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::library_source_modtime_string",1,"struct library_version_configuration *");
  if(!SWIG_lua_isnilstring(L,2)) SWIG_fail_arg("library_version_configuration::library_source_modtime_string",2,"char *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_library_source_modtime_string_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  arg2 = (char *)lua_tostring(L, 2);
  {
    free(arg1->library_source_modtime_string);
    if (arg2) {
      arg1->library_source_modtime_string = (char *) malloc(strlen((const char *)arg2)+1);
      strcpy((char *)arg1->library_source_modtime_string, (const char *)arg2);
    } else {
      arg1->library_source_modtime_string = 0;
    }
  }
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_library_source_modtime_string_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  char *result = 0 ;
  
  SWIG_check_num_args("library_version_configuration::library_source_modtime_string",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::library_source_modtime_string",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_library_source_modtime_string_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (char *) ((arg1)->library_source_modtime_string);
  lua_pushstring(L,(const char *)result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_library_source_versiondate_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  int arg2 ;
  
  SWIG_check_num_args("library_version_configuration::library_source_versiondate",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::library_source_versiondate",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::library_source_versiondate",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_library_source_versiondate_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  if (arg1) (arg1)->library_source_versiondate = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_library_source_versiondate_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  int result;
  
  SWIG_check_num_args("library_version_configuration::library_source_versiondate",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::library_source_versiondate",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_library_source_versiondate_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (int) ((arg1)->library_source_versiondate);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_me_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::sizeof_me",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_me",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::sizeof_me",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_me_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->sizeof_me = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_me_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::sizeof_me",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_me",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_me_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->sizeof_me);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_splinefont_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::sizeof_splinefont",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_splinefont",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::sizeof_splinefont",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_splinefont_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->sizeof_splinefont = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_splinefont_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::sizeof_splinefont",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_splinefont",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_splinefont_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->sizeof_splinefont);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_splinechar_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::sizeof_splinechar",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_splinechar",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::sizeof_splinechar",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_splinechar_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->sizeof_splinechar = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_splinechar_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::sizeof_splinechar",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_splinechar",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_splinechar_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->sizeof_splinechar);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_fvbase_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::sizeof_fvbase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_fvbase",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::sizeof_fvbase",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_fvbase_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->sizeof_fvbase = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_fvbase_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::sizeof_fvbase",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_fvbase",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_fvbase_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->sizeof_fvbase);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_cvbase_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::sizeof_cvbase",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_cvbase",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::sizeof_cvbase",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_cvbase_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->sizeof_cvbase = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_cvbase_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::sizeof_cvbase",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_cvbase",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_cvbase_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->sizeof_cvbase);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_cvcontainer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::sizeof_cvcontainer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_cvcontainer",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::sizeof_cvcontainer",2,"uint16");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_cvcontainer_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint16)lua_tonumber(L, 2);
  if (arg1) (arg1)->sizeof_cvcontainer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_sizeof_cvcontainer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint16 result;
  
  SWIG_check_num_args("library_version_configuration::sizeof_cvcontainer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::sizeof_cvcontainer",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_sizeof_cvcontainer_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint16) ((arg1)->sizeof_cvcontainer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_config_had_devicetables_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::config_had_devicetables",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::config_had_devicetables",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::config_had_devicetables",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_config_had_devicetables_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->config_had_devicetables = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_config_had_devicetables_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("library_version_configuration::config_had_devicetables",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::config_had_devicetables",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_config_had_devicetables_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint8) ((arg1)->config_had_devicetables);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_config_had_multilayer_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::config_had_multilayer",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::config_had_multilayer",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::config_had_multilayer",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_config_had_multilayer_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->config_had_multilayer = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_config_had_multilayer_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("library_version_configuration::config_had_multilayer",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::config_had_multilayer",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_config_had_multilayer_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint8) ((arg1)->config_had_multilayer);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_config_had_python_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::config_had_python",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::config_had_python",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::config_had_python",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_config_had_python_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->config_had_python = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_config_had_python_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("library_version_configuration::config_had_python",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::config_had_python",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_config_had_python_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint8) ((arg1)->config_had_python);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_mba1_set(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 arg2 ;
  
  SWIG_check_num_args("library_version_configuration::mba1",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::mba1",1,"struct library_version_configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("library_version_configuration::mba1",2,"uint8");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_mba1_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  SWIG_contract_assert((lua_tonumber(L,2)>=0),"number must not be negative")
  arg2 = (uint8)lua_tonumber(L, 2);
  if (arg1) (arg1)->mba1 = arg2;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_Library_Version_Configuration_mba1_get(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *arg1 = (struct library_version_configuration *) 0 ;
  uint8 result;
  
  SWIG_check_num_args("library_version_configuration::mba1",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration::mba1",1,"struct library_version_configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("Library_Version_Configuration_mba1_get",1,SWIGTYPE_p_library_version_configuration);
  }
  
  result = (uint8) ((arg1)->mba1);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_Library_Version_Configuration(lua_State* L) {
  int SWIG_arg = 0;
  struct library_version_configuration *result = 0 ;
  
  SWIG_check_num_args("library_version_configuration::library_version_configuration",0,0)
  result = (struct library_version_configuration *)calloc(1, sizeof(struct library_version_configuration));
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_library_version_configuration,1); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static void swig_delete_Library_Version_Configuration(void *obj) {
struct library_version_configuration *arg1 = (struct library_version_configuration *) obj;
free((char *) arg1);
}
static swig_lua_method swig_library_version_configuration_methods[] = {
    {0,0}
};
static swig_lua_attribute swig_library_version_configuration_attributes[] = {
    { "major", _wrap_Library_Version_Configuration_major_get, _wrap_Library_Version_Configuration_major_set},
    { "minor", _wrap_Library_Version_Configuration_minor_get, _wrap_Library_Version_Configuration_minor_set},
    { "library_source_modtime", _wrap_Library_Version_Configuration_library_source_modtime_get, _wrap_Library_Version_Configuration_library_source_modtime_set},
    { "library_source_modtime_string", _wrap_Library_Version_Configuration_library_source_modtime_string_get, _wrap_Library_Version_Configuration_library_source_modtime_string_set},
    { "library_source_versiondate", _wrap_Library_Version_Configuration_library_source_versiondate_get, _wrap_Library_Version_Configuration_library_source_versiondate_set},
    { "sizeof_me", _wrap_Library_Version_Configuration_sizeof_me_get, _wrap_Library_Version_Configuration_sizeof_me_set},
    { "sizeof_splinefont", _wrap_Library_Version_Configuration_sizeof_splinefont_get, _wrap_Library_Version_Configuration_sizeof_splinefont_set},
    { "sizeof_splinechar", _wrap_Library_Version_Configuration_sizeof_splinechar_get, _wrap_Library_Version_Configuration_sizeof_splinechar_set},
    { "sizeof_fvbase", _wrap_Library_Version_Configuration_sizeof_fvbase_get, _wrap_Library_Version_Configuration_sizeof_fvbase_set},
    { "sizeof_cvbase", _wrap_Library_Version_Configuration_sizeof_cvbase_get, _wrap_Library_Version_Configuration_sizeof_cvbase_set},
    { "sizeof_cvcontainer", _wrap_Library_Version_Configuration_sizeof_cvcontainer_get, _wrap_Library_Version_Configuration_sizeof_cvcontainer_set},
    { "config_had_devicetables", _wrap_Library_Version_Configuration_config_had_devicetables_get, _wrap_Library_Version_Configuration_config_had_devicetables_set},
    { "config_had_multilayer", _wrap_Library_Version_Configuration_config_had_multilayer_get, _wrap_Library_Version_Configuration_config_had_multilayer_set},
    { "config_had_python", _wrap_Library_Version_Configuration_config_had_python_get, _wrap_Library_Version_Configuration_config_had_python_set},
    { "mba1", _wrap_Library_Version_Configuration_mba1_get, _wrap_Library_Version_Configuration_mba1_set},
    {0,0,0}
};
static swig_lua_class *swig_library_version_configuration_bases[] = {0};
static const char *swig_library_version_configuration_base_names[] = {0};
static swig_lua_class _wrap_class_library_version_configuration = { "Library_Version_Configuration", &SWIGTYPE_p_library_version_configuration,_wrap_new_Library_Version_Configuration, swig_delete_Library_Version_Configuration, swig_library_version_configuration_methods, swig_library_version_configuration_attributes, swig_library_version_configuration_bases, swig_library_version_configuration_base_names };

static int _wrap_library_version_configuration_set(lua_State* L) {
  int SWIG_arg = 0;
  Library_Version_Configuration *arg1 = (Library_Version_Configuration *) 0 ;
  
  SWIG_check_num_args("library_version_configuration",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("library_version_configuration",1,"Library_Version_Configuration *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("library_version_configuration_set",1,SWIGTYPE_p_library_version_configuration);
  }
  
  library_version_configuration = *arg1;
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_library_version_configuration_get(lua_State* L) {
  int SWIG_arg = 0;
  Library_Version_Configuration *result = 0 ;
  
  SWIG_check_num_args("library_version_configuration",0,0)
  result = (Library_Version_Configuration *)&library_version_configuration;
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_library_version_configuration,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_check_library_version(lua_State* L) {
  int SWIG_arg = 0;
  Library_Version_Configuration *arg1 = (Library_Version_Configuration *) 0 ;
  int arg2 ;
  int arg3 ;
  int result;
  
  SWIG_check_num_args("check_library_version",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("check_library_version",1,"Library_Version_Configuration *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("check_library_version",2,"int");
  if(!lua_isnumber(L,3)) SWIG_fail_arg("check_library_version",3,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_library_version_configuration,0))){
    SWIG_fail_ptr("check_library_version",1,SWIGTYPE_p_library_version_configuration);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  arg3 = (int)lua_tonumber(L, 3);
  result = (int)check_library_version(arg1,arg2,arg3);
  lua_pushnumber(L, (lua_Number) result); SWIG_arg++;
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineCharArray(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  SplineChar **result = 0 ;
  
  SWIG_check_num_args("new_SplineCharArray",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("new_SplineCharArray",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (SplineChar **)new_SplineCharArray(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_SplineCharArray(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar **arg1 = (SplineChar **) 0 ;
  
  SWIG_check_num_args("delete_SplineCharArray",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("delete_SplineCharArray",1,"SplineChar **");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_splinechar,0))){
    SWIG_fail_ptr("delete_SplineCharArray",1,SWIGTYPE_p_p_splinechar);
  }
  
  delete_SplineCharArray(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharArray_getitem(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar **arg1 = (SplineChar **) 0 ;
  int arg2 ;
  SplineChar *result = 0 ;
  
  SWIG_check_num_args("SplineCharArray_getitem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharArray_getitem",1,"SplineChar **");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharArray_getitem",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharArray_getitem",1,SWIGTYPE_p_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = (SplineChar *)SplineCharArray_getitem(arg1,arg2);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinechar,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineCharArray_setitem(lua_State* L) {
  int SWIG_arg = 0;
  SplineChar **arg1 = (SplineChar **) 0 ;
  int arg2 ;
  SplineChar *arg3 = (SplineChar *) 0 ;
  
  SWIG_check_num_args("SplineCharArray_setitem",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineCharArray_setitem",1,"SplineChar **");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineCharArray_setitem",2,"int");
  if(!SWIG_isptrtype(L,3)) SWIG_fail_arg("SplineCharArray_setitem",3,"SplineChar *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharArray_setitem",1,SWIGTYPE_p_p_splinechar);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&arg3,SWIGTYPE_p_splinechar,0))){
    SWIG_fail_ptr("SplineCharArray_setitem",3,SWIGTYPE_p_splinechar);
  }
  
  SplineCharArray_setitem(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LayerArray(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  Layer *result = 0 ;
  
  SWIG_check_num_args("new_LayerArray",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("new_LayerArray",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (Layer *)new_LayerArray(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_layer,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_LayerArray(lua_State* L) {
  int SWIG_arg = 0;
  Layer *arg1 = (Layer *) 0 ;
  
  SWIG_check_num_args("delete_LayerArray",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("delete_LayerArray",1,"Layer *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("delete_LayerArray",1,SWIGTYPE_p_layer);
  }
  
  delete_LayerArray(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerArray_getitem(lua_State* L) {
  int SWIG_arg = 0;
  Layer *arg1 = (Layer *) 0 ;
  int arg2 ;
  Layer result;
  
  SWIG_check_num_args("LayerArray_getitem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerArray_getitem",1,"Layer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("LayerArray_getitem",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayerArray_getitem",1,SWIGTYPE_p_layer);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = LayerArray_getitem(arg1,arg2);
  {
    Layer * resultptr;
    resultptr = (Layer *) malloc(sizeof(Layer));
    memmove(resultptr, &result, sizeof(Layer));
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_layer,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerArray_setitem(lua_State* L) {
  int SWIG_arg = 0;
  Layer *arg1 = (Layer *) 0 ;
  int arg2 ;
  Layer arg3 ;
  Layer *argp3 ;
  
  SWIG_check_num_args("LayerArray_setitem",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerArray_setitem",1,"Layer *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("LayerArray_setitem",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("LayerArray_setitem",3,"Layer");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayerArray_setitem",1,SWIGTYPE_p_layer);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_layer,0))){
    SWIG_fail_ptr("LayerArray_setitem",3,SWIGTYPE_p_layer);
  }
  arg3 = *argp3;
  
  LayerArray_setitem(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_LayerInfoArray(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  LayerInfo *result = 0 ;
  
  SWIG_check_num_args("new_LayerInfoArray",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("new_LayerInfoArray",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (LayerInfo *)new_LayerInfoArray(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_layerinfo,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_LayerInfoArray(lua_State* L) {
  int SWIG_arg = 0;
  LayerInfo *arg1 = (LayerInfo *) 0 ;
  
  SWIG_check_num_args("delete_LayerInfoArray",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("delete_LayerInfoArray",1,"LayerInfo *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("delete_LayerInfoArray",1,SWIGTYPE_p_layerinfo);
  }
  
  delete_LayerInfoArray(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfoArray_getitem(lua_State* L) {
  int SWIG_arg = 0;
  LayerInfo *arg1 = (LayerInfo *) 0 ;
  int arg2 ;
  LayerInfo result;
  
  SWIG_check_num_args("LayerInfoArray_getitem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerInfoArray_getitem",1,"LayerInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("LayerInfoArray_getitem",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfoArray_getitem",1,SWIGTYPE_p_layerinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = LayerInfoArray_getitem(arg1,arg2);
  {
    LayerInfo * resultptr;
    resultptr = (LayerInfo *) malloc(sizeof(LayerInfo));
    memmove(resultptr, &result, sizeof(LayerInfo));
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_layerinfo,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_LayerInfoArray_setitem(lua_State* L) {
  int SWIG_arg = 0;
  LayerInfo *arg1 = (LayerInfo *) 0 ;
  int arg2 ;
  LayerInfo arg3 ;
  LayerInfo *argp3 ;
  
  SWIG_check_num_args("LayerInfoArray_setitem",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("LayerInfoArray_setitem",1,"LayerInfo *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("LayerInfoArray_setitem",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("LayerInfoArray_setitem",3,"LayerInfo");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfoArray_setitem",1,SWIGTYPE_p_layerinfo);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_layerinfo,0))){
    SWIG_fail_ptr("LayerInfoArray_setitem",3,SWIGTYPE_p_layerinfo);
  }
  arg3 = *argp3;
  
  LayerInfoArray_setitem(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplinePointListArray(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  SplinePointList *result = 0 ;
  
  SWIG_check_num_args("new_SplinePointListArray",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("new_SplinePointListArray",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (SplinePointList *)new_SplinePointListArray(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_splinepointlist,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_SplinePointListArray(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  
  SWIG_check_num_args("delete_SplinePointListArray",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("delete_SplinePointListArray",1,"SplinePointList *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("delete_SplinePointListArray",1,SWIGTYPE_p_splinepointlist);
  }
  
  delete_SplinePointListArray(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListArray_getitem(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  int arg2 ;
  SplinePointList result;
  
  SWIG_check_num_args("SplinePointListArray_getitem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListArray_getitem",1,"SplinePointList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplinePointListArray_getitem",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListArray_getitem",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = SplinePointListArray_getitem(arg1,arg2);
  {
    SplinePointList * resultptr;
    resultptr = (SplinePointList *) malloc(sizeof(SplinePointList));
    memmove(resultptr, &result, sizeof(SplinePointList));
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_splinepointlist,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplinePointListArray_setitem(lua_State* L) {
  int SWIG_arg = 0;
  SplinePointList *arg1 = (SplinePointList *) 0 ;
  int arg2 ;
  SplinePointList arg3 ;
  SplinePointList *argp3 ;
  
  SWIG_check_num_args("SplinePointListArray_setitem",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplinePointListArray_setitem",1,"SplinePointList *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplinePointListArray_setitem",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("SplinePointListArray_setitem",3,"SplinePointList");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListArray_setitem",1,SWIGTYPE_p_splinepointlist);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_splinepointlist,0))){
    SWIG_fail_ptr("SplinePointListArray_setitem",3,SWIGTYPE_p_splinepointlist);
  }
  arg3 = *argp3;
  
  SplinePointListArray_setitem(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_new_SplineArray(lua_State* L) {
  int SWIG_arg = 0;
  int arg1 ;
  Spline *result = 0 ;
  
  SWIG_check_num_args("new_SplineArray",1,1)
  if(!lua_isnumber(L,1)) SWIG_fail_arg("new_SplineArray",1,"int");
  arg1 = (int)lua_tonumber(L, 1);
  result = (Spline *)new_SplineArray(arg1);
  SWIG_NewPointerObj(L,result,SWIGTYPE_p_spline,0); SWIG_arg++; 
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_delete_SplineArray(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  
  SWIG_check_num_args("delete_SplineArray",1,1)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("delete_SplineArray",1,"Spline *");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("delete_SplineArray",1,SWIGTYPE_p_spline);
  }
  
  delete_SplineArray(arg1);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineArray_getitem(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  int arg2 ;
  Spline result;
  
  SWIG_check_num_args("SplineArray_getitem",2,2)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineArray_getitem",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineArray_getitem",2,"int");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineArray_getitem",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  result = SplineArray_getitem(arg1,arg2);
  {
    Spline * resultptr;
    resultptr = (Spline *) malloc(sizeof(Spline));
    memmove(resultptr, &result, sizeof(Spline));
    SWIG_NewPointerObj(L,(void *) resultptr,SWIGTYPE_p_spline,1); SWIG_arg++;
  }
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


static int _wrap_SplineArray_setitem(lua_State* L) {
  int SWIG_arg = 0;
  Spline *arg1 = (Spline *) 0 ;
  int arg2 ;
  Spline arg3 ;
  Spline *argp3 ;
  
  SWIG_check_num_args("SplineArray_setitem",3,3)
  if(!SWIG_isptrtype(L,1)) SWIG_fail_arg("SplineArray_setitem",1,"Spline *");
  if(!lua_isnumber(L,2)) SWIG_fail_arg("SplineArray_setitem",2,"int");
  if(!lua_isuserdata(L,3)) SWIG_fail_arg("SplineArray_setitem",3,"Spline");
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,1,(void**)&arg1,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineArray_setitem",1,SWIGTYPE_p_spline);
  }
  
  arg2 = (int)lua_tonumber(L, 2);
  
  if (!SWIG_IsOK(SWIG_ConvertPtr(L,3,(void**)&argp3,SWIGTYPE_p_spline,0))){
    SWIG_fail_ptr("SplineArray_setitem",3,SWIGTYPE_p_spline);
  }
  arg3 = *argp3;
  
  SplineArray_setitem(arg1,arg2,arg3);
  
  return SWIG_arg;
  
  if(0) SWIG_fail;
  
fail:
  lua_error(L);
  return SWIG_arg;
}


#ifdef __cplusplus
}
#endif

static const struct luaL_Reg swig_commands[] = {
    { "galloc", _wrap_galloc},
    { "gcalloc", _wrap_gcalloc},
    { "grealloc", _wrap_grealloc},
    { "gfree", _wrap_gfree},
    { "galloc_set_trap", _wrap_galloc_set_trap},
    { "chunkalloc", _wrap_chunkalloc},
    { "chunkfree", _wrap_chunkfree},
    { "strconcat", _wrap_strconcat},
    { "strconcat3", _wrap_strconcat3},
    { "XUIDFromFD", _wrap_XUIDFromFD},
    { "SplineFontFromPSFont", _wrap_SplineFontFromPSFont},
    { "CheckAfmOfPostScript", _wrap_CheckAfmOfPostScript},
    { "LoadKerningDataFromAmfm", _wrap_LoadKerningDataFromAmfm},
    { "LoadKerningDataFromAfm", _wrap_LoadKerningDataFromAfm},
    { "LoadKerningDataFromTfm", _wrap_LoadKerningDataFromTfm},
    { "LoadKerningDataFromOfm", _wrap_LoadKerningDataFromOfm},
    { "LoadKerningDataFromPfm", _wrap_LoadKerningDataFromPfm},
    { "LoadKerningDataFromMacFOND", _wrap_LoadKerningDataFromMacFOND},
    { "LoadKerningDataFromMetricsFile", _wrap_LoadKerningDataFromMetricsFile},
    { "FeatDumpFontLookups", _wrap_FeatDumpFontLookups},
    { "FeatDumpOneLookup", _wrap_FeatDumpOneLookup},
    { "SFApplyFeatureFile", _wrap_SFApplyFeatureFile},
    { "SFApplyFeatureFilename", _wrap_SFApplyFeatureFilename},
    { "SubsNew", _wrap_SubsNew},
    { "PosNew", _wrap_PosNew},
    { "SFOneWidth", _wrap_SFOneWidth},
    { "CIDOneWidth", _wrap_CIDOneWidth},
    { "SFOneHeight", _wrap_SFOneHeight},
    { "SFIsCJK", _wrap_SFIsCJK},
    { "CIDMasterAsDes", _wrap_CIDMasterAsDes},
    { "CanWoff", _wrap_CanWoff},
    { "SplineFont2ChrsSubrs", _wrap_SplineFont2ChrsSubrs},
    { "CanonicalCombiner", _wrap_CanonicalCombiner},
    { "GrowBuffer", _wrap_GrowBuffer},
    { "GrowBufferAdd", _wrap_GrowBufferAdd},
    { "GrowBufferAddStr", _wrap_GrowBufferAddStr},
    { "UnitsParallel", _wrap_UnitsParallel},
    { "CvtPsStem3", _wrap_CvtPsStem3},
    { "CID2ChrsSubrs", _wrap_CID2ChrsSubrs},
    { "SplineFont2ChrsSubrs2", _wrap_SplineFont2ChrsSubrs2},
    { "CID2ChrsSubrs2", _wrap_CID2ChrsSubrs2},
    { "filechecksum", _wrap_filechecksum},
    { "GetAuthor", _wrap_GetAuthor},
    { "SFFindExistingCharMac", _wrap_SFFindExistingCharMac},
    { "SC_PSDump", _wrap_SC_PSDump},
    { "_WritePSFont", _wrap__WritePSFont},
    { "WritePSFont", _wrap_WritePSFont},
    { "WriteMacPSFont", _wrap_WriteMacPSFont},
    { "_WriteWOFFFont", _wrap__WriteWOFFFont},
    { "WriteWOFFFont", _wrap_WriteWOFFFont},
    { "_WriteTTFFont", _wrap__WriteTTFFont},
    { "WriteTTFFont", _wrap_WriteTTFFont},
    { "_WriteType42SFNTS", _wrap__WriteType42SFNTS},
    { "WriteMacTTFFont", _wrap_WriteMacTTFFont},
    { "WriteMacBitmaps", _wrap_WriteMacBitmaps},
    { "WritePalmBitmaps", _wrap_WritePalmBitmaps},
    { "WriteMacFamily", _wrap_WriteMacFamily},
    { "WriteTTC", _wrap_WriteTTC},
    { "mactime", _wrap_mactime},
    { "WriteSVGFont", _wrap_WriteSVGFont},
    { "_WriteSVGFont", _wrap__WriteSVGFont},
    { "WriteUFOFont", _wrap_WriteUFOFont},
    { "SfListFree", _wrap_SfListFree},
    { "TTF_PSDupsDefault", _wrap_TTF_PSDupsDefault},
    { "DefaultTTFEnglishNames", _wrap_DefaultTTFEnglishNames},
    { "TeXDefaultParams", _wrap_TeXDefaultParams},
    { "AlreadyMSSymbolArea", _wrap_AlreadyMSSymbolArea},
    { "OS2FigureCodePages", _wrap_OS2FigureCodePages},
    { "OS2FigureUnicodeRanges", _wrap_OS2FigureUnicodeRanges},
    { "SFDefaultOS2Info", _wrap_SFDefaultOS2Info},
    { "SFDefaultOS2Simple", _wrap_SFDefaultOS2Simple},
    { "SFDefaultOS2SubSuper", _wrap_SFDefaultOS2SubSuper},
    { "ScriptIsRightToLeft", _wrap_ScriptIsRightToLeft},
    { "ScriptMainRange", _wrap_ScriptMainRange},
    { "ScriptFromUnicode", _wrap_ScriptFromUnicode},
    { "SCScriptFromUnicode", _wrap_SCScriptFromUnicode},
    { "SCRightToLeft", _wrap_SCRightToLeft},
    { "SFForceEncoding", _wrap_SFForceEncoding},
    { "CountOfEncoding", _wrap_CountOfEncoding},
    { "SFMatchGlyphs", _wrap_SFMatchGlyphs},
    { "MMMatchGlyphs", _wrap_MMMatchGlyphs},
    { "_GetModifiers", _wrap__GetModifiers},
    { "SFGetModifiers", _wrap_SFGetModifiers},
    { "_uGetModifiers", _wrap__uGetModifiers},
    { "SFSetFontName", _wrap_SFSetFontName},
    { "ttfdumpbitmap", _wrap_ttfdumpbitmap},
    { "ttfdumpbitmapscaling", _wrap_ttfdumpbitmapscaling},
    { "SplineFontSetUnChanged", _wrap_SplineFontSetUnChanged},
    { "Within4RoundingErrors", _wrap_Within4RoundingErrors},
    { "Within16RoundingErrors", _wrap_Within16RoundingErrors},
    { "Within64RoundingErrors", _wrap_Within64RoundingErrors},
    { "RealNear", _wrap_RealNear},
    { "RealNearish", _wrap_RealNearish},
    { "RealApprox", _wrap_RealApprox},
    { "RealWithin", _wrap_RealWithin},
    { "RealRatio", _wrap_RealRatio},
    { "PointsDiagonalable", _wrap_PointsDiagonalable},
    { "MergeDStemInfo", _wrap_MergeDStemInfo},
    { "LineListFree", _wrap_LineListFree},
    { "LinearApproxFree", _wrap_LinearApproxFree},
    { "SplineFree", _wrap_SplineFree},
    { "SplinePointCreate", _wrap_SplinePointCreate},
    { "SplinePointFree", _wrap_SplinePointFree},
    { "SplinePointMDFree", _wrap_SplinePointMDFree},
    { "SplinePointsFree", _wrap_SplinePointsFree},
    { "SplinePointListFree", _wrap_SplinePointListFree},
    { "SplinePointListMDFree", _wrap_SplinePointListMDFree},
    { "SplinePointListsMDFree", _wrap_SplinePointListsMDFree},
    { "SplinePointListsFree", _wrap_SplinePointListsFree},
    { "SplineSetSpirosClear", _wrap_SplineSetSpirosClear},
    { "SplineSetBeziersClear", _wrap_SplineSetBeziersClear},
    { "RefCharFree", _wrap_RefCharFree},
    { "RefCharsFree", _wrap_RefCharsFree},
    { "RefCharsFreeRef", _wrap_RefCharsFreeRef},
    { "CopyBufferFree", _wrap_CopyBufferFree},
    { "CopyBufferClearCopiedFrom", _wrap_CopyBufferClearCopiedFrom},
    { "UndoesFree", _wrap_UndoesFree},
    { "StemInfosFree", _wrap_StemInfosFree},
    { "StemInfoFree", _wrap_StemInfoFree},
    { "DStemInfosFree", _wrap_DStemInfosFree},
    { "DStemInfoFree", _wrap_DStemInfoFree},
    { "KernPairsFree", _wrap_KernPairsFree},
    { "SCOrderAP", _wrap_SCOrderAP},
    { "AnchorPointsFree", _wrap_AnchorPointsFree},
    { "AnchorPointsCopy", _wrap_AnchorPointsCopy},
    { "SFRemoveAnchorClass", _wrap_SFRemoveAnchorClass},
    { "IsAnchorClassUsed", _wrap_IsAnchorClassUsed},
    { "APAnchorClassMerge", _wrap_APAnchorClassMerge},
    { "AnchorClassMerge", _wrap_AnchorClassMerge},
    { "AnchorClassesFree", _wrap_AnchorClassesFree},
    { "TtfTablesFree", _wrap_TtfTablesFree},
    { "SFRemoveSavedTable", _wrap_SFRemoveSavedTable},
    { "AnchorClassMatch", _wrap_AnchorClassMatch},
    { "AnchorClassMkMkMatch", _wrap_AnchorClassMkMkMatch},
    { "AnchorClassCursMatch", _wrap_AnchorClassCursMatch},
    { "PSTFree", _wrap_PSTFree},
    { "PSTContains", _wrap_PSTContains},
    { "StemInfoCopy", _wrap_StemInfoCopy},
    { "DStemInfoCopy", _wrap_DStemInfoCopy},
    { "MinimumDistanceCopy", _wrap_MinimumDistanceCopy},
    { "SPChangePointType", _wrap_SPChangePointType},
    { "PSTCopy", _wrap_PSTCopy},
    { "MCConvertSubtable", _wrap_MCConvertSubtable},
    { "MCConvertAnchorClass", _wrap_MCConvertAnchorClass},
    { "SFFinishMergeContext", _wrap_SFFinishMergeContext},
    { "SplineCharCopy", _wrap_SplineCharCopy},
    { "BDFCharCopy", _wrap_BDFCharCopy},
    { "BCFlattenFloat", _wrap_BCFlattenFloat},
    { "BitmapsCopy", _wrap_BitmapsCopy},
    { "ImageAlterClut", _wrap_ImageAlterClut},
    { "ImageListsFree", _wrap_ImageListsFree},
    { "TTFLangNamesFree", _wrap_TTFLangNamesFree},
    { "AltUniFree", _wrap_AltUniFree},
    { "AltUniFigure", _wrap_AltUniFigure},
    { "AltUniRemove", _wrap_AltUniRemove},
    { "AltUniAdd", _wrap_AltUniAdd},
    { "AltUniAdd_DontCheckDups", _wrap_AltUniAdd_DontCheckDups},
    { "MinimumDistancesFree", _wrap_MinimumDistancesFree},
    { "LayerDefault", _wrap_LayerDefault},
    { "SplineCharCreate", _wrap_SplineCharCreate},
    { "SFSplineCharCreate", _wrap_SFSplineCharCreate},
    { "RefCharCreate", _wrap_RefCharCreate},
    { "RefCharsCopy", _wrap_RefCharsCopy},
    { "AltUniCopy", _wrap_AltUniCopy},
    { "SCAddRef", _wrap_SCAddRef},
    { "_SCAddRef", _wrap__SCAddRef},
    { "KernClassCopy", _wrap_KernClassCopy},
    { "KernClassFreeContents", _wrap_KernClassFreeContents},
    { "KernClassListFree", _wrap_KernClassListFree},
    { "KernClassContains", _wrap_KernClassContains},
    { "OTLookupFree", _wrap_OTLookupFree},
    { "OTLookupListFree", _wrap_OTLookupListFree},
    { "FPSTCopy", _wrap_FPSTCopy},
    { "FPSTRuleContentsFree", _wrap_FPSTRuleContentsFree},
    { "FPSTClassesFree", _wrap_FPSTClassesFree},
    { "FPSTRulesFree", _wrap_FPSTRulesFree},
    { "FPSTFree", _wrap_FPSTFree},
    { "ASMFree", _wrap_ASMFree},
    { "MacNameCopy", _wrap_MacNameCopy},
    { "MacNameListFree", _wrap_MacNameListFree},
    { "MacSettingListFree", _wrap_MacSettingListFree},
    { "MacFeatListFree", _wrap_MacFeatListFree},
    { "GlyphVariantsFree", _wrap_GlyphVariantsFree},
    { "GlyphVariantsCopy", _wrap_GlyphVariantsCopy},
    { "MathKernVContentsFree", _wrap_MathKernVContentsFree},
    { "MathKernFree", _wrap_MathKernFree},
    { "MathKernCopy", _wrap_MathKernCopy},
    { "SplineCharListsFree", _wrap_SplineCharListsFree},
    { "LayerFreeContents", _wrap_LayerFreeContents},
    { "SplineCharFreeContents", _wrap_SplineCharFreeContents},
    { "SplineCharFree", _wrap_SplineCharFree},
    { "EncMapFree", _wrap_EncMapFree},
    { "EncMapFromEncoding", _wrap_EncMapFromEncoding},
    { "CompactEncMap", _wrap_CompactEncMap},
    { "EncMapNew", _wrap_EncMapNew},
    { "EncMap1to1", _wrap_EncMap1to1},
    { "EncMapCopy", _wrap_EncMapCopy},
    { "SFExpandGlyphCount", _wrap_SFExpandGlyphCount},
    { "ScriptLangListFree", _wrap_ScriptLangListFree},
    { "FeatureScriptLangListFree", _wrap_FeatureScriptLangListFree},
    { "SFBaseSort", _wrap_SFBaseSort},
    { "BaseLangCopy", _wrap_BaseLangCopy},
    { "BaseLangFree", _wrap_BaseLangFree},
    { "BaseScriptFree", _wrap_BaseScriptFree},
    { "BaseFree", _wrap_BaseFree},
    { "SplineFontFree", _wrap_SplineFontFree},
    { "JstfLangsCopy", _wrap_JstfLangsCopy},
    { "JstfLangFree", _wrap_JstfLangFree},
    { "JustifyFree", _wrap_JustifyFree},
    { "MATHFree", _wrap_MATHFree},
    { "MathTableNew", _wrap_MathTableNew},
    { "OtfNameListFree", _wrap_OtfNameListFree},
    { "OtfFeatNameListFree", _wrap_OtfFeatNameListFree},
    { "findotffeatname", _wrap_findotffeatname},
    { "MarkSetFree", _wrap_MarkSetFree},
    { "MarkClassFree", _wrap_MarkClassFree},
    { "MMSetFreeContents", _wrap_MMSetFreeContents},
    { "MMSetFree", _wrap_MMSetFree},
    { "SFRemoveUndoes", _wrap_SFRemoveUndoes},
    { "SplineRefigure3", _wrap_SplineRefigure3},
    { "SplineRefigure", _wrap_SplineRefigure},
    { "SplineMake3", _wrap_SplineMake3},
    { "SplineApproximate", _wrap_SplineApproximate},
    { "SplinePointListIsClockwise", _wrap_SplinePointListIsClockwise},
    { "SplineSetFindBounds", _wrap_SplineSetFindBounds},
    { "SplineCharLayerFindBounds", _wrap_SplineCharLayerFindBounds},
    { "SplineCharFindBounds", _wrap_SplineCharFindBounds},
    { "SplineFontLayerFindBounds", _wrap_SplineFontLayerFindBounds},
    { "SplineFontFindBounds", _wrap_SplineFontFindBounds},
    { "CIDLayerFindBounds", _wrap_CIDLayerFindBounds},
    { "SplineSetQuickBounds", _wrap_SplineSetQuickBounds},
    { "SplineCharLayerQuickBounds", _wrap_SplineCharLayerQuickBounds},
    { "SplineCharQuickBounds", _wrap_SplineCharQuickBounds},
    { "SplineSetQuickConservativeBounds", _wrap_SplineSetQuickConservativeBounds},
    { "SplineCharQuickConservativeBounds", _wrap_SplineCharQuickConservativeBounds},
    { "SplineFontQuickConservativeBounds", _wrap_SplineFontQuickConservativeBounds},
    { "SplinePointCatagorize", _wrap_SplinePointCatagorize},
    { "SplinePointIsACorner", _wrap_SplinePointIsACorner},
    { "SPLCatagorizePoints", _wrap_SPLCatagorizePoints},
    { "SCCatagorizePoints", _wrap_SCCatagorizePoints},
    { "SplinePointListCopy1", _wrap_SplinePointListCopy1},
    { "SplinePointListCopy", _wrap_SplinePointListCopy},
    { "SplinePointListCopySelected", _wrap_SplinePointListCopySelected},
    { "SplinePointListCopySpiroSelected", _wrap_SplinePointListCopySpiroSelected},
    { "ImageListCopy", _wrap_ImageListCopy},
    { "ImageListTransform", _wrap_ImageListTransform},
    { "BpTransform", _wrap_BpTransform},
    { "ApTransform", _wrap_ApTransform},
    { "SplinePointListTransform", _wrap_SplinePointListTransform},
    { "SplinePointListSpiroTransform", _wrap_SplinePointListSpiroTransform},
    { "SplinePointListShift", _wrap_SplinePointListShift},
    { "HintMaskFromTransformedRef", _wrap_HintMaskFromTransformedRef},
    { "SPLCopyTranslatedHintMasks", _wrap_SPLCopyTranslatedHintMasks},
    { "SPLCopyTransformedHintMasks", _wrap_SPLCopyTransformedHintMasks},
    { "SplinePointListRemoveSelected", _wrap_SplinePointListRemoveSelected},
    { "SplinePointListSet", _wrap_SplinePointListSet},
    { "SplinePointListSelect", _wrap_SplinePointListSelect},
    { "SCRefToSplines", _wrap_SCRefToSplines},
    { "RefCharFindBounds", _wrap_RefCharFindBounds},
    { "SCReinstanciateRefChar", _wrap_SCReinstanciateRefChar},
    { "SCReinstanciateRef", _wrap_SCReinstanciateRef},
    { "SFReinstanciateRefs", _wrap_SFReinstanciateRefs},
    { "SFInstanciateRefs", _wrap_SFInstanciateRefs},
    { "SCRemoveDependent", _wrap_SCRemoveDependent},
    { "SCRemoveLayerDependents", _wrap_SCRemoveLayerDependents},
    { "SCRemoveDependents", _wrap_SCRemoveDependents},
    { "SCDependsOnSC", _wrap_SCDependsOnSC},
    { "BCCompressBitmap", _wrap_BCCompressBitmap},
    { "BCRegularizeBitmap", _wrap_BCRegularizeBitmap},
    { "BCRegularizeGreymap", _wrap_BCRegularizeGreymap},
    { "BCPasteInto", _wrap_BCPasteInto},
    { "BCRotateCharForVert", _wrap_BCRotateCharForVert},
    { "SplineCharRasterize", _wrap_SplineCharRasterize},
    { "SplineFontToBDFHeader", _wrap_SplineFontToBDFHeader},
    { "SplineFontRasterize", _wrap_SplineFontRasterize},
    { "BDFCAntiAlias", _wrap_BDFCAntiAlias},
    { "SplineCharAntiAlias", _wrap_SplineCharAntiAlias},
    { "SplineFontAntiAlias", _wrap_SplineFontAntiAlias},
    { "_BDFClut", _wrap__BDFClut},
    { "BDFClut", _wrap_BDFClut},
    { "BDFDepth", _wrap_BDFDepth},
    { "BDFPieceMeal", _wrap_BDFPieceMeal},
    { "BDFPieceMealCheck", _wrap_BDFPieceMealCheck},
    { "SplineFontPieceMeal", _wrap_SplineFontPieceMeal},
    { "BDFCharFindBounds", _wrap_BDFCharFindBounds},
    { "BDFCharQuickBounds", _wrap_BDFCharQuickBounds},
    { "BCPrepareForOutput", _wrap_BCPrepareForOutput},
    { "BCRestoreAfterOutput", _wrap_BCRestoreAfterOutput},
    { "BCMakeDependent", _wrap_BCMakeDependent},
    { "BCRemoveDependent", _wrap_BCRemoveDependent},
    { "BCExpandBitmapToEmBox", _wrap_BCExpandBitmapToEmBox},
    { "BitmapFontScaleTo", _wrap_BitmapFontScaleTo},
    { "BDFCharFree", _wrap_BDFCharFree},
    { "BDFPropsFree", _wrap_BDFPropsFree},
    { "BDFFontFree", _wrap_BDFFontFree},
    { "SFDefaultAscent", _wrap_SFDefaultAscent},
    { "PSBitmapDump", _wrap_PSBitmapDump},
    { "BDFFontDump", _wrap_BDFFontDump},
    { "FNTFontDump", _wrap_FNTFontDump},
    { "FONFontDump", _wrap_FONFontDump},
    { "SFReplaceEncodingBDFProps", _wrap_SFReplaceEncodingBDFProps},
    { "SFReplaceFontnameBDFProps", _wrap_SFReplaceFontnameBDFProps},
    { "IsUnsignedBDFKey", _wrap_IsUnsignedBDFKey},
    { "BdfPropHasInt", _wrap_BdfPropHasInt},
    { "BdfPropHasString", _wrap_BdfPropHasString},
    { "def_Charset_Enc", _wrap_def_Charset_Enc},
    { "Default_XLFD", _wrap_Default_XLFD},
    { "Default_Properties", _wrap_Default_Properties},
    { "BDFDefaultProps", _wrap_BDFDefaultProps},
    { "BdfPropsCopy", _wrap_BdfPropsCopy},
    { "XLFD_GetComponents", _wrap_XLFD_GetComponents},
    { "XLFD_CreateComponents", _wrap_XLFD_CreateComponents},
    { "SplinesIntersect", _wrap_SplinesIntersect},
    { "LayerAllSplines", _wrap_LayerAllSplines},
    { "LayerUnAllSplines", _wrap_LayerUnAllSplines},
    { "SplineSetIntersect", _wrap_SplineSetIntersect},
    { "LineTangentToSplineThroughPt", _wrap_LineTangentToSplineThroughPt},
    { "_CubicSolve", _wrap__CubicSolve},
    { "CubicSolve", _wrap_CubicSolve},
    { "SplineSolve", _wrap_SplineSolve},
    { "SplineSolveFixup", _wrap_SplineSolveFixup},
    { "IterateSplineSolve", _wrap_IterateSplineSolve},
    { "IterateSplineSolveFixup", _wrap_IterateSplineSolveFixup},
    { "SplineFindExtrema", _wrap_SplineFindExtrema},
    { "SSBoundsWithin", _wrap_SSBoundsWithin},
    { "SplineMinDistanceToPoint", _wrap_SplineMinDistanceToPoint},
    { "SplineSetsInterpolate", _wrap_SplineSetsInterpolate},
    { "SplineCharInterpolate", _wrap_SplineCharInterpolate},
    { "InterpolateFont", _wrap_InterpolateFont},
    { "SFSerifHeight", _wrap_SFSerifHeight},
    { "DumpPfaEditEncodings", _wrap_DumpPfaEditEncodings},
    { "ParseEncodingFile", _wrap_ParseEncodingFile},
    { "LoadPfaEditEncodings", _wrap_LoadPfaEditEncodings},
    { "GenerateScript", _wrap_GenerateScript},
    { "_SCAutoTrace", _wrap__SCAutoTrace},
    { "AutoTraceArgs", _wrap_AutoTraceArgs},
    { "SplineCurvature", _wrap_SplineCurvature},
    { "CheckExtremaForSingleBitErrors", _wrap_CheckExtremaForSingleBitErrors},
    { "Spline2DFindExtrema", _wrap_Spline2DFindExtrema},
    { "Spline2DFindPointsOfInflection", _wrap_Spline2DFindPointsOfInflection},
    { "SplineAtInflection", _wrap_SplineAtInflection},
    { "SplineAtMinMax", _wrap_SplineAtMinMax},
    { "SplineRemoveExtremaTooClose", _wrap_SplineRemoveExtremaTooClose},
    { "NearSpline", _wrap_NearSpline},
    { "SplineNearPoint", _wrap_SplineNearPoint},
    { "SplineT2SpiroIndex", _wrap_SplineT2SpiroIndex},
    { "SCMakeDependent", _wrap_SCMakeDependent},
    { "SplineBisect", _wrap_SplineBisect},
    { "SplineSplit", _wrap_SplineSplit},
    { "ApproximateSplineFromPoints", _wrap_ApproximateSplineFromPoints},
    { "ApproximateSplineFromPointsSlopes", _wrap_ApproximateSplineFromPointsSlopes},
    { "SplineLength", _wrap_SplineLength},
    { "SplineLengthRange", _wrap_SplineLengthRange},
    { "PathLength", _wrap_PathLength},
    { "PathFindDistance", _wrap_PathFindDistance},
    { "SplineSetBindToPath", _wrap_SplineSetBindToPath},
    { "SplineIsLinear", _wrap_SplineIsLinear},
    { "SplineIsLinearMake", _wrap_SplineIsLinearMake},
    { "SplineInSplineSet", _wrap_SplineInSplineSet},
    { "SSPointWithin", _wrap_SSPointWithin},
    { "SSRemoveZeroLengthSplines", _wrap_SSRemoveZeroLengthSplines},
    { "SSRemoveStupidControlPoints", _wrap_SSRemoveStupidControlPoints},
    { "SSOverlapClusterCpAngles", _wrap_SSOverlapClusterCpAngles},
    { "SplinesRemoveBetween", _wrap_SplinesRemoveBetween},
    { "SplineCharMerge", _wrap_SplineCharMerge},
    { "SPLNearlyHvCps", _wrap_SPLNearlyHvCps},
    { "SPLNearlyHvLines", _wrap_SPLNearlyHvLines},
    { "SPLNearlyLines", _wrap_SPLNearlyLines},
    { "SPInterpolate", _wrap_SPInterpolate},
    { "SplinePointListSimplify", _wrap_SplinePointListSimplify},
    { "SplineCharSimplify", _wrap_SplineCharSimplify},
    { "SPLStartToLeftmost", _wrap_SPLStartToLeftmost},
    { "SPLsStartToLeftmost", _wrap_SPLsStartToLeftmost},
    { "CanonicalContours", _wrap_CanonicalContours},
    { "SplineSetJoinCpFixup", _wrap_SplineSetJoinCpFixup},
    { "SplineSetJoin", _wrap_SplineSetJoin},
    { "SpIsExtremum", _wrap_SpIsExtremum},
    { "Spline1DCantExtremeX", _wrap_Spline1DCantExtremeX},
    { "Spline1DCantExtremeY", _wrap_Spline1DCantExtremeY},
    { "SplineAddExtrema", _wrap_SplineAddExtrema},
    { "SplineSetAddExtrema", _wrap_SplineSetAddExtrema},
    { "SplineCharAddExtrema", _wrap_SplineCharAddExtrema},
    { "SplineCharRemoveTiny", _wrap_SplineCharRemoveTiny},
    { "SplineFontNew", _wrap_SplineFontNew},
    { "GetNextUntitledName", _wrap_GetNextUntitledName},
    { "SplineFontEmpty", _wrap_SplineFontEmpty},
    { "SplineFontBlank", _wrap_SplineFontBlank},
    { "SFIncrementXUID", _wrap_SFIncrementXUID},
    { "SFRandomChangeXUID", _wrap_SFRandomChangeXUID},
    { "SplineSetReverse", _wrap_SplineSetReverse},
    { "SplineSetsExtractOpen", _wrap_SplineSetsExtractOpen},
    { "SplineSetsInsertOpen", _wrap_SplineSetsInsertOpen},
    { "SplineSetsCorrect", _wrap_SplineSetsCorrect},
    { "SplineSetsAntiCorrect", _wrap_SplineSetsAntiCorrect},
    { "SplineSetsDetectDir", _wrap_SplineSetsDetectDir},
    { "SPAverageCps", _wrap_SPAverageCps},
    { "SPLAverageCps", _wrap_SPLAverageCps},
    { "SPWeightedAverageCps", _wrap_SPWeightedAverageCps},
    { "BP_HVForce", _wrap_BP_HVForce},
    { "SplineCharDefaultPrevCP", _wrap_SplineCharDefaultPrevCP},
    { "SplineCharDefaultNextCP", _wrap_SplineCharDefaultNextCP},
    { "SplineCharTangentNextCP", _wrap_SplineCharTangentNextCP},
    { "SplineCharTangentPrevCP", _wrap_SplineCharTangentPrevCP},
    { "SPAdjustControl", _wrap_SPAdjustControl},
    { "SPHVCurveForce", _wrap_SPHVCurveForce},
    { "SPSmoothJoint", _wrap_SPSmoothJoint},
    { "PointListIsSelected", _wrap_PointListIsSelected},
    { "SCSplinePointsUntick", _wrap_SCSplinePointsUntick},
    { "SplineSetsUntick", _wrap_SplineSetsUntick},
    { "SFOrderBitmapList", _wrap_SFOrderBitmapList},
    { "KernThreshold", _wrap_KernThreshold},
    { "SFGuessItalicAngle", _wrap_SFGuessItalicAngle},
    { "SplineTtfApprox", _wrap_SplineTtfApprox},
    { "SSttfApprox", _wrap_SSttfApprox},
    { "SplineSetsTTFApprox", _wrap_SplineSetsTTFApprox},
    { "SSPSApprox", _wrap_SSPSApprox},
    { "SplineSetsPSApprox", _wrap_SplineSetsPSApprox},
    { "SplineSetsConvertOrder", _wrap_SplineSetsConvertOrder},
    { "SplineRefigure2", _wrap_SplineRefigure2},
    { "SplineRefigureFixup", _wrap_SplineRefigureFixup},
    { "SplineMake2", _wrap_SplineMake2},
    { "SplineMake", _wrap_SplineMake},
    { "SCConvertToOrder2", _wrap_SCConvertToOrder2},
    { "SFConvertToOrder2", _wrap_SFConvertToOrder2},
    { "SCConvertToOrder3", _wrap_SCConvertToOrder3},
    { "SFConvertToOrder3", _wrap_SFConvertToOrder3},
    { "SFConvertGridToOrder2", _wrap_SFConvertGridToOrder2},
    { "SCConvertLayerToOrder2", _wrap_SCConvertLayerToOrder2},
    { "SFConvertLayerToOrder2", _wrap_SFConvertLayerToOrder2},
    { "SFConvertGridToOrder3", _wrap_SFConvertGridToOrder3},
    { "SCConvertLayerToOrder3", _wrap_SCConvertLayerToOrder3},
    { "SFConvertLayerToOrder3", _wrap_SFConvertLayerToOrder3},
    { "SCConvertOrder", _wrap_SCConvertOrder},
    { "SplinePointPrevCPChanged2", _wrap_SplinePointPrevCPChanged2},
    { "SplinePointNextCPChanged2", _wrap_SplinePointNextCPChanged2},
    { "IntersectLinesSlopes", _wrap_IntersectLinesSlopes},
    { "IntersectLines", _wrap_IntersectLines},
    { "IntersectLinesClip", _wrap_IntersectLinesClip},
    { "SSRemoveBacktracks", _wrap_SSRemoveBacktracks},
    { "PolygonIsConvex", _wrap_PolygonIsConvex},
    { "UnitShape", _wrap_UnitShape},
    { "SplineSetStroke", _wrap_SplineSetStroke},
    { "SplineSetRemoveOverlap", _wrap_SplineSetRemoveOverlap},
    { "SSShadow", _wrap_SSShadow},
    { "BlueScaleFigureForced", _wrap_BlueScaleFigureForced},
    { "BlueScaleFigure", _wrap_BlueScaleFigure},
    { "FindBlues", _wrap_FindBlues},
    { "QuickBlues", _wrap_QuickBlues},
    { "FindHStems", _wrap_FindHStems},
    { "FindVStems", _wrap_FindVStems},
    { "SFStdVW", _wrap_SFStdVW},
    { "SplineCharIsFlexible", _wrap_SplineCharIsFlexible},
    { "SCGuessHintInstancesList", _wrap_SCGuessHintInstancesList},
    { "SCGuessDHintInstances", _wrap_SCGuessDHintInstances},
    { "SCGuessHHintInstancesAndAdd", _wrap_SCGuessHHintInstancesAndAdd},
    { "SCGuessVHintInstancesAndAdd", _wrap_SCGuessVHintInstancesAndAdd},
    { "SCGuessHHintInstancesList", _wrap_SCGuessHHintInstancesList},
    { "SCGuessVHintInstancesList", _wrap_SCGuessVHintInstancesList},
    { "HIlen", _wrap_HIlen},
    { "HIoverlap", _wrap_HIoverlap},
    { "StemInfoAnyOverlaps", _wrap_StemInfoAnyOverlaps},
    { "StemListAnyConflicts", _wrap_StemListAnyConflicts},
    { "HICopyTrans", _wrap_HICopyTrans},
    { "SFNeedsAutoHint", _wrap_SFNeedsAutoHint},
    { "InitGlobalInstrCt", _wrap_InitGlobalInstrCt},
    { "FreeGlobalInstrCt", _wrap_FreeGlobalInstrCt},
    { "NowakowskiSCAutoInstr", _wrap_NowakowskiSCAutoInstr},
    { "SCModifyHintMasksAdd", _wrap_SCModifyHintMasksAdd},
    { "SCClearHints", _wrap_SCClearHints},
    { "SCClearHintMasks", _wrap_SCClearHintMasks},
    { "SCFigureVerticalCounterMasks", _wrap_SCFigureVerticalCounterMasks},
    { "SCFigureCounterMasks", _wrap_SCFigureCounterMasks},
    { "SCFigureHintMasks", _wrap_SCFigureHintMasks},
    { "_SplineCharAutoHint", _wrap__SplineCharAutoHint},
    { "SplineCharAutoHint", _wrap_SplineCharAutoHint},
    { "SFSCAutoHint", _wrap_SFSCAutoHint},
    { "SplineFontAutoHint", _wrap_SplineFontAutoHint},
    { "SplineFontAutoHintRefs", _wrap_SplineFontAutoHintRefs},
    { "HintCleanup", _wrap_HintCleanup},
    { "SplineFontIsFlexible", _wrap_SplineFontIsFlexible},
    { "SCDrawsSomething", _wrap_SCDrawsSomething},
    { "SCWorthOutputting", _wrap_SCWorthOutputting},
    { "SFFindNotdef", _wrap_SFFindNotdef},
    { "doesGlyphExpandHorizontally", _wrap_doesGlyphExpandHorizontally},
    { "IsntBDFChar", _wrap_IsntBDFChar},
    { "CIDWorthOutputting", _wrap_CIDWorthOutputting},
    { "AmfmSplineFont", _wrap_AmfmSplineFont},
    { "AfmSplineFont", _wrap_AfmSplineFont},
    { "PfmSplineFont", _wrap_PfmSplineFont},
    { "TfmSplineFont", _wrap_TfmSplineFont},
    { "OfmSplineFont", _wrap_OfmSplineFont},
    { "EncodingName", _wrap_EncodingName},
    { "SFEncodingName", _wrap_SFEncodingName},
    { "SFLigaturePrepare", _wrap_SFLigaturePrepare},
    { "SFLigatureCleanup", _wrap_SFLigatureCleanup},
    { "SFKernClassTempDecompose", _wrap_SFKernClassTempDecompose},
    { "SFKernCleanup", _wrap_SFKernCleanup},
    { "SCSetMetaData", _wrap_SCSetMetaData},
    { "interp_from_encoding", _wrap_interp_from_encoding},
    { "EncName", _wrap_EncName},
    { "FindUnicharName", _wrap_FindUnicharName},
    { "_FindOrMakeEncoding", _wrap__FindOrMakeEncoding},
    { "FindOrMakeEncoding", _wrap_FindOrMakeEncoding},
    { "SFDDumpMacFeat", _wrap_SFDDumpMacFeat},
    { "SFDParseMacFeatures", _wrap_SFDParseMacFeatures},
    { "SFDWrite", _wrap_SFDWrite},
    { "SFDWriteBak", _wrap_SFDWriteBak},
    { "SFDRead", _wrap_SFDRead},
    { "_SFDRead", _wrap__SFDRead},
    { "SFDirRead", _wrap_SFDirRead},
    { "SFDReadOneChar", _wrap_SFDReadOneChar},
    { "TTFGetFontName", _wrap_TTFGetFontName},
    { "TTFLoadBitmaps", _wrap_TTFLoadBitmaps},
    { "_SFReadWOFF", _wrap__SFReadWOFF},
    { "_SFReadTTF", _wrap__SFReadTTF},
    { "SFReadTTF", _wrap_SFReadTTF},
    { "SFReadSVG", _wrap_SFReadSVG},
    { "SFReadSVGMem", _wrap_SFReadSVGMem},
    { "SFReadUFO", _wrap_SFReadUFO},
    { "_CFFParse", _wrap__CFFParse},
    { "CFFParse", _wrap_CFFParse},
    { "SFReadMacBinary", _wrap_SFReadMacBinary},
    { "SFReadWinFON", _wrap_SFReadWinFON},
    { "SFReadPalmPdb", _wrap_SFReadPalmPdb},
    { "LoadSplineFont", _wrap_LoadSplineFont},
    { "_ReadSplineFont", _wrap__ReadSplineFont},
    { "ReadSplineFont", _wrap_ReadSplineFont},
    { "URLToTempFile", _wrap_URLToTempFile},
    { "URLFromFile", _wrap_URLFromFile},
    { "HttpGetBuf", _wrap_HttpGetBuf},
    { "ArchiveCleanup", _wrap_ArchiveCleanup},
    { "Unarchive", _wrap_Unarchive},
    { "Decompress", _wrap_Decompress},
    { "SFFromBDF", _wrap_SFFromBDF},
    { "SFFromMF", _wrap_SFFromMF},
    { "SFCheckPSBitmap", _wrap_SFCheckPSBitmap},
    { "_MacStyleCode", _wrap__MacStyleCode},
    { "MacStyleCode", _wrap_MacStyleCode},
    { "SFReadIkarus", _wrap_SFReadIkarus},
    { "_SFReadPdfFont", _wrap__SFReadPdfFont},
    { "SFReadPdfFont", _wrap_SFReadPdfFont},
    { "GetFontNames", _wrap_GetFontNames},
    { "NamesReadPDF", _wrap_NamesReadPDF},
    { "NamesReadSFD", _wrap_NamesReadSFD},
    { "NamesReadTTF", _wrap_NamesReadTTF},
    { "NamesReadCFF", _wrap_NamesReadCFF},
    { "NamesReadPostScript", _wrap_NamesReadPostScript},
    { "_NamesReadPostScript", _wrap__NamesReadPostScript},
    { "NamesReadSVG", _wrap_NamesReadSVG},
    { "NamesReadUFO", _wrap_NamesReadUFO},
    { "NamesReadMacBinary", _wrap_NamesReadMacBinary},
    { "SFSetOrder", _wrap_SFSetOrder},
    { "SFFindOrder", _wrap_SFFindOrder},
    { "UnicodeRange", _wrap_UnicodeRange},
    { "SCBuildDummy", _wrap_SCBuildDummy},
    { "SFMakeChar", _wrap_SFMakeChar},
    { "BDFMakeGID", _wrap_BDFMakeGID},
    { "BDFMakeChar", _wrap_BDFMakeChar},
    { "RefCharsCopyState", _wrap_RefCharsCopyState},
    { "SCWasEmpty", _wrap_SCWasEmpty},
    { "SCUndoSetLBearingChange", _wrap_SCUndoSetLBearingChange},
    { "SCPreserveHints", _wrap_SCPreserveHints},
    { "SCPreserveLayer", _wrap_SCPreserveLayer},
    { "_SCPreserveLayer", _wrap__SCPreserveLayer},
    { "SCPreserveState", _wrap_SCPreserveState},
    { "SCPreserveBackground", _wrap_SCPreserveBackground},
    { "SFPreserveGuide", _wrap_SFPreserveGuide},
    { "SCPreserveWidth", _wrap_SCPreserveWidth},
    { "SCPreserveVWidth", _wrap_SCPreserveVWidth},
    { "BCPreserveState", _wrap_BCPreserveState},
    { "BCDoRedo", _wrap_BCDoRedo},
    { "BCDoUndo", _wrap_BCDoUndo},
    { "isaccent", _wrap_isaccent},
    { "SFIsCompositBuildable", _wrap_SFIsCompositBuildable},
    { "SFIsSomethingBuildable", _wrap_SFIsSomethingBuildable},
    { "SFIsRotatable", _wrap_SFIsRotatable},
    { "SCBuildComposit", _wrap_SCBuildComposit},
    { "SCAppendAccent", _wrap_SCAppendAccent},
    { "SFGetAlternate", _wrap_SFGetAlternate},
    { "getAdobeEnc", _wrap_getAdobeEnc},
    { "SFSplinesFromLayers", _wrap_SFSplinesFromLayers},
    { "SplinePointListInterpretSVG", _wrap_SplinePointListInterpretSVG},
    { "SplinePointListInterpretGlif", _wrap_SplinePointListInterpretGlif},
    { "SplinePointListInterpretPS", _wrap_SplinePointListInterpretPS},
    { "PSFontInterpretPS", _wrap_PSFontInterpretPS},
    { "PSSlurpEncodings", _wrap_PSSlurpEncodings},
    { "EvaluatePS", _wrap_EvaluatePS},
    { "UnblendedCompare", _wrap_UnblendedCompare},
    { "PSCharStringToSplines", _wrap_PSCharStringToSplines},
    { "MatMultiply", _wrap_MatMultiply},
    { "MatIsIdentity", _wrap_MatIsIdentity},
    { "NameToEncoding", _wrap_NameToEncoding},
    { "GlyphHashFree", _wrap_GlyphHashFree},
    { "SFHashGlyph", _wrap_SFHashGlyph},
    { "SFHashName", _wrap_SFHashName},
    { "SFFindGID", _wrap_SFFindGID},
    { "SFFindSlot", _wrap_SFFindSlot},
    { "SFCIDFindCID", _wrap_SFCIDFindCID},
    { "SFGetChar", _wrap_SFGetChar},
    { "SFHasChar", _wrap_SFHasChar},
    { "SFGetOrMakeChar", _wrap_SFGetOrMakeChar},
    { "SFFindExistingSlot", _wrap_SFFindExistingSlot},
    { "SFCIDFindExistingChar", _wrap_SFCIDFindExistingChar},
    { "SFHasCID", _wrap_SFHasCID},
    { "getPfaEditDir", _wrap_getPfaEditDir},
    { "_DoAutoSaves", _wrap__DoAutoSaves},
    { "CleanAutoRecovery", _wrap_CleanAutoRecovery},
    { "DoAutoRecovery", _wrap_DoAutoRecovery},
    { "SFRecoverFile", _wrap_SFRecoverFile},
    { "SFAutoSave", _wrap_SFAutoSave},
    { "SFClearAutoSave", _wrap_SFClearAutoSave},
    { "PSCharsFree", _wrap_PSCharsFree},
    { "PSDictFree", _wrap_PSDictFree},
    { "PSDictCopy", _wrap_PSDictCopy},
    { "PSDictFindEntry", _wrap_PSDictFindEntry},
    { "PSDictHasEntry", _wrap_PSDictHasEntry},
    { "PSDictSame", _wrap_PSDictSame},
    { "PSDictRemoveEntry", _wrap_PSDictRemoveEntry},
    { "PSDictChangeEntry", _wrap_PSDictChangeEntry},
    { "SFPrivateGuess", _wrap_SFPrivateGuess},
    { "SFRemoveLayer", _wrap_SFRemoveLayer},
    { "SFAddLayer", _wrap_SFAddLayer},
    { "SFLayerSetBackground", _wrap_SFLayerSetBackground},
    { "SplineSetsRound2Int", _wrap_SplineSetsRound2Int},
    { "SCRound2Int", _wrap_SCRound2Int},
    { "SCRoundToCluster", _wrap_SCRoundToCluster},
    { "SplineSetsRemoveAnnoyingExtrema", _wrap_SplineSetsRemoveAnnoyingExtrema},
    { "hascomposing", _wrap_hascomposing},
    { "CIDFromName", _wrap_CIDFromName},
    { "CID2Uni", _wrap_CID2Uni},
    { "CID2NameUni", _wrap_CID2NameUni},
    { "NameUni2CID", _wrap_NameUni2CID},
    { "CIDSetAltUnis", _wrap_CIDSetAltUnis},
    { "MaxCID", _wrap_MaxCID},
    { "LoadMapFromFile", _wrap_LoadMapFromFile},
    { "FindCidMap", _wrap_FindCidMap},
    { "SFEncodeToMap", _wrap_SFEncodeToMap},
    { "CIDFlatten", _wrap_CIDFlatten},
    { "SFFlatten", _wrap_SFFlatten},
    { "SFFlattenByCMap", _wrap_SFFlattenByCMap},
    { "MakeCIDMaster", _wrap_MakeCIDMaster},
    { "getushort", _wrap_getushort},
    { "getlong", _wrap_getlong},
    { "get3byte", _wrap_get3byte},
    { "getfixed", _wrap_getfixed},
    { "get2dot14", _wrap_get2dot14},
    { "putshort", _wrap_putshort},
    { "putlong", _wrap_putlong},
    { "putfixed", _wrap_putfixed},
    { "ttfcopyfile", _wrap_ttfcopyfile},
    { "SCCopyLayerToLayer", _wrap_SCCopyLayerToLayer},
    { "hasFreeType", _wrap_hasFreeType},
    { "hasFreeTypeDebugger", _wrap_hasFreeTypeDebugger},
    { "hasFreeTypeByteCode", _wrap_hasFreeTypeByteCode},
    { "FreeTypeAtLeast", _wrap_FreeTypeAtLeast},
    { "FreeTypeStringVersion", _wrap_FreeTypeStringVersion},
    { "doneFreeType", _wrap_doneFreeType},
    { "_FreeTypeFontContext", _wrap__FreeTypeFontContext},
    { "FreeTypeFontContext", _wrap_FreeTypeFontContext},
    { "SplineFontFreeTypeRasterize", _wrap_SplineFontFreeTypeRasterize},
    { "SplineCharFreeTypeRasterize", _wrap_SplineCharFreeTypeRasterize},
    { "FreeTypeFreeContext", _wrap_FreeTypeFreeContext},
    { "FreeType_GridFitChar", _wrap_FreeType_GridFitChar},
    { "FreeType_GetRaster", _wrap_FreeType_GetRaster},
    { "SplineCharFreeTypeRasterizeNoHints", _wrap_SplineCharFreeTypeRasterizeNoHints},
    { "SplineFontFreeTypeRasterizeNoHints", _wrap_SplineFontFreeTypeRasterizeNoHints},
    { "FreeType_FreeRaster", _wrap_FreeType_FreeRaster},
    { "UniFromName", _wrap_UniFromName},
    { "StdGlyphName", _wrap_StdGlyphName},
    { "AllGlyphNames", _wrap_AllGlyphNames},
    { "AllNamelistNames", _wrap_AllNamelistNames},
    { "DefaultNameListForNewFonts", _wrap_DefaultNameListForNewFonts},
    { "NameListByName", _wrap_NameListByName},
    { "LoadNamelist", _wrap_LoadNamelist},
    { "LoadNamelistDir", _wrap_LoadNamelistDir},
    { "RenameGlyphToNamelist", _wrap_RenameGlyphToNamelist},
    { "SFRenameGlyphsToNamelist", _wrap_SFRenameGlyphsToNamelist},
    { "SFTemporaryRenameGlyphsToNamelist", _wrap_SFTemporaryRenameGlyphsToNamelist},
    { "SFTemporaryRestoreGlyphNames", _wrap_SFTemporaryRestoreGlyphNames},
    { "doversion", _wrap_doversion},
    { "SSTtfNumberPoints", _wrap_SSTtfNumberPoints},
    { "SCNumberPoints", _wrap_SCNumberPoints},
    { "SCPointsNumberedProperly", _wrap_SCPointsNumberedProperly},
    { "ttfFindPointInSC", _wrap_ttfFindPointInSC},
    { "SFFigureDefWidth", _wrap_SFFigureDefWidth},
    { "ClassesMatch", _wrap_ClassesMatch},
    { "FPSTGlyphToClass", _wrap_FPSTGlyphToClass},
    { "ASMFromOpenTypeForms", _wrap_ASMFromOpenTypeForms},
    { "ASMFromFPST", _wrap_ASMFromFPST},
    { "utf8_verify_copy", _wrap_utf8_verify_copy},
    { "MacStrToUtf8", _wrap_MacStrToUtf8},
    { "Utf8ToMacStr", _wrap_Utf8ToMacStr},
    { "MacEncFromMacLang", _wrap_MacEncFromMacLang},
    { "WinLangFromMac", _wrap_WinLangFromMac},
    { "WinLangToMac", _wrap_WinLangToMac},
    { "CanEncodingWinLangAsMac", _wrap_CanEncodingWinLangAsMac},
    { "MacEncToUnicode", _wrap_MacEncToUnicode},
    { "MacLangFromLocale", _wrap_MacLangFromLocale},
    { "MacLanguageFromCode", _wrap_MacLanguageFromCode},
    { "FindEnglishNameInMacName", _wrap_FindEnglishNameInMacName},
    { "PickNameFromMacName", _wrap_PickNameFromMacName},
    { "FindMacFeature", _wrap_FindMacFeature},
    { "FindMacSetting", _wrap_FindMacSetting},
    { "FindMacSettingName", _wrap_FindMacSettingName},
    { "UniFromEnc", _wrap_UniFromEnc},
    { "EncFromUni", _wrap_EncFromUni},
    { "EncFromName", _wrap_EncFromName},
    { "MatInverse", _wrap_MatInverse},
    { "BpColinear", _wrap_BpColinear},
    { "BpWithin", _wrap_BpWithin},
    { "MMAxisAbrev", _wrap_MMAxisAbrev},
    { "MMMakeMasterFontname", _wrap_MMMakeMasterFontname},
    { "MMGuessWeight", _wrap_MMGuessWeight},
    { "MMExtractNth", _wrap_MMExtractNth},
    { "MMExtractArrayNth", _wrap_MMExtractArrayNth},
    { "MMValid", _wrap_MMValid},
    { "MMKern", _wrap_MMKern},
    { "MMBlendChar", _wrap_MMBlendChar},
    { "EnforcePostScriptName", _wrap_EnforcePostScriptName},
    { "ToAbsolute", _wrap_ToAbsolute},
    { "BitmapCompare", _wrap_BitmapCompare},
    { "SSsCompare", _wrap_SSsCompare},
    { "CompareFonts", _wrap_CompareFonts},
    { "LayersSimilar", _wrap_LayersSimilar},
    { "DefaultOtherSubrs", _wrap_DefaultOtherSubrs},
    { "ReadOtherSubrsFile", _wrap_ReadOtherSubrsFile},
    { "utf8toutf7_copy", _wrap_utf8toutf7_copy},
    { "utf7toutf8_copy", _wrap_utf7toutf8_copy},
    { "SFSetModTime", _wrap_SFSetModTime},
    { "SFTimesFromFile", _wrap_SFTimesFromFile},
    { "SFHasInstructions", _wrap_SFHasInstructions},
    { "RefDepth", _wrap_RefDepth},
    { "SCHasSubs", _wrap_SCHasSubs},
    { "TagFullName", _wrap_TagFullName},
    { "SFScriptsInLookups", _wrap_SFScriptsInLookups},
    { "SFLangsInScript", _wrap_SFLangsInScript},
    { "SFFeaturesInScriptLang", _wrap_SFFeaturesInScriptLang},
    { "SFLookupsInScriptLangFeature", _wrap_SFLookupsInScriptLangFeature},
    { "SFGlyphsWithPSTinSubtable", _wrap_SFGlyphsWithPSTinSubtable},
    { "SFGlyphsWithLigatureinLookup", _wrap_SFGlyphsWithLigatureinLookup},
    { "SFFindUnusedLookups", _wrap_SFFindUnusedLookups},
    { "SFFindClearUnusedLookupBits", _wrap_SFFindClearUnusedLookupBits},
    { "LookupUsedNested", _wrap_LookupUsedNested},
    { "SFRemoveUnusedLookupSubTables", _wrap_SFRemoveUnusedLookupSubTables},
    { "SFRemoveLookupSubTable", _wrap_SFRemoveLookupSubTable},
    { "SFRemoveLookup", _wrap_SFRemoveLookup},
    { "SFFindLookupSubtable", _wrap_SFFindLookupSubtable},
    { "SFFindLookupSubtableAndFreeName", _wrap_SFFindLookupSubtableAndFreeName},
    { "SFFindLookup", _wrap_SFFindLookup},
    { "NameOTLookup", _wrap_NameOTLookup},
    { "GlyphNameCnt", _wrap_GlyphNameCnt},
    { "reverseGlyphNames", _wrap_reverseGlyphNames},
    { "FPSTRule_From_Str", _wrap_FPSTRule_From_Str},
    { "FPSTRule_To_Str", _wrap_FPSTRule_To_Str},
    { "FListAppendScriptLang", _wrap_FListAppendScriptLang},
    { "FListsAppendScriptLang", _wrap_FListsAppendScriptLang},
    { "SLCopy", _wrap_SLCopy},
    { "SListCopy", _wrap_SListCopy},
    { "FeatureListCopy", _wrap_FeatureListCopy},
    { "SLMerge", _wrap_SLMerge},
    { "FLMerge", _wrap_FLMerge},
    { "FLOrder", _wrap_FLOrder},
    { "FeatureScriptTagInFeatureScriptList", _wrap_FeatureScriptTagInFeatureScriptList},
    { "FindFeatureTagInFeatureScriptList", _wrap_FindFeatureTagInFeatureScriptList},
    { "FeatureTagInFeatureScriptList", _wrap_FeatureTagInFeatureScriptList},
    { "DefaultLangTagInOneScriptList", _wrap_DefaultLangTagInOneScriptList},
    { "DefaultLangTagInScriptList", _wrap_DefaultLangTagInScriptList},
    { "ScriptInFeatureScriptList", _wrap_ScriptInFeatureScriptList},
    { "_FeatureOrderId", _wrap__FeatureOrderId},
    { "FeatureOrderId", _wrap_FeatureOrderId},
    { "SFSubTablesMerge", _wrap_SFSubTablesMerge},
    { "SFSubTableFindOrMake", _wrap_SFSubTableFindOrMake},
    { "SFSubTableMake", _wrap_SFSubTableMake},
    { "OTLookupCopyInto", _wrap_OTLookupCopyInto},
    { "OTLookupsCopyInto", _wrap_OTLookupsCopyInto},
    { "ApplyTickedFeatures", _wrap_ApplyTickedFeatures},
    { "VerticalKernFeature", _wrap_VerticalKernFeature},
    { "SFGlyphRenameFixup", _wrap_SFGlyphRenameFixup},
    { "SllkFree", _wrap_SllkFree},
    { "AddOTLToSllks", _wrap_AddOTLToSllks},
    { "NewAALTLookup", _wrap_NewAALTLookup},
    { "AddNewAALTFeatures", _wrap_AddNewAALTFeatures},
    { "SplinePointRound", _wrap_SplinePointRound},
    { "KCFindName", _wrap_KCFindName},
    { "SCClearRounds", _wrap_SCClearRounds},
    { "MDReplace", _wrap_MDReplace},
    { "SCSynchronizeWidth", _wrap_SCSynchronizeWidth},
    { "HasUseMyMetrics", _wrap_HasUseMyMetrics},
    { "SCSynchronizeLBearing", _wrap_SCSynchronizeLBearing},
    { "RevertedGlyphReferenceFixup", _wrap_RevertedGlyphReferenceFixup},
    { "SFUntickAll", _wrap_SFUntickAll},
    { "BDFOrigFixup", _wrap_BDFOrigFixup},
    { "HasSVG", _wrap_HasSVG},
    { "SCImportSVG", _wrap_SCImportSVG},
    { "HasUFO", _wrap_HasUFO},
    { "SCImportGlif", _wrap_SCImportGlif},
    { "SCImportPS", _wrap_SCImportPS},
    { "SCImportPSFile", _wrap_SCImportPSFile},
    { "SCImportPDF", _wrap_SCImportPDF},
    { "SCImportPDFFile", _wrap_SCImportPDFFile},
    { "SCImportPlateFile", _wrap_SCImportPlateFile},
    { "SCAddScaleImage", _wrap_SCAddScaleImage},
    { "SCInsertImage", _wrap_SCInsertImage},
    { "SCImportFig", _wrap_SCImportFig},
    { "_ExportPlate", _wrap__ExportPlate},
    { "_ExportPDF", _wrap__ExportPDF},
    { "_ExportEPS", _wrap__ExportEPS},
    { "_ExportSVG", _wrap__ExportSVG},
    { "_ExportGlif", _wrap__ExportGlif},
    { "ExportEPS", _wrap_ExportEPS},
    { "ExportPDF", _wrap_ExportPDF},
    { "ExportPlate", _wrap_ExportPlate},
    { "ExportSVG", _wrap_ExportSVG},
    { "ExportGlif", _wrap_ExportGlif},
    { "ExportFig", _wrap_ExportFig},
    { "BCExportXBM", _wrap_BCExportXBM},
    { "ExportImage", _wrap_ExportImage},
    { "ScriptExport", _wrap_ScriptExport},
    { "SFRemoveGlyph", _wrap_SFRemoveGlyph},
    { "SFAddEncodingSlot", _wrap_SFAddEncodingSlot},
    { "SFAddGlyphAndEncode", _wrap_SFAddGlyphAndEncode},
    { "SCDoRedo", _wrap_SCDoRedo},
    { "SCDoUndo", _wrap_SCDoUndo},
    { "SCCopyWidth", _wrap_SCCopyWidth},
    { "SCClearBackground", _wrap_SCClearBackground},
    { "BackgroundImageTransform", _wrap_BackgroundImageTransform},
    { "SFIsDuplicatable", _wrap_SFIsDuplicatable},
    { "DoAutoSaves", _wrap_DoAutoSaves},
    { "SCClearLayer", _wrap_SCClearLayer},
    { "SCClearContents", _wrap_SCClearContents},
    { "SCClearAll", _wrap_SCClearAll},
    { "BCClearAll", _wrap_BCClearAll},
    { "doinitFontForgeMain", _wrap_doinitFontForgeMain},
    { "InitSimpleStuff", _wrap_InitSimpleStuff},
    { "SSExistsInLayer", _wrap_SSExistsInLayer},
    { "SplineExistsInSS", _wrap_SplineExistsInSS},
    { "SpExistsInSS", _wrap_SpExistsInSS},
    { "MSLanguageFromLocale", _wrap_MSLanguageFromLocale},
    { "BPTooFar", _wrap_BPTooFar},
    { "SCHintOverlapInMask", _wrap_SCHintOverlapInMask},
    { "SCValidate", _wrap_SCValidate},
    { "SCValidateAnchors", _wrap_SCValidateAnchors},
    { "SCTickValidationState", _wrap_SCTickValidationState},
    { "ValidatePrivate", _wrap_ValidatePrivate},
    { "SFValidate", _wrap_SFValidate},
    { "VSMaskFromFormat", _wrap_VSMaskFromFormat},
    { "hasspiro", _wrap_hasspiro},
    { "SpiroCP2SplineSet", _wrap_SpiroCP2SplineSet},
    { "SplineSet2SpiroCP", _wrap_SplineSet2SpiroCP},
    { "SpiroCPCopy", _wrap_SpiroCPCopy},
    { "SSRegenerateFromSpiros", _wrap_SSRegenerateFromSpiros},
    { "PrtBuildDef", _wrap_PrtBuildDef},
    { "RandomParaFromScriptLang", _wrap_RandomParaFromScriptLang},
    { "RandomParaFromScript", _wrap_RandomParaFromScript},
    { "SF2Scripts", _wrap_SF2Scripts},
    { "SFScriptLangs", _wrap_SFScriptLangs},
    { "SSHasClip", _wrap_SSHasClip},
    { "SSHasDrawn", _wrap_SSHasDrawn},
    { "GradientCopy", _wrap_GradientCopy},
    { "GradientFree", _wrap_GradientFree},
    { "PatternCopy", _wrap_PatternCopy},
    { "PatternFree", _wrap_PatternFree},
    { "BrushCopy", _wrap_BrushCopy},
    { "PenCopy", _wrap_PenCopy},
    { "SFDefaultImage", _wrap_SFDefaultImage},
    { "SCClearInstrsOrMark", _wrap_SCClearInstrsOrMark},
    { "instrcheck", _wrap_instrcheck},
    { "TTFPointMatches", _wrap_TTFPointMatches},
    { "SFCapHeight", _wrap_SFCapHeight},
    { "SFXHeight", _wrap_SFXHeight},
    { "SFAscender", _wrap_SFAscender},
    { "SFDescender", _wrap_SFDescender},
    { "GlyphClassesFromNames", _wrap_GlyphClassesFromNames},
    { "ProcessNativeScript", _wrap_ProcessNativeScript},
    { "CheckIsScript", _wrap_CheckIsScript},
    { "check_library_version", _wrap_check_library_version},
    { "new_SplineCharArray", _wrap_new_SplineCharArray},
    { "delete_SplineCharArray", _wrap_delete_SplineCharArray},
    { "SplineCharArray_getitem", _wrap_SplineCharArray_getitem},
    { "SplineCharArray_setitem", _wrap_SplineCharArray_setitem},
    { "new_LayerArray", _wrap_new_LayerArray},
    { "delete_LayerArray", _wrap_delete_LayerArray},
    { "LayerArray_getitem", _wrap_LayerArray_getitem},
    { "LayerArray_setitem", _wrap_LayerArray_setitem},
    { "new_LayerInfoArray", _wrap_new_LayerInfoArray},
    { "delete_LayerInfoArray", _wrap_delete_LayerInfoArray},
    { "LayerInfoArray_getitem", _wrap_LayerInfoArray_getitem},
    { "LayerInfoArray_setitem", _wrap_LayerInfoArray_setitem},
    { "new_SplinePointListArray", _wrap_new_SplinePointListArray},
    { "delete_SplinePointListArray", _wrap_delete_SplinePointListArray},
    { "SplinePointListArray_getitem", _wrap_SplinePointListArray_getitem},
    { "SplinePointListArray_setitem", _wrap_SplinePointListArray_setitem},
    { "new_SplineArray", _wrap_new_SplineArray},
    { "delete_SplineArray", _wrap_delete_SplineArray},
    { "SplineArray_getitem", _wrap_SplineArray_getitem},
    { "SplineArray_setitem", _wrap_SplineArray_setitem},
    {0,0}
};

static swig_lua_var_info swig_variables[] = {
    { "friendlies", _wrap_friendlies_get, SWIG_Lua_set_immutable },
    { "unicode4_size", _wrap_unicode4_size_get, SWIG_Lua_set_immutable },
    { "AdobeStandardEncoding", _wrap_AdobeStandardEncoding_get, _wrap_AdobeStandardEncoding_set },
    { "unicode_from_adobestd", _wrap_unicode_from_adobestd_get, _wrap_unicode_from_adobestd_set },
    { "_UnicodeNameAnnot", _wrap__UnicodeNameAnnot_get, _wrap__UnicodeNameAnnot_set },
    { "default_fv_font_size", _wrap_default_fv_font_size_get, _wrap_default_fv_font_size_set },
    { "default_fv_antialias", _wrap_default_fv_antialias_get, _wrap_default_fv_antialias_set },
    { "default_fv_bbsized", _wrap_default_fv_bbsized_get, _wrap_default_fv_bbsized_set },
    { "default_encoding", _wrap_default_encoding_get, _wrap_default_encoding_set },
    { "custom", _wrap_custom_get, _wrap_custom_set },
    { "adjustwidth", _wrap_adjustwidth_get, _wrap_adjustwidth_set },
    { "adjustlbearing", _wrap_adjustlbearing_get, _wrap_adjustlbearing_set },
    { "autohint_before_generate", _wrap_autohint_before_generate_get, _wrap_autohint_before_generate_set },
    { "no_windowing_ui", _wrap_no_windowing_ui_get, _wrap_no_windowing_ui_set },
    { "default_background", _wrap_default_background_get, _wrap_default_background_set },
    { "use_utf8_in_script", _wrap_use_utf8_in_script_get, _wrap_use_utf8_in_script_set },
    { "new_em_size", _wrap_new_em_size_get, _wrap_new_em_size_set },
    { "new_fonts_are_order2", _wrap_new_fonts_are_order2_get, _wrap_new_fonts_are_order2_set },
    { "loaded_fonts_same_as_new", _wrap_loaded_fonts_same_as_new_get, _wrap_loaded_fonts_same_as_new_set },
    { "BDFFoundry", _wrap_BDFFoundry_get, _wrap_BDFFoundry_set },
    { "TTFFoundry", _wrap_TTFFoundry_get, _wrap_TTFFoundry_set },
    { "xuid", _wrap_xuid_get, _wrap_xuid_set },
    { "pagewidth", _wrap_pagewidth_get, _wrap_pagewidth_set },
    { "pageheight", _wrap_pageheight_get, _wrap_pageheight_set },
    { "printtype", _wrap_printtype_get, _wrap_printtype_set },
    { "printcommand", _wrap_printcommand_get, _wrap_printcommand_set },
    { "printlazyprinter", _wrap_printlazyprinter_get, _wrap_printlazyprinter_set },
    { "enclist", _wrap_enclist_get, _wrap_enclist_set },
    { "default_mac_feature_map", _wrap_default_mac_feature_map_get, _wrap_default_mac_feature_map_set },
    { "library_version_configuration", _wrap_library_version_configuration_get, _wrap_library_version_configuration_set },
    {0,0,0}
};

static swig_lua_const_info swig_constants[] = {
    {SWIG_LUA_CONSTTAB_INT("true", 1)},
    {SWIG_LUA_CONSTTAB_INT("false", 0)},
    {SWIG_LUA_CONSTTAB_INT("MmMax", 16)},
    {SWIG_LUA_CONSTTAB_INT("AppleMmMax", 26)},
    {SWIG_LUA_CONSTTAB_INT("v_int", v_int)},
    {SWIG_LUA_CONSTTAB_INT("v_real", v_real)},
    {SWIG_LUA_CONSTTAB_INT("v_str", v_str)},
    {SWIG_LUA_CONSTTAB_INT("v_unicode", v_unicode)},
    {SWIG_LUA_CONSTTAB_INT("v_lval", v_lval)},
    {SWIG_LUA_CONSTTAB_INT("v_arr", v_arr)},
    {SWIG_LUA_CONSTTAB_INT("v_arrfree", v_arrfree)},
    {SWIG_LUA_CONSTTAB_INT("v_int32pt", v_int32pt)},
    {SWIG_LUA_CONSTTAB_INT("v_int16pt", v_int16pt)},
    {SWIG_LUA_CONSTTAB_INT("v_int8pt", v_int8pt)},
    {SWIG_LUA_CONSTTAB_INT("v_void", v_void)},
    {SWIG_LUA_CONSTTAB_INT("lj_miter", lj_miter)},
    {SWIG_LUA_CONSTTAB_INT("lj_round", lj_round)},
    {SWIG_LUA_CONSTTAB_INT("lj_bevel", lj_bevel)},
    {SWIG_LUA_CONSTTAB_INT("lj_inherited", lj_inherited)},
    {SWIG_LUA_CONSTTAB_INT("lc_butt", lc_butt)},
    {SWIG_LUA_CONSTTAB_INT("lc_round", lc_round)},
    {SWIG_LUA_CONSTTAB_INT("lc_square", lc_square)},
    {SWIG_LUA_CONSTTAB_INT("lc_inherited", lc_inherited)},
    {SWIG_LUA_CONSTTAB_INT("sm_pad", sm_pad)},
    {SWIG_LUA_CONSTTAB_INT("sm_reflect", sm_reflect)},
    {SWIG_LUA_CONSTTAB_INT("sm_repeat", sm_repeat)},
    {SWIG_LUA_CONSTTAB_INT("COLOR_INHERITED", 0xfffffffe)},
    {SWIG_LUA_CONSTTAB_INT("WIDTH_INHERITED", (-1))},
    {SWIG_LUA_CONSTTAB_INT("DASH_INHERITED", 255)},
    {SWIG_LUA_CONSTTAB_INT("DASH_MAX", 8)},
    {SWIG_LUA_CONSTTAB_INT("si_std", si_std)},
    {SWIG_LUA_CONSTTAB_INT("si_caligraphic", si_caligraphic)},
    {SWIG_LUA_CONSTTAB_INT("si_poly", si_poly)},
    {SWIG_LUA_CONSTTAB_INT("si_centerline", si_centerline)},
    {SWIG_LUA_CONSTTAB_INT("Poly_Convex", Poly_Convex)},
    {SWIG_LUA_CONSTTAB_INT("Poly_Concave", Poly_Concave)},
    {SWIG_LUA_CONSTTAB_INT("Poly_PointOnEdge", Poly_PointOnEdge)},
    {SWIG_LUA_CONSTTAB_INT("Poly_TooFewPoints", Poly_TooFewPoints)},
    {SWIG_LUA_CONSTTAB_INT("Poly_Line", Poly_Line)},
    {SWIG_LUA_CONSTTAB_INT("over_remove", over_remove)},
    {SWIG_LUA_CONSTTAB_INT("over_rmselected", over_rmselected)},
    {SWIG_LUA_CONSTTAB_INT("over_intersect", over_intersect)},
    {SWIG_LUA_CONSTTAB_INT("over_intersel", over_intersel)},
    {SWIG_LUA_CONSTTAB_INT("over_exclude", over_exclude)},
    {SWIG_LUA_CONSTTAB_INT("over_findinter", over_findinter)},
    {SWIG_LUA_CONSTTAB_INT("over_fisel", over_fisel)},
    {SWIG_LUA_CONSTTAB_INT("sf_cleanup", sf_cleanup)},
    {SWIG_LUA_CONSTTAB_INT("sf_normal", sf_normal)},
    {SWIG_LUA_CONSTTAB_INT("sf_ignoreslopes", sf_ignoreslopes)},
    {SWIG_LUA_CONSTTAB_INT("sf_ignoreextremum", sf_ignoreextremum)},
    {SWIG_LUA_CONSTTAB_INT("sf_smoothcurves", sf_smoothcurves)},
    {SWIG_LUA_CONSTTAB_INT("sf_choosehv", sf_choosehv)},
    {SWIG_LUA_CONSTTAB_INT("sf_forcelines", sf_forcelines)},
    {SWIG_LUA_CONSTTAB_INT("sf_nearlyhvlines", sf_nearlyhvlines)},
    {SWIG_LUA_CONSTTAB_INT("sf_mergelines", sf_mergelines)},
    {SWIG_LUA_CONSTTAB_INT("sf_setstart2extremum", sf_setstart2extremum)},
    {SWIG_LUA_CONSTTAB_INT("sf_rmsingletonpoints", sf_rmsingletonpoints)},
    {SWIG_LUA_CONSTTAB_INT("srf_flat", srf_flat)},
    {SWIG_LUA_CONSTTAB_INT("srf_simpleslant", srf_simpleslant)},
    {SWIG_LUA_CONSTTAB_INT("srf_complexslant", srf_complexslant)},
    {SWIG_LUA_CONSTTAB_INT("DEFAULT_LANG", ((('d') << 24)|(('f') << 16)|(('l') << 8)|('t')))},
    {SWIG_LUA_CONSTTAB_INT("DEFAULT_SCRIPT", ((('D') << 24)|(('F') << 16)|(('L') << 8)|('T')))},
    {SWIG_LUA_CONSTTAB_INT("REQUIRED_FEATURE", (((' ') << 24)|(('R') << 16)|(('Q') << 8)|('D')))},
    {SWIG_LUA_CONSTTAB_INT("ot_undef", ot_undef)},
    {SWIG_LUA_CONSTTAB_INT("gsub_start", gsub_start)},
    {SWIG_LUA_CONSTTAB_INT("gsub_single", gsub_single)},
    {SWIG_LUA_CONSTTAB_INT("gsub_multiple", gsub_multiple)},
    {SWIG_LUA_CONSTTAB_INT("gsub_alternate", gsub_alternate)},
    {SWIG_LUA_CONSTTAB_INT("gsub_ligature", gsub_ligature)},
    {SWIG_LUA_CONSTTAB_INT("gsub_context", gsub_context)},
    {SWIG_LUA_CONSTTAB_INT("gsub_contextchain", gsub_contextchain)},
    {SWIG_LUA_CONSTTAB_INT("gsub_reversecchain", gsub_reversecchain)},
    {SWIG_LUA_CONSTTAB_INT("morx_indic", morx_indic)},
    {SWIG_LUA_CONSTTAB_INT("morx_context", morx_context)},
    {SWIG_LUA_CONSTTAB_INT("morx_insert", morx_insert)},
    {SWIG_LUA_CONSTTAB_INT("gpos_start", gpos_start)},
    {SWIG_LUA_CONSTTAB_INT("gpos_single", gpos_single)},
    {SWIG_LUA_CONSTTAB_INT("gpos_pair", gpos_pair)},
    {SWIG_LUA_CONSTTAB_INT("gpos_cursive", gpos_cursive)},
    {SWIG_LUA_CONSTTAB_INT("gpos_mark2base", gpos_mark2base)},
    {SWIG_LUA_CONSTTAB_INT("gpos_mark2ligature", gpos_mark2ligature)},
    {SWIG_LUA_CONSTTAB_INT("gpos_mark2mark", gpos_mark2mark)},
    {SWIG_LUA_CONSTTAB_INT("gpos_context", gpos_context)},
    {SWIG_LUA_CONSTTAB_INT("gpos_contextchain", gpos_contextchain)},
    {SWIG_LUA_CONSTTAB_INT("kern_statemachine", kern_statemachine)},
    {SWIG_LUA_CONSTTAB_INT("gsub_single_mask", gsub_single_mask)},
    {SWIG_LUA_CONSTTAB_INT("gsub_multiple_mask", gsub_multiple_mask)},
    {SWIG_LUA_CONSTTAB_INT("gsub_alternate_mask", gsub_alternate_mask)},
    {SWIG_LUA_CONSTTAB_INT("gsub_ligature_mask", gsub_ligature_mask)},
    {SWIG_LUA_CONSTTAB_INT("gsub_context_mask", gsub_context_mask)},
    {SWIG_LUA_CONSTTAB_INT("gsub_contextchain_mask", gsub_contextchain_mask)},
    {SWIG_LUA_CONSTTAB_INT("gsub_reversecchain_mask", gsub_reversecchain_mask)},
    {SWIG_LUA_CONSTTAB_INT("morx_indic_mask", morx_indic_mask)},
    {SWIG_LUA_CONSTTAB_INT("morx_context_mask", morx_context_mask)},
    {SWIG_LUA_CONSTTAB_INT("morx_insert_mask", morx_insert_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_single_mask", gpos_single_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_pair_mask", gpos_pair_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_cursive_mask", gpos_cursive_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_mark2base_mask", gpos_mark2base_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_mark2ligature_mask", gpos_mark2ligature_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_mark2mark_mask", gpos_mark2mark_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_context_mask", gpos_context_mask)},
    {SWIG_LUA_CONSTTAB_INT("gpos_contextchain_mask", gpos_contextchain_mask)},
    {SWIG_LUA_CONSTTAB_INT("kern_statemachine_mask", kern_statemachine_mask)},
    {SWIG_LUA_CONSTTAB_INT("MAX_LANG", 4)},
    {SWIG_LUA_CONSTTAB_INT("pst_r2l", pst_r2l)},
    {SWIG_LUA_CONSTTAB_INT("pst_ignorebaseglyphs", pst_ignorebaseglyphs)},
    {SWIG_LUA_CONSTTAB_INT("pst_ignoreligatures", pst_ignoreligatures)},
    {SWIG_LUA_CONSTTAB_INT("pst_ignorecombiningmarks", pst_ignorecombiningmarks)},
    {SWIG_LUA_CONSTTAB_INT("pst_usemarkfilteringset", pst_usemarkfilteringset)},
    {SWIG_LUA_CONSTTAB_INT("pst_markclass", pst_markclass)},
    {SWIG_LUA_CONSTTAB_INT("pst_markset", pst_markset)},
    {SWIG_LUA_CONSTTAB_INT("act_mark", act_mark)},
    {SWIG_LUA_CONSTTAB_INT("act_mkmk", act_mkmk)},
    {SWIG_LUA_CONSTTAB_INT("act_curs", act_curs)},
    {SWIG_LUA_CONSTTAB_INT("act_mklg", act_mklg)},
    {SWIG_LUA_CONSTTAB_INT("at_mark", at_mark)},
    {SWIG_LUA_CONSTTAB_INT("at_basechar", at_basechar)},
    {SWIG_LUA_CONSTTAB_INT("at_baselig", at_baselig)},
    {SWIG_LUA_CONSTTAB_INT("at_basemark", at_basemark)},
    {SWIG_LUA_CONSTTAB_INT("at_centry", at_centry)},
    {SWIG_LUA_CONSTTAB_INT("at_cexit", at_cexit)},
    {SWIG_LUA_CONSTTAB_INT("at_max", at_max)},
    {SWIG_LUA_CONSTTAB_INT("pst_null", pst_null)},
    {SWIG_LUA_CONSTTAB_INT("pst_position", pst_position)},
    {SWIG_LUA_CONSTTAB_INT("pst_pair", pst_pair)},
    {SWIG_LUA_CONSTTAB_INT("pst_substitution", pst_substitution)},
    {SWIG_LUA_CONSTTAB_INT("pst_alternate", pst_alternate)},
    {SWIG_LUA_CONSTTAB_INT("pst_multiple", pst_multiple)},
    {SWIG_LUA_CONSTTAB_INT("pst_ligature", pst_ligature)},
    {SWIG_LUA_CONSTTAB_INT("pst_lcaret", pst_lcaret)},
    {SWIG_LUA_CONSTTAB_INT("pst_max", pst_max)},
    {SWIG_LUA_CONSTTAB_INT("pst_kerning", pst_kerning)},
    {SWIG_LUA_CONSTTAB_INT("pst_vkerning", pst_vkerning)},
    {SWIG_LUA_CONSTTAB_INT("pst_anchors", pst_anchors)},
    {SWIG_LUA_CONSTTAB_INT("pst_contextpos", pst_contextpos)},
    {SWIG_LUA_CONSTTAB_INT("pst_contextsub", pst_contextsub)},
    {SWIG_LUA_CONSTTAB_INT("pst_chainpos", pst_chainpos)},
    {SWIG_LUA_CONSTTAB_INT("pst_chainsub", pst_chainsub)},
    {SWIG_LUA_CONSTTAB_INT("pst_reversesub", pst_reversesub)},
    {SWIG_LUA_CONSTTAB_INT("fpst_max", fpst_max)},
    {SWIG_LUA_CONSTTAB_INT("pst_kernback", pst_kernback)},
    {SWIG_LUA_CONSTTAB_INT("pst_vkernback", pst_vkernback)},
    {SWIG_LUA_CONSTTAB_INT("pst_glyphs", pst_glyphs)},
    {SWIG_LUA_CONSTTAB_INT("pst_class", pst_class)},
    {SWIG_LUA_CONSTTAB_INT("pst_coverage", pst_coverage)},
    {SWIG_LUA_CONSTTAB_INT("pst_reversecoverage", pst_reversecoverage)},
    {SWIG_LUA_CONSTTAB_INT("pst_formatmax", pst_formatmax)},
    {SWIG_LUA_CONSTTAB_INT("asm_indic", asm_indic)},
    {SWIG_LUA_CONSTTAB_INT("asm_context", asm_context)},
    {SWIG_LUA_CONSTTAB_INT("asm_lig", asm_lig)},
    {SWIG_LUA_CONSTTAB_INT("asm_simple", asm_simple)},
    {SWIG_LUA_CONSTTAB_INT("asm_insert", asm_insert)},
    {SWIG_LUA_CONSTTAB_INT("asm_kern", asm_kern)},
    {SWIG_LUA_CONSTTAB_INT("asm_vert", asm_vert)},
    {SWIG_LUA_CONSTTAB_INT("asm_descending", asm_descending)},
    {SWIG_LUA_CONSTTAB_INT("asm_always", asm_always)},
    {SWIG_LUA_CONSTTAB_INT("ut_none", ut_none)},
    {SWIG_LUA_CONSTTAB_INT("ut_state", ut_state)},
    {SWIG_LUA_CONSTTAB_INT("ut_tstate", ut_tstate)},
    {SWIG_LUA_CONSTTAB_INT("ut_statehint", ut_statehint)},
    {SWIG_LUA_CONSTTAB_INT("ut_statename", ut_statename)},
    {SWIG_LUA_CONSTTAB_INT("ut_statelookup", ut_statelookup)},
    {SWIG_LUA_CONSTTAB_INT("ut_anchors", ut_anchors)},
    {SWIG_LUA_CONSTTAB_INT("ut_width", ut_width)},
    {SWIG_LUA_CONSTTAB_INT("ut_vwidth", ut_vwidth)},
    {SWIG_LUA_CONSTTAB_INT("ut_lbearing", ut_lbearing)},
    {SWIG_LUA_CONSTTAB_INT("ut_rbearing", ut_rbearing)},
    {SWIG_LUA_CONSTTAB_INT("ut_possub", ut_possub)},
    {SWIG_LUA_CONSTTAB_INT("ut_hints", ut_hints)},
    {SWIG_LUA_CONSTTAB_INT("ut_bitmap", ut_bitmap)},
    {SWIG_LUA_CONSTTAB_INT("ut_bitmapsel", ut_bitmapsel)},
    {SWIG_LUA_CONSTTAB_INT("ut_composit", ut_composit)},
    {SWIG_LUA_CONSTTAB_INT("ut_multiple", ut_multiple)},
    {SWIG_LUA_CONSTTAB_INT("ut_layers", ut_layers)},
    {SWIG_LUA_CONSTTAB_INT("ut_noop", ut_noop)},
    {SWIG_LUA_CONSTTAB_INT("ui_unset", ui_unset)},
    {SWIG_LUA_CONSTTAB_INT("ui_none", ui_none)},
    {SWIG_LUA_CONSTTAB_INT("ui_adobe", ui_adobe)},
    {SWIG_LUA_CONSTTAB_INT("ui_greek", ui_greek)},
    {SWIG_LUA_CONSTTAB_INT("ui_japanese", ui_japanese)},
    {SWIG_LUA_CONSTTAB_INT("ui_trad_chinese", ui_trad_chinese)},
    {SWIG_LUA_CONSTTAB_INT("ui_simp_chinese", ui_simp_chinese)},
    {SWIG_LUA_CONSTTAB_INT("ui_korean", ui_korean)},
    {SWIG_LUA_CONSTTAB_INT("ui_ams", ui_ams)},
    {SWIG_LUA_CONSTTAB_INT("prt_string", prt_string)},
    {SWIG_LUA_CONSTTAB_INT("prt_atom", prt_atom)},
    {SWIG_LUA_CONSTTAB_INT("prt_int", prt_int)},
    {SWIG_LUA_CONSTTAB_INT("prt_uint", prt_uint)},
    {SWIG_LUA_CONSTTAB_INT("prt_property", prt_property)},
    {SWIG_LUA_CONSTTAB_INT("HntMax", 96)},
    {SWIG_LUA_CONSTTAB_INT("pt_curve", pt_curve)},
    {SWIG_LUA_CONSTTAB_INT("pt_corner", pt_corner)},
    {SWIG_LUA_CONSTTAB_INT("pt_tangent", pt_tangent)},
    {SWIG_LUA_CONSTTAB_INT("pt_hvcurve", pt_hvcurve)},
    {SWIG_LUA_CONSTTAB_INT("cvli_onscreen", cvli_onscreen)},
    {SWIG_LUA_CONSTTAB_INT("cvli_clipped", cvli_clipped)},
    {SWIG_LUA_CONSTTAB_INT("ht_unspecified", ht_unspecified)},
    {SWIG_LUA_CONSTTAB_INT("ht_h", ht_h)},
    {SWIG_LUA_CONSTTAB_INT("ht_v", ht_v)},
    {SWIG_LUA_CONSTTAB_INT("ht_d", ht_d)},
    {SWIG_LUA_CONSTTAB_INT("ly_all", ly_all)},
    {SWIG_LUA_CONSTTAB_INT("ly_grid", ly_grid)},
    {SWIG_LUA_CONSTTAB_INT("ly_back", ly_back)},
    {SWIG_LUA_CONSTTAB_INT("ly_fore", ly_fore)},
    {SWIG_LUA_CONSTTAB_INT("ly_none", ly_none)},
    {SWIG_LUA_CONSTTAB_INT("pds_odd", pds_odd)},
    {SWIG_LUA_CONSTTAB_INT("pds_outoforder", pds_outoforder)},
    {SWIG_LUA_CONSTTAB_INT("pds_toomany", pds_toomany)},
    {SWIG_LUA_CONSTTAB_INT("pds_tooclose", pds_tooclose)},
    {SWIG_LUA_CONSTTAB_INT("pds_notintegral", pds_notintegral)},
    {SWIG_LUA_CONSTTAB_INT("pds_toobig", pds_toobig)},
    {SWIG_LUA_CONSTTAB_INT("pds_shift", pds_shift)},
    {SWIG_LUA_CONSTTAB_INT("pds_missingblue", pds_missingblue)},
    {SWIG_LUA_CONSTTAB_INT("pds_badbluefuzz", pds_badbluefuzz)},
    {SWIG_LUA_CONSTTAB_INT("pds_badbluescale", pds_badbluescale)},
    {SWIG_LUA_CONSTTAB_INT("pds_badstdhw", pds_badstdhw)},
    {SWIG_LUA_CONSTTAB_INT("pds_badstdvw", pds_badstdvw)},
    {SWIG_LUA_CONSTTAB_INT("pds_badstemsnaph", pds_badstemsnaph)},
    {SWIG_LUA_CONSTTAB_INT("pds_badstemsnapv", pds_badstemsnapv)},
    {SWIG_LUA_CONSTTAB_INT("pds_stemsnapnostdh", pds_stemsnapnostdh)},
    {SWIG_LUA_CONSTTAB_INT("pds_stemsnapnostdv", pds_stemsnapnostdv)},
    {SWIG_LUA_CONSTTAB_INT("pds_badblueshift", pds_badblueshift)},
    {SWIG_LUA_CONSTTAB_INT("vs_unknown", vs_unknown)},
    {SWIG_LUA_CONSTTAB_INT("vs_known", vs_known)},
    {SWIG_LUA_CONSTTAB_INT("vs_opencontour", vs_opencontour)},
    {SWIG_LUA_CONSTTAB_INT("vs_selfintersects", vs_selfintersects)},
    {SWIG_LUA_CONSTTAB_INT("vs_wrongdirection", vs_wrongdirection)},
    {SWIG_LUA_CONSTTAB_INT("vs_flippedreferences", vs_flippedreferences)},
    {SWIG_LUA_CONSTTAB_INT("vs_missingextrema", vs_missingextrema)},
    {SWIG_LUA_CONSTTAB_INT("vs_missingglyphnameingsub", vs_missingglyphnameingsub)},
    {SWIG_LUA_CONSTTAB_INT("vs_toomanypoints", vs_toomanypoints)},
    {SWIG_LUA_CONSTTAB_INT("vs_toomanyhints", vs_toomanyhints)},
    {SWIG_LUA_CONSTTAB_INT("vs_badglyphname", vs_badglyphname)},
    {SWIG_LUA_CONSTTAB_INT("vs_maxp_toomanypoints", vs_maxp_toomanypoints)},
    {SWIG_LUA_CONSTTAB_INT("vs_maxp_toomanypaths", vs_maxp_toomanypaths)},
    {SWIG_LUA_CONSTTAB_INT("vs_maxp_toomanycomppoints", vs_maxp_toomanycomppoints)},
    {SWIG_LUA_CONSTTAB_INT("vs_maxp_toomanycomppaths", vs_maxp_toomanycomppaths)},
    {SWIG_LUA_CONSTTAB_INT("vs_maxp_instrtoolong", vs_maxp_instrtoolong)},
    {SWIG_LUA_CONSTTAB_INT("vs_maxp_toomanyrefs", vs_maxp_toomanyrefs)},
    {SWIG_LUA_CONSTTAB_INT("vs_maxp_refstoodeep", vs_maxp_refstoodeep)},
    {SWIG_LUA_CONSTTAB_INT("vs_pointstoofarapart", vs_pointstoofarapart)},
    {SWIG_LUA_CONSTTAB_INT("vs_nonintegral", vs_nonintegral)},
    {SWIG_LUA_CONSTTAB_INT("vs_missinganchor", vs_missinganchor)},
    {SWIG_LUA_CONSTTAB_INT("vs_dupname", vs_dupname)},
    {SWIG_LUA_CONSTTAB_INT("vs_dupunicode", vs_dupunicode)},
    {SWIG_LUA_CONSTTAB_INT("vs_overlappedhints", vs_overlappedhints)},
    {SWIG_LUA_CONSTTAB_INT("vs_last", vs_last)},
    {SWIG_LUA_CONSTTAB_INT("vs_maskps", vs_maskps)},
    {SWIG_LUA_CONSTTAB_INT("vs_maskcid", vs_maskcid)},
    {SWIG_LUA_CONSTTAB_INT("vs_maskttf", vs_maskttf)},
    {SWIG_LUA_CONSTTAB_INT("vs_maskfindproblems", vs_maskfindproblems)},
    {SWIG_LUA_CONSTTAB_INT("TEX_UNDEF", 0x7fff)},
    {SWIG_LUA_CONSTTAB_INT("ttf_copyright", ttf_copyright)},
    {SWIG_LUA_CONSTTAB_INT("ttf_family", ttf_family)},
    {SWIG_LUA_CONSTTAB_INT("ttf_subfamily", ttf_subfamily)},
    {SWIG_LUA_CONSTTAB_INT("ttf_uniqueid", ttf_uniqueid)},
    {SWIG_LUA_CONSTTAB_INT("ttf_fullname", ttf_fullname)},
    {SWIG_LUA_CONSTTAB_INT("ttf_version", ttf_version)},
    {SWIG_LUA_CONSTTAB_INT("ttf_postscriptname", ttf_postscriptname)},
    {SWIG_LUA_CONSTTAB_INT("ttf_trademark", ttf_trademark)},
    {SWIG_LUA_CONSTTAB_INT("ttf_manufacturer", ttf_manufacturer)},
    {SWIG_LUA_CONSTTAB_INT("ttf_designer", ttf_designer)},
    {SWIG_LUA_CONSTTAB_INT("ttf_descriptor", ttf_descriptor)},
    {SWIG_LUA_CONSTTAB_INT("ttf_venderurl", ttf_venderurl)},
    {SWIG_LUA_CONSTTAB_INT("ttf_designerurl", ttf_designerurl)},
    {SWIG_LUA_CONSTTAB_INT("ttf_license", ttf_license)},
    {SWIG_LUA_CONSTTAB_INT("ttf_licenseurl", ttf_licenseurl)},
    {SWIG_LUA_CONSTTAB_INT("ttf_idontknow", ttf_idontknow)},
    {SWIG_LUA_CONSTTAB_INT("ttf_preffamilyname", ttf_preffamilyname)},
    {SWIG_LUA_CONSTTAB_INT("ttf_prefmodifiers", ttf_prefmodifiers)},
    {SWIG_LUA_CONSTTAB_INT("ttf_compatfull", ttf_compatfull)},
    {SWIG_LUA_CONSTTAB_INT("ttf_sampletext", ttf_sampletext)},
    {SWIG_LUA_CONSTTAB_INT("ttf_cidfindfontname", ttf_cidfindfontname)},
    {SWIG_LUA_CONSTTAB_INT("ttf_wwsfamily", ttf_wwsfamily)},
    {SWIG_LUA_CONSTTAB_INT("ttf_wwssubfamily", ttf_wwssubfamily)},
    {SWIG_LUA_CONSTTAB_INT("ttf_namemax", ttf_namemax)},
    {SWIG_LUA_CONSTTAB_INT("bs_dontknow", bs_dontknow)},
    {SWIG_LUA_CONSTTAB_INT("bs_not", bs_not)},
    {SWIG_LUA_CONSTTAB_INT("bs_backedup", bs_backedup)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_ps_fontname", lvs_bad_ps_fontname)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_glyph_table", lvs_bad_glyph_table)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_cff_table", lvs_bad_cff_table)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_metrics_table", lvs_bad_metrics_table)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_cmap_table", lvs_bad_cmap_table)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_bitmaps_table", lvs_bad_bitmaps_table)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_gx_table", lvs_bad_gx_table)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_ot_table", lvs_bad_ot_table)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_os2_version", lvs_bad_os2_version)},
    {SWIG_LUA_CONSTTAB_INT("lvs_bad_sfnt_header", lvs_bad_sfnt_header)},
    {SWIG_LUA_CONSTTAB_INT("tex_unset", tex_unset)},
    {SWIG_LUA_CONSTTAB_INT("tex_text", tex_text)},
    {SWIG_LUA_CONSTTAB_INT("tex_math", tex_math)},
    {SWIG_LUA_CONSTTAB_INT("tex_mathext", tex_mathext)},
    {SWIG_LUA_CONSTTAB_INT("sfntRevisionUnset", 0x44445555)},
    {SWIG_LUA_CONSTTAB_INT("woffUnset", 0x4455)},
    {SWIG_LUA_CONSTTAB_INT("sf_bold", sf_bold)},
    {SWIG_LUA_CONSTTAB_INT("sf_italic", sf_italic)},
    {SWIG_LUA_CONSTTAB_INT("sf_underline", sf_underline)},
    {SWIG_LUA_CONSTTAB_INT("sf_outline", sf_outline)},
    {SWIG_LUA_CONSTTAB_INT("sf_shadow", sf_shadow)},
    {SWIG_LUA_CONSTTAB_INT("sf_condense", sf_condense)},
    {SWIG_LUA_CONSTTAB_INT("sf_extend", sf_extend)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_shortps", ttf_flag_shortps)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_nohints", ttf_flag_nohints)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_applemode", ttf_flag_applemode)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_pfed_comments", ttf_flag_pfed_comments)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_pfed_colors", ttf_flag_pfed_colors)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_otmode", ttf_flag_otmode)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_glyphmap", ttf_flag_glyphmap)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_TeXtable", ttf_flag_TeXtable)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_ofm", ttf_flag_ofm)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_oldkern", ttf_flag_oldkern)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_brokensize", ttf_flag_brokensize)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_pfed_lookupnames", ttf_flag_pfed_lookupnames)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_pfed_guides", ttf_flag_pfed_guides)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_pfed_layers", ttf_flag_pfed_layers)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_symbol", ttf_flag_symbol)},
    {SWIG_LUA_CONSTTAB_INT("ttf_flag_dummyDSIG", ttf_flag_dummyDSIG)},
    {SWIG_LUA_CONSTTAB_INT("ttc_flag_trymerge", ttc_flag_trymerge)},
    {SWIG_LUA_CONSTTAB_INT("ttc_flag_cff", ttc_flag_cff)},
    {SWIG_LUA_CONSTTAB_INT("of_fstypepermitted", of_fstypepermitted)},
    {SWIG_LUA_CONSTTAB_INT("of_askcmap", of_askcmap)},
    {SWIG_LUA_CONSTTAB_INT("of_all_glyphs_in_ttc", of_all_glyphs_in_ttc)},
    {SWIG_LUA_CONSTTAB_INT("of_fontlint", of_fontlint)},
    {SWIG_LUA_CONSTTAB_INT("of_hidewindow", of_hidewindow)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_nohintsubs", ps_flag_nohintsubs)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_noflex", ps_flag_noflex)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_nohints", ps_flag_nohints)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_restrict256", ps_flag_restrict256)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_afm", ps_flag_afm)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_pfm", ps_flag_pfm)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_tfm", ps_flag_tfm)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_round", ps_flag_round)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_nocffsugar", ps_flag_nocffsugar)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_identitycidmap", ps_flag_identitycidmap)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_afmwithmarks", ps_flag_afmwithmarks)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_noseac", ps_flag_noseac)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_outputfontlog", ps_flag_outputfontlog)},
    {SWIG_LUA_CONSTTAB_INT("ps_flag_mask", ps_flag_mask)},
    {SWIG_LUA_CONSTTAB_INT("ars_tar", ars_tar)},
    {SWIG_LUA_CONSTTAB_INT("ars_zip", ars_zip)},
    {SWIG_LUA_CONSTTAB_INT("ff_pfa", ff_pfa)},
    {SWIG_LUA_CONSTTAB_INT("ff_pfb", ff_pfb)},
    {SWIG_LUA_CONSTTAB_INT("ff_pfbmacbin", ff_pfbmacbin)},
    {SWIG_LUA_CONSTTAB_INT("ff_multiple", ff_multiple)},
    {SWIG_LUA_CONSTTAB_INT("ff_mma", ff_mma)},
    {SWIG_LUA_CONSTTAB_INT("ff_mmb", ff_mmb)},
    {SWIG_LUA_CONSTTAB_INT("ff_ptype3", ff_ptype3)},
    {SWIG_LUA_CONSTTAB_INT("ff_ptype0", ff_ptype0)},
    {SWIG_LUA_CONSTTAB_INT("ff_cid", ff_cid)},
    {SWIG_LUA_CONSTTAB_INT("ff_cff", ff_cff)},
    {SWIG_LUA_CONSTTAB_INT("ff_cffcid", ff_cffcid)},
    {SWIG_LUA_CONSTTAB_INT("ff_type42", ff_type42)},
    {SWIG_LUA_CONSTTAB_INT("ff_type42cid", ff_type42cid)},
    {SWIG_LUA_CONSTTAB_INT("ff_ttf", ff_ttf)},
    {SWIG_LUA_CONSTTAB_INT("ff_ttfsym", ff_ttfsym)},
    {SWIG_LUA_CONSTTAB_INT("ff_ttfmacbin", ff_ttfmacbin)},
    {SWIG_LUA_CONSTTAB_INT("ff_ttc", ff_ttc)},
    {SWIG_LUA_CONSTTAB_INT("ff_ttfdfont", ff_ttfdfont)},
    {SWIG_LUA_CONSTTAB_INT("ff_otf", ff_otf)},
    {SWIG_LUA_CONSTTAB_INT("ff_otfdfont", ff_otfdfont)},
    {SWIG_LUA_CONSTTAB_INT("ff_otfcid", ff_otfcid)},
    {SWIG_LUA_CONSTTAB_INT("ff_otfciddfont", ff_otfciddfont)},
    {SWIG_LUA_CONSTTAB_INT("ff_svg", ff_svg)},
    {SWIG_LUA_CONSTTAB_INT("ff_ufo", ff_ufo)},
    {SWIG_LUA_CONSTTAB_INT("ff_woff", ff_woff)},
    {SWIG_LUA_CONSTTAB_INT("ff_none", ff_none)},
    {SWIG_LUA_CONSTTAB_INT("bf_bdf", bf_bdf)},
    {SWIG_LUA_CONSTTAB_INT("bf_ttf", bf_ttf)},
    {SWIG_LUA_CONSTTAB_INT("bf_sfnt_dfont", bf_sfnt_dfont)},
    {SWIG_LUA_CONSTTAB_INT("bf_sfnt_ms", bf_sfnt_ms)},
    {SWIG_LUA_CONSTTAB_INT("bf_otb", bf_otb)},
    {SWIG_LUA_CONSTTAB_INT("bf_nfntmacbin", bf_nfntmacbin)},
    {SWIG_LUA_CONSTTAB_INT("bf_fon", bf_fon)},
    {SWIG_LUA_CONSTTAB_INT("bf_fnt", bf_fnt)},
    {SWIG_LUA_CONSTTAB_INT("bf_palm", bf_palm)},
    {SWIG_LUA_CONSTTAB_INT("bf_ptype3", bf_ptype3)},
    {SWIG_LUA_CONSTTAB_INT("bf_none", bf_none)},
    {SWIG_LUA_CONSTTAB_INT("tpt_OnlySelected", tpt_OnlySelected)},
    {SWIG_LUA_CONSTTAB_INT("tpt_AllPoints", tpt_AllPoints)},
    {SWIG_LUA_CONSTTAB_INT("tpt_OnlySelectedInterpCPs", tpt_OnlySelectedInterpCPs)},
    {SWIG_LUA_CONSTTAB_INT("pf_antialias", pf_antialias)},
    {SWIG_LUA_CONSTTAB_INT("pf_bbsized", pf_bbsized)},
    {SWIG_LUA_CONSTTAB_INT("pf_ft_nohints", pf_ft_nohints)},
    {SWIG_LUA_CONSTTAB_INT("pf_ft_recontext", pf_ft_recontext)},
    {SWIG_LUA_CONSTTAB_FLOAT("CURVATURE_ERROR", -1e9)},
    {SWIG_LUA_CONSTTAB_INT("ae_all", ae_all)},
    {SWIG_LUA_CONSTTAB_INT("ae_between_selected", ae_between_selected)},
    {SWIG_LUA_CONSTTAB_INT("ae_only_good", ae_only_good)},
    {SWIG_LUA_CONSTTAB_INT("ae_only_good_rm_later", ae_only_good_rm_later)},
    {SWIG_LUA_CONSTTAB_INT("ttf_onlystrikes", ttf_onlystrikes)},
    {SWIG_LUA_CONSTTAB_INT("ttf_onlyonestrike", ttf_onlyonestrike)},
    {SWIG_LUA_CONSTTAB_INT("ttf_onlykerns", ttf_onlykerns)},
    {SWIG_LUA_CONSTTAB_INT("ttf_onlynames", ttf_onlynames)},
    {SWIG_LUA_CONSTTAB_INT("UNDEFINED_WIDTH", -999999)},
    {SWIG_LUA_CONSTTAB_INT("sf_handle_eraser", sf_handle_eraser)},
    {SWIG_LUA_CONSTTAB_INT("sf_correctdir", sf_correctdir)},
    {SWIG_LUA_CONSTTAB_INT("sf_clearbeforeinput", sf_clearbeforeinput)},
    {SWIG_LUA_CONSTTAB_INT("SS_DiffContourCount", SS_DiffContourCount)},
    {SWIG_LUA_CONSTTAB_INT("SS_MismatchOpenClosed", SS_MismatchOpenClosed)},
    {SWIG_LUA_CONSTTAB_INT("SS_DisorderedContours", SS_DisorderedContours)},
    {SWIG_LUA_CONSTTAB_INT("SS_DisorderedStart", SS_DisorderedStart)},
    {SWIG_LUA_CONSTTAB_INT("SS_DisorderedDirection", SS_DisorderedDirection)},
    {SWIG_LUA_CONSTTAB_INT("SS_PointsMatch", SS_PointsMatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_ContourMatch", SS_ContourMatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_NoMatch", SS_NoMatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_RefMismatch", SS_RefMismatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_WidthMismatch", SS_WidthMismatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_VWidthMismatch", SS_VWidthMismatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_HintMismatch", SS_HintMismatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_HintMaskMismatch", SS_HintMaskMismatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_LayerCntMismatch", SS_LayerCntMismatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_ContourMismatch", SS_ContourMismatch)},
    {SWIG_LUA_CONSTTAB_INT("SS_UnlinkRefMatch", SS_UnlinkRefMatch)},
    {SWIG_LUA_CONSTTAB_INT("BC_DepthMismatch", BC_DepthMismatch)},
    {SWIG_LUA_CONSTTAB_INT("BC_BoundingBoxMismatch", BC_BoundingBoxMismatch)},
    {SWIG_LUA_CONSTTAB_INT("BC_BitmapMismatch", BC_BitmapMismatch)},
    {SWIG_LUA_CONSTTAB_INT("BC_NoMatch", BC_NoMatch)},
    {SWIG_LUA_CONSTTAB_INT("BC_Match", BC_Match)},
    {SWIG_LUA_CONSTTAB_INT("SS_RefPtMismatch", SS_RefPtMismatch)},
    {SWIG_LUA_CONSTTAB_INT("fcf_outlines", fcf_outlines)},
    {SWIG_LUA_CONSTTAB_INT("fcf_exact", fcf_exact)},
    {SWIG_LUA_CONSTTAB_INT("fcf_warn_not_exact", fcf_warn_not_exact)},
    {SWIG_LUA_CONSTTAB_INT("fcf_hinting", fcf_hinting)},
    {SWIG_LUA_CONSTTAB_INT("fcf_hintmasks", fcf_hintmasks)},
    {SWIG_LUA_CONSTTAB_INT("fcf_hmonlywithconflicts", fcf_hmonlywithconflicts)},
    {SWIG_LUA_CONSTTAB_INT("fcf_warn_not_ref_exact", fcf_warn_not_ref_exact)},
    {SWIG_LUA_CONSTTAB_INT("fcf_bitmaps", fcf_bitmaps)},
    {SWIG_LUA_CONSTTAB_INT("fcf_names", fcf_names)},
    {SWIG_LUA_CONSTTAB_INT("fcf_gpos", fcf_gpos)},
    {SWIG_LUA_CONSTTAB_INT("fcf_gsub", fcf_gsub)},
    {SWIG_LUA_CONSTTAB_INT("fcf_adddiff2sf1", fcf_adddiff2sf1)},
    {SWIG_LUA_CONSTTAB_INT("fcf_addmissing", fcf_addmissing)},
    {SWIG_LUA_CONSTTAB_INT("SCRIPT_MENU_MAX", 10)},
    {SWIG_LUA_CONSTTAB_INT("PfEd_TAG", ((('P') << 24)|(('f') << 16)|(('E') << 8)|('d')))},
    {SWIG_LUA_CONSTTAB_INT("fcmt_TAG", ((('f') << 24)|(('c') << 16)|(('m') << 8)|('t')))},
    {SWIG_LUA_CONSTTAB_INT("flog_TAG", ((('f') << 24)|(('l') << 16)|(('o') << 8)|('g')))},
    {SWIG_LUA_CONSTTAB_INT("cmnt_TAG", ((('c') << 24)|(('m') << 16)|(('n') << 8)|('t')))},
    {SWIG_LUA_CONSTTAB_INT("cvtc_TAG", ((('c') << 24)|(('v') << 16)|(('t') << 8)|('c')))},
    {SWIG_LUA_CONSTTAB_INT("colr_TAG", ((('c') << 24)|(('o') << 16)|(('l') << 8)|('r')))},
    {SWIG_LUA_CONSTTAB_INT("GPOS_TAG", ((('G') << 24)|(('P') << 16)|(('O') << 8)|('S')))},
    {SWIG_LUA_CONSTTAB_INT("GSUB_TAG", ((('G') << 24)|(('S') << 16)|(('U') << 8)|('B')))},
    {SWIG_LUA_CONSTTAB_INT("guid_TAG", ((('g') << 24)|(('u') << 16)|(('i') << 8)|('d')))},
    {SWIG_LUA_CONSTTAB_INT("layr_TAG", ((('l') << 24)|(('a') << 16)|(('y') << 8)|('r')))},
    {SWIG_LUA_CONSTTAB_INT("V_B", 0)},
    {SWIG_LUA_CONSTTAB_INT("V_S", 1)},
    {SWIG_LUA_CONSTTAB_INT("V_F", 2)},
    {SWIG_LUA_CONSTTAB_INT("V_MoveTo", 0)},
    {SWIG_LUA_CONSTTAB_INT("V_LineTo", 4)},
    {SWIG_LUA_CONSTTAB_INT("V_HLineTo", 8)},
    {SWIG_LUA_CONSTTAB_INT("V_VLineTo", 12)},
    {SWIG_LUA_CONSTTAB_INT("V_QCurveTo", 16)},
    {SWIG_LUA_CONSTTAB_INT("V_QImplicit", 20)},
    {SWIG_LUA_CONSTTAB_INT("V_QHImplicit", 24)},
    {SWIG_LUA_CONSTTAB_INT("V_QVImplicit", 28)},
    {SWIG_LUA_CONSTTAB_INT("V_CurveTo", 32)},
    {SWIG_LUA_CONSTTAB_INT("V_VHCurveTo", 36)},
    {SWIG_LUA_CONSTTAB_INT("V_HVCurveTo", 40)},
    {SWIG_LUA_CONSTTAB_INT("V_Close", 44)},
    {SWIG_LUA_CONSTTAB_INT("V_End", 45)},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_OPEN_CONTOUR", '{')},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_CORNER", 'v')},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_G4", 'o')},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_G2", 'c')},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_LEFT", '[')},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_RIGHT", ']')},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_END", 'z')},
    {SWIG_LUA_CONSTTAB_CHAR("SPIRO_CLOSE_CONTOUR", '}')},
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_ASM_state = {"_p_ASM_state", "ASM_state *", 0, 0, (void*)&_wrap_class_ASM_state, 0};
static swig_type_info _swigt__p_ASM_state_u = {"_p_ASM_state_u", "ASM_state_u *", 0, 0, (void*)&_wrap_class_ASM_state_u, 0};
static swig_type_info _swigt__p_ASM_state_u_context = {"_p_ASM_state_u_context", "ASM_state_u_context *", 0, 0, (void*)&_wrap_class_ASM_state_u_context, 0};
static swig_type_info _swigt__p_ASM_state_u_insert = {"_p_ASM_state_u_insert", "ASM_state_u_insert *", 0, 0, (void*)&_wrap_class_ASM_state_u_insert, 0};
static swig_type_info _swigt__p_ASM_state_u_kern = {"_p_ASM_state_u_kern", "ASM_state_u_kern *", 0, 0, (void*)&_wrap_class_ASM_state_u_kern, 0};
static swig_type_info _swigt__p_BDFChar_dependents = {"_p_BDFChar_dependents", "BDFChar_dependents *", 0, 0, (void*)&_wrap_class_BDFChar_dependents, 0};
static swig_type_info _swigt__p_BDFProperties_u = {"_p_BDFProperties_u", "BDFProperties_u *", 0, 0, (void*)&_wrap_class_BDFProperties_u, 0};
static swig_type_info _swigt__p_Base = {"_p_Base", "struct Base *|Base *", 0, 0, (void*)&_wrap_class_Base, 0};
static swig_type_info _swigt__p_FILE = {"_p_FILE", "FILE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FPST_rules = {"_p_FPST_rules", "FPST_rules *", 0, 0, (void*)&_wrap_class_FPST_rules, 0};
static swig_type_info _swigt__p_FPST_rules_lookups = {"_p_FPST_rules_lookups", "FPST_rules_lookups *", 0, 0, (void*)&_wrap_class_FPST_rules_lookups, 0};
static swig_type_info _swigt__p_FPST_rules_u = {"_p_FPST_rules_u", "FPST_rules_u *", 0, 0, (void*)&_wrap_class_FPST_rules_u, 0};
static swig_type_info _swigt__p_FPST_rules_u_class = {"_p_FPST_rules_u_class", "FPST_rules_u_class *", 0, 0, (void*)&_wrap_class_FPST_rules_u_class, 0};
static swig_type_info _swigt__p_FPST_rules_u_coverage = {"_p_FPST_rules_u_coverage", "FPST_rules_u_coverage *", 0, 0, (void*)&_wrap_class_FPST_rules_u_coverage, 0};
static swig_type_info _swigt__p_FPST_rules_u_glyph = {"_p_FPST_rules_u_glyph", "FPST_rules_u_glyph *", 0, 0, (void*)&_wrap_class_FPST_rules_u_glyph, 0};
static swig_type_info _swigt__p_FPST_rules_u_rcoverage = {"_p_FPST_rules_u_rcoverage", "FPST_rules_u_rcoverage *", 0, 0, (void*)&_wrap_class_FPST_rules_u_rcoverage, 0};
static swig_type_info _swigt__p_ItalicInfo_lc = {"_p_ItalicInfo_lc", "ItalicInfo_lc *", 0, 0, (void*)&_wrap_class_ItalicInfo_lc, 0};
static swig_type_info _swigt__p_ItalicInfo_neither = {"_p_ItalicInfo_neither", "ItalicInfo_neither *", 0, 0, (void*)&_wrap_class_ItalicInfo_neither, 0};
static swig_type_info _swigt__p_ItalicInfo_uc = {"_p_ItalicInfo_uc", "ItalicInfo_uc *", 0, 0, (void*)&_wrap_class_ItalicInfo_uc, 0};
static swig_type_info _swigt__p_MATH = {"_p_MATH", "struct MATH *|MATH *", 0, 0, (void*)&_wrap_class_MATH, 0};
static swig_type_info _swigt__p_MMSet_axismaps = {"_p_MMSet_axismaps", "MMSet_axismaps *", 0, 0, (void*)&_wrap_class_MMSet_axismaps, 0};
static swig_type_info _swigt__p_MMSet_named_instances = {"_p_MMSet_named_instances", "MMSet_named_instances *", 0, 0, (void*)&_wrap_class_MMSet_named_instances, 0};
static swig_type_info _swigt__p_MacFeat_settings = {"_p_MacFeat_settings", "MacFeat_settings *", 0, 0, (void*)&_wrap_class_MacFeat_settings, 0};
static swig_type_info _swigt__p_NameList_renames = {"_p_NameList_renames", "NameList_renames *", 0, 0, (void*)&_wrap_class_NameList_renames, 0};
static swig_type_info _swigt__p_OTLookup_subtables = {"_p_OTLookup_subtables", "OTLookup_subtables *", 0, 0, (void*)&_wrap_class_OTLookup_subtables, 0};
static swig_type_info _swigt__p_PST_u = {"_p_PST_u", "PST_u *", 0, 0, (void*)&_wrap_class_PST_u, 0};
static swig_type_info _swigt__p_PST_u_alt = {"_p_PST_u_alt", "PST_u_alt *", 0, 0, (void*)&_wrap_class_PST_u_alt, 0};
static swig_type_info _swigt__p_PST_u_lcaret = {"_p_PST_u_lcaret", "PST_u_lcaret *", 0, 0, (void*)&_wrap_class_PST_u_lcaret, 0};
static swig_type_info _swigt__p_PST_u_lig = {"_p_PST_u_lig", "PST_u_lig *", 0, 0, (void*)&_wrap_class_PST_u_lig, 0};
static swig_type_info _swigt__p_PST_u_mult = {"_p_PST_u_mult", "PST_u_mult *", 0, 0, (void*)&_wrap_class_PST_u_mult, 0};
static swig_type_info _swigt__p_PST_u_pair = {"_p_PST_u_pair", "PST_u_pair *", 0, 0, (void*)&_wrap_class_PST_u_pair, 0};
static swig_type_info _swigt__p_PST_u_subs = {"_p_PST_u_subs", "PST_u_subs *", 0, 0, (void*)&_wrap_class_PST_u_subs, 0};
static swig_type_info _swigt__p_RefChar_layers = {"_p_RefChar_layers", "RefChar_layers *", 0, 0, (void*)&_wrap_class_RefChar_layers, 0};
static swig_type_info _swigt__p_SplineChar_altuni = {"_p_SplineChar_altuni", "SplineChar_altuni *", 0, 0, (void*)&_wrap_class_SplineChar_altuni, 0};
static swig_type_info _swigt__p_SplineChar_dependents = {"_p_SplineChar_dependents", "SplineChar_dependents *", 0, 0, (void*)&_wrap_class_SplineChar_dependents, 0};
static swig_type_info _swigt__p_SplineFont_gasp = {"_p_SplineFont_gasp", "SplineFont_gasp *", 0, 0, (void*)&_wrap_class_SplineFont_gasp, 0};
static swig_type_info _swigt__p_SplineFont_pfminfo = {"_p_SplineFont_pfminfo", "SplineFont_pfminfo *", 0, 0, (void*)&_wrap_class_SplineFont_pfminfo, 0};
static swig_type_info _swigt__p_SplineFont_ttf_tab_saved = {"_p_SplineFont_ttf_tab_saved", "SplineFont_ttf_tab_saved *", 0, 0, (void*)&_wrap_class_SplineFont_ttf_tab_saved, 0};
static swig_type_info _swigt__p_SplineFont_ttf_tables = {"_p_SplineFont_ttf_tables", "SplineFont_ttf_tables *", 0, 0, (void*)&_wrap_class_SplineFont_ttf_tables, 0};
static swig_type_info _swigt__p_StemInfo_u = {"_p_StemInfo_u", "StemInfo_u *", 0, 0, (void*)&_wrap_class_StemInfo_u, 0};
static swig_type_info _swigt__p_Undoes_u = {"_p_Undoes_u", "Undoes_u *", 0, 0, (void*)&_wrap_class_Undoes_u, 0};
static swig_type_info _swigt__p_Undoes_u_composit = {"_p_Undoes_u_composit", "Undoes_u_composit *", 0, 0, (void*)&_wrap_class_Undoes_u_composit, 0};
static swig_type_info _swigt__p_Undoes_u_multiple = {"_p_Undoes_u_multiple", "Undoes_u_multiple *", 0, 0, (void*)&_wrap_class_Undoes_u_multiple, 0};
static swig_type_info _swigt__p_Undoes_u_possub = {"_p_Undoes_u_possub", "Undoes_u_possub *", 0, 0, (void*)&_wrap_class_Undoes_u_possub, 0};
static swig_type_info _swigt__p_Undoes_u_state = {"_p_Undoes_u_state", "Undoes_u_state *", 0, 0, (void*)&_wrap_class_Undoes_u_state, 0};
static swig_type_info _swigt__p_Val_u = {"_p_Val_u", "Val_u *", 0, 0, (void*)&_wrap_class_Val_u, 0};
static swig_type_info _swigt__p_a_2__a_16__float = {"_p_a_2__a_16__float", "_MMArray *|float (*)[2][16]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_2__float = {"_p_a_2__float", "float (*)[2]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_96_8__unsigned_char = {"_p_a_96_8__unsigned_char", "HintMask *|unsigned char (*)[96/8]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_alltabs = {"_p_alltabs", "struct alltabs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_altuni = {"_p_altuni", "struct altuni *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_anchorclass = {"_p_anchorclass", "struct anchorclass *|anchorclass *|AnchorClass *", 0, 0, (void*)&_wrap_class_anchorclass, 0};
static swig_type_info _swigt__p_anchorpoint = {"_p_anchorpoint", "struct anchorpoint *|AnchorPoint *|anchorpoint *", 0, 0, (void*)&_wrap_class_anchorpoint, 0};
static swig_type_info _swigt__p_anchorpos = {"_p_anchorpos", "struct anchorpos *|anchorpos *|AnchorPos *", 0, 0, (void*)&_wrap_class_anchorpos, 0};
static swig_type_info _swigt__p_archivers = {"_p_archivers", "struct archivers *|archivers *", 0, 0, (void*)&_wrap_class_archivers, 0};
static swig_type_info _swigt__p_array = {"_p_array", "struct array *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_baselangextent = {"_p_baselangextent", "struct baselangextent *|baselangextent *", 0, 0, (void*)&_wrap_class_baselangextent, 0};
static swig_type_info _swigt__p_basepoint = {"_p_basepoint", "struct basepoint *|BasePoint *|basepoint *", 0, 0, (void*)&_wrap_class_basepoint, 0};
static swig_type_info _swigt__p_basescript = {"_p_basescript", "struct basescript *|basescript *", 0, 0, (void*)&_wrap_class_basescript, 0};
static swig_type_info _swigt__p_bdfchar = {"_p_bdfchar", "BDFChar *|struct bdfchar *|bdfchar *", 0, 0, (void*)&_wrap_class_bdfchar, 0};
static swig_type_info _swigt__p_bdfcharlist = {"_p_bdfcharlist", "struct bdfcharlist *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_bdffloat = {"_p_bdffloat", "struct bdffloat *|bdffloat *|BDFFloat *", 0, 0, (void*)&_wrap_class_bdffloat, 0};
static swig_type_info _swigt__p_bdffont = {"_p_bdffont", "BDFFont *|struct bdffont *|bdffont *", 0, 0, (void*)&_wrap_class_bdffont, 0};
static swig_type_info _swigt__p_bdfprops = {"_p_bdfprops", "BDFProperties *|struct bdfprops *|bdfprops *", 0, 0, (void*)&_wrap_class_bdfprops, 0};
static swig_type_info _swigt__p_bitmapview = {"_p_bitmapview", "struct bitmapview *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_bluedata = {"_p_bluedata", "struct bluedata *|bluedata *|BlueData *", 0, 0, (void*)&_wrap_class_bluedata, 0};
static swig_type_info _swigt__p_bluezone = {"_p_bluezone", "struct bluezone *|bluezone *|BlueZone *", 0, 0, (void*)&_wrap_class_bluezone, 0};
static swig_type_info _swigt__p_brush = {"_p_brush", "struct brush *|brush *", 0, 0, (void*)&_wrap_class_brush, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_charinfo = {"_p_charinfo", "struct charinfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_charprocs = {"_p_charprocs", "struct charprocs *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_charviewbase = {"_p_charviewbase", "struct charviewbase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cidbytes = {"_p_cidbytes", "struct cidbytes *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_cidmap = {"_p_cidmap", "struct cidmap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_clut = {"_p_clut", "struct clut *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_compressors = {"_p_compressors", "struct compressors *|compressors *", 0, 0, (void*)&_wrap_class_compressors, 0};
static swig_type_info _swigt__p_dbasepoint = {"_p_dbasepoint", "struct dbasepoint *|DBasePoint *|dbasepoint *", 0, 0, (void*)&_wrap_class_dbasepoint, 0};
static swig_type_info _swigt__p_dbounds = {"_p_dbounds", "struct dbounds *|DBounds *|dbounds *", 0, 0, (void*)&_wrap_class_dbounds, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_dsteminfo = {"_p_dsteminfo", "struct dsteminfo *|dsteminfo *|DStemInfo *", 0, 0, (void*)&_wrap_class_dsteminfo, 0};
static swig_type_info _swigt__p_enc = {"_p_enc", "enc *|struct enc *|Encoding *", 0, 0, (void*)&_wrap_class_enc, 0};
static swig_type_info _swigt__p_encmap = {"_p_encmap", "EncMap *|struct encmap *|encmap *", 0, 0, (void*)&_wrap_class_encmap, 0};
static swig_type_info _swigt__p_f_int__int = {"_p_f_int__int", "int (*)(int)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_int_p_void__void = {"_p_f_int_p_void__void", "void (*)(int,void *)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_int_unsigned_int_unsigned_int__void = {"_p_f_p_void_int_unsigned_int_unsigned_int__void", "void (*)(void *,int,unsigned int,unsigned int)|void (*)(void *,int,uint32,uint32)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_p_void_p_struct_spline_float__double = {"_p_f_p_void_p_struct_spline_float__double", "double (*)(void *,struct spline *,float)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_f_void__void = {"_p_f_void__void", "void (*)(void)", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fd2data = {"_p_fd2data", "struct fd2data *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_featurescriptlanglist = {"_p_featurescriptlanglist", "struct featurescriptlanglist *|featurescriptlanglist *|FeatureScriptLangList *", 0, 0, (void*)&_wrap_class_featurescriptlanglist, 0};
static swig_type_info _swigt__p_findsel = {"_p_findsel", "struct findsel *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_float = {"_p_float", "float *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fontdict = {"_p_fontdict", "struct fontdict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fontviewbase = {"_p_fontviewbase", "struct fontviewbase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_fpst_rule = {"_p_fpst_rule", "struct fpst_rule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_freetype_raster = {"_p_freetype_raster", "struct freetype_raster *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_generic_asm = {"_p_generic_asm", "struct generic_asm *|generic_asm *|ASM *", 0, 0, (void*)&_wrap_class_generic_asm, 0};
static swig_type_info _swigt__p_generic_fpst = {"_p_generic_fpst", "struct generic_fpst *|generic_fpst *|FPST *", 0, 0, (void*)&_wrap_class_generic_fpst, 0};
static swig_type_info _swigt__p_generic_pst = {"_p_generic_pst", "struct generic_pst *|generic_pst *|PST *", 0, 0, (void*)&_wrap_class_generic_pst, 0};
static swig_type_info _swigt__p_gfi_data = {"_p_gfi_data", "struct gfi_data *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_gimage = {"_p_gimage", "struct gimage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_globalinstrct = {"_p_globalinstrct", "struct globalinstrct *|globalinstrct *|GlobalInstrCt *", 0, 0, (void*)&_wrap_class_globalinstrct, 0};
static swig_type_info _swigt__p_glyphdata = {"_p_glyphdata", "struct glyphdata *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glyphnamehash = {"_p_glyphnamehash", "struct glyphnamehash *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_glyphvariants = {"_p_glyphvariants", "struct glyphvariants *|glyphvariants *", 0, 0, (void*)&_wrap_class_glyphvariants, 0};
static swig_type_info _swigt__p_glyphvariants_parts = {"_p_glyphvariants_parts", "glyphvariants_parts *", 0, 0, (void*)&_wrap_class_glyphvariants_parts, 0};
static swig_type_info _swigt__p_gradient = {"_p_gradient", "struct gradient *|gradient *", 0, 0, (void*)&_wrap_class_gradient, 0};
static swig_type_info _swigt__p_gradient_grad_stops = {"_p_gradient_grad_stops", "gradient_grad_stops *", 0, 0, (void*)&_wrap_class_gradient_grad_stops, 0};
static swig_type_info _swigt__p_growbuf = {"_p_growbuf", "GrowBuf *|struct growbuf *|growbuf *", 0, 0, (void*)&_wrap_class_growbuf, 0};
static swig_type_info _swigt__p_hintinstance = {"_p_hintinstance", "struct hintinstance *|hintinstance *|HintInstance *", 0, 0, (void*)&_wrap_class_hintinstance, 0};
static swig_type_info _swigt__p_ibounds = {"_p_ibounds", "struct ibounds *|ibounds *|IBounds *", 0, 0, (void*)&_wrap_class_ibounds, 0};
static swig_type_info _swigt__p_iconv_t = {"_p_iconv_t", "iconv_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_imagelist = {"_p_imagelist", "struct imagelist *|imagelist *|ImageList *", 0, 0, (void*)&_wrap_class_imagelist, 0};
static swig_type_info _swigt__p_instrdata = {"_p_instrdata", "struct instrdata *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *|int32 *|int32_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_intptr_t = {"_p_intptr_t", "intptr_t *|intpt *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ipoint = {"_p_ipoint", "struct ipoint *|ipoint *|IPoint *", 0, 0, (void*)&_wrap_class_ipoint, 0};
static swig_type_info _swigt__p_italicinfo = {"_p_italicinfo", "struct italicinfo *|italicinfo *|ItalicInfo *", 0, 0, (void*)&_wrap_class_italicinfo, 0};
static swig_type_info _swigt__p_jstf_lang = {"_p_jstf_lang", "struct jstf_lang *|jstf_lang *", 0, 0, (void*)&_wrap_class_jstf_lang, 0};
static swig_type_info _swigt__p_jstf_prio = {"_p_jstf_prio", "struct jstf_prio *|jstf_prio *", 0, 0, (void*)&_wrap_class_jstf_prio, 0};
static swig_type_info _swigt__p_jstf_script = {"_p_jstf_script", "Justify *|struct jstf_script *|jstf_script *", 0, 0, (void*)&_wrap_class_jstf_script, 0};
static swig_type_info _swigt__p_kernclass = {"_p_kernclass", "struct kernclass *|kernclass *|KernClass *", 0, 0, (void*)&_wrap_class_kernclass, 0};
static swig_type_info _swigt__p_kernclassdlg = {"_p_kernclassdlg", "struct kernclassdlg *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_kernclasslistdlg = {"_p_kernclasslistdlg", "struct kernclasslistdlg *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_kernpair = {"_p_kernpair", "struct kernpair *|kernpair *|KernPair *", 0, 0, (void*)&_wrap_class_kernpair, 0};
static swig_type_info _swigt__p_lang_frequencies = {"_p_lang_frequencies", "struct lang_frequencies *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_layer = {"_p_layer", "struct layer *|Layer *|layer *", 0, 0, (void*)&_wrap_class_layer, 0};
static swig_type_info _swigt__p_layerinfo = {"_p_layerinfo", "LayerInfo *|struct layerinfo *|layerinfo *", 0, 0, (void*)&_wrap_class_layerinfo, 0};
static swig_type_info _swigt__p_library_version_configuration = {"_p_library_version_configuration", "struct library_version_configuration *|library_version_configuration *|Library_Version_Configuration *", 0, 0, (void*)&_wrap_class_library_version_configuration, 0};
static swig_type_info _swigt__p_liglist = {"_p_liglist", "struct liglist *|liglist *|LigList *", 0, 0, (void*)&_wrap_class_liglist, 0};
static swig_type_info _swigt__p_linearapprox = {"_p_linearapprox", "struct linearapprox *|LinearApprox *|linearapprox *", 0, 0, (void*)&_wrap_class_linearapprox, 0};
static swig_type_info _swigt__p_linelist = {"_p_linelist", "struct linelist *|linelist *|LineList *", 0, 0, (void*)&_wrap_class_linelist, 0};
static swig_type_info _swigt__p_lookup_subtable = {"_p_lookup_subtable", "struct lookup_subtable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_macfeat = {"_p_macfeat", "struct macfeat *|macfeat *|MacFeat *", 0, 0, (void*)&_wrap_class_macfeat, 0};
static swig_type_info _swigt__p_macname = {"_p_macname", "struct macname *|macname *", 0, 0, (void*)&_wrap_class_macname, 0};
static swig_type_info _swigt__p_macsetting = {"_p_macsetting", "struct macsetting *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_math_constants_descriptor = {"_p_math_constants_descriptor", "struct math_constants_descriptor *|math_constants_descriptor *", 0, 0, (void*)&_wrap_class_math_constants_descriptor, 0};
static swig_type_info _swigt__p_mathkern = {"_p_mathkern", "struct mathkern *|mathkern *", 0, 0, (void*)&_wrap_class_mathkern, 0};
static swig_type_info _swigt__p_mathkernvertex = {"_p_mathkernvertex", "struct mathkernvertex *|mathkernvertex *", 0, 0, (void*)&_wrap_class_mathkernvertex, 0};
static swig_type_info _swigt__p_mathkernvertex_mkd = {"_p_mathkernvertex_mkd", "mathkernvertex_mkd *", 0, 0, (void*)&_wrap_class_mathkernvertex_mkd, 0};
static swig_type_info _swigt__p_metricsview = {"_p_metricsview", "struct metricsview *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_minimumdistance = {"_p_minimumdistance", "struct minimumdistance *|minimumdistance *|MinimumDistance *", 0, 0, (void*)&_wrap_class_minimumdistance, 0};
static swig_type_info _swigt__p_mmset = {"_p_mmset", "MMSet *|struct mmset *|mmset *", 0, 0, (void*)&_wrap_class_mmset, 0};
static swig_type_info _swigt__p_namelist = {"_p_namelist", "struct namelist *|namelist *|NameList *", 0, 0, (void*)&_wrap_class_namelist, 0};
static swig_type_info _swigt__p_opentype_feature_friendlynames = {"_p_opentype_feature_friendlynames", "struct opentype_feature_friendlynames *|opentype_feature_friendlynames *", 0, 0, (void*)&_wrap_class_opentype_feature_friendlynames, 0};
static swig_type_info _swigt__p_opentype_str = {"_p_opentype_str", "struct opentype_str *|opentype_str *", 0, 0, (void*)&_wrap_class_opentype_str, 0};
static swig_type_info _swigt__p_otffeatname = {"_p_otffeatname", "struct otffeatname *|otffeatname *", 0, 0, (void*)&_wrap_class_otffeatname, 0};
static swig_type_info _swigt__p_otfname = {"_p_otfname", "struct otfname *|otfname *", 0, 0, (void*)&_wrap_class_otfname, 0};
static swig_type_info _swigt__p_otlookup = {"_p_otlookup", "struct otlookup *|OTLookup *|otlookup *", 0, 0, (void*)&_wrap_class_otlookup, 0};
static swig_type_info _swigt__p_p_anchorpoint = {"_p_p_anchorpoint", "struct anchorpoint **|AnchorPoint **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_basepoint = {"_p_p_basepoint", "struct basepoint **|BasePoint **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_bdfchar = {"_p_p_bdfchar", "struct bdfchar **|BDFChar **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_bdffont = {"_p_p_bdffont", "struct bdffont **|BDFFont **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_char = {"_p_p_char", "char **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_dsteminfo = {"_p_p_dsteminfo", "struct dsteminfo **|DStemInfo **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_macfeat = {"_p_p_macfeat", "struct macfeat **|MacFeat **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_macsetting = {"_p_p_macsetting", "struct macsetting **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_otlookup = {"_p_p_otlookup", "struct otlookup **|OTLookup **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_p_lang_frequencies = {"_p_p_p_lang_frequencies", "struct lang_frequencies ***", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_p_p_char = {"_p_p_p_p_char", "char ****", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_p_splinechar = {"_p_p_p_splinechar", "struct splinechar ***|SplineChar ***", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_p_unicode_nameannot = {"_p_p_p_unicode_nameannot", "struct unicode_nameannot ***", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_pschars = {"_p_p_pschars", "struct pschars **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_spline = {"_p_p_spline", "struct spline **|Spline **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_splinechar = {"_p_p_splinechar", "struct splinechar **|SplineChar **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_splinefont = {"_p_p_splinefont", "struct splinefont **|SplineFont **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_splinepoint = {"_p_p_splinepoint", "struct splinepoint **|SplinePoint **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_splinepointlist = {"_p_p_splinepointlist", "SplineSet **|struct splinepointlist **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_unsigned_char = {"_p_p_unsigned_char", "unsigned char **|uint8 **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pattern = {"_p_pattern", "struct pattern *|pattern *", 0, 0, (void*)&_wrap_class_pattern, 0};
static swig_type_info _swigt__p_pen = {"_p_pen", "pen *|struct pen *", 0, 0, (void*)&_wrap_class_pen, 0};
static swig_type_info _swigt__p_pfminfo = {"_p_pfminfo", "struct pfminfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_pschars = {"_p_pschars", "struct pschars *|pschars *", 0, 0, (void*)&_wrap_class_pschars, 0};
static swig_type_info _swigt__p_pscontext = {"_p_pscontext", "struct pscontext *|pscontext *", 0, 0, (void*)&_wrap_class_pscontext, 0};
static swig_type_info _swigt__p_psdict = {"_p_psdict", "struct psdict *|psdict *", 0, 0, (void*)&_wrap_class_psdict, 0};
static swig_type_info _swigt__p_refbdfc = {"_p_refbdfc", "struct refbdfc *|refbdfc *|BDFRefChar *", 0, 0, (void*)&_wrap_class_refbdfc, 0};
static swig_type_info _swigt__p_refchar = {"_p_refchar", "RefChar *|struct refchar *|refchar *", 0, 0, (void*)&_wrap_class_refchar, 0};
static swig_type_info _swigt__p_remap = {"_p_remap", "struct remap *|remap *", 0, 0, (void*)&_wrap_class_remap, 0};
static swig_type_info _swigt__p_scriptlanglist = {"_p_scriptlanglist", "struct scriptlanglist *|scriptlanglist *", 0, 0, (void*)&_wrap_class_scriptlanglist, 0};
static swig_type_info _swigt__p_sflist = {"_p_sflist", "struct sflist *|sflist *", 0, 0, (void*)&_wrap_class_sflist, 0};
static swig_type_info _swigt__p_sfmergecontext = {"_p_sfmergecontext", "struct sfmergecontext *|sfmergecontext *", 0, 0, (void*)&_wrap_class_sfmergecontext, 0};
static swig_type_info _swigt__p_sfmergecontext_acs = {"_p_sfmergecontext_acs", "sfmergecontext_acs *", 0, 0, (void*)&_wrap_class_sfmergecontext_acs, 0};
static swig_type_info _swigt__p_sfmergecontext_lks = {"_p_sfmergecontext_lks", "sfmergecontext_lks *", 0, 0, (void*)&_wrap_class_sfmergecontext_lks, 0};
static swig_type_info _swigt__p_sfmergecontext_subs = {"_p_sfmergecontext_subs", "sfmergecontext_subs *", 0, 0, (void*)&_wrap_class_sfmergecontext_subs, 0};
static swig_type_info _swigt__p_short = {"_p_short", "int16 *|short *|int16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_shortview = {"_p_shortview", "struct shortview *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int8 *|int8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_simplifyinfo = {"_p_simplifyinfo", "struct simplifyinfo *|simplifyinfo *", 0, 0, (void*)&_wrap_class_simplifyinfo, 0};
static swig_type_info _swigt__p_sllk = {"_p_sllk", "struct sllk *|sllk *", 0, 0, (void*)&_wrap_class_sllk, 0};
static swig_type_info _swigt__p_spiro_cp = {"_p_spiro_cp", "spiro_cp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_spline = {"_p_spline", "struct spline *|Spline *|spline *", 0, 0, (void*)&_wrap_class_spline, 0};
static swig_type_info _swigt__p_spline1d = {"_p_spline1d", "Spline1D *|struct spline1d *|spline1d *", 0, 0, (void*)&_wrap_class_spline1d, 0};
static swig_type_info _swigt__p_splinechar = {"_p_splinechar", "struct splinechar *|splinechar *|SplineChar *", 0, 0, (void*)&_wrap_class_splinechar, 0};
static swig_type_info _swigt__p_splinecharlist = {"_p_splinecharlist", "struct splinecharlist *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_splinefont = {"_p_splinefont", "struct splinefont *|splinefont *|SplineFont *", 0, 0, (void*)&_wrap_class_splinefont, 0};
static swig_type_info _swigt__p_splinepoint = {"_p_splinepoint", "struct splinepoint *|SplinePoint *|splinepoint *", 0, 0, (void*)&_wrap_class_splinepoint, 0};
static swig_type_info _swigt__p_splinepointlist = {"_p_splinepointlist", "SplinePointList *|struct splinepointlist *|splinepointlist *|SplineSet *", 0, 0, (void*)&_wrap_class_splinepointlist, 0};
static swig_type_info _swigt__p_std_bdf_props = {"_p_std_bdf_props", "struct std_bdf_props *|std_bdf_props *", 0, 0, (void*)&_wrap_class_std_bdf_props, 0};
static swig_type_info _swigt__p_stdstem = {"_p_stdstem", "StdStem *|struct stdstem *|stdstem *", 0, 0, (void*)&_wrap_class_stdstem, 0};
static swig_type_info _swigt__p_steminfo = {"_p_steminfo", "struct steminfo *|steminfo *|StemInfo *", 0, 0, (void*)&_wrap_class_steminfo, 0};
static swig_type_info _swigt__p_strokeinfo = {"_p_strokeinfo", "struct strokeinfo *|strokeinfo *|StrokeInfo *", 0, 0, (void*)&_wrap_class_strokeinfo, 0};
static swig_type_info _swigt__p_tex_data = {"_p_tex_data", "struct tex_data *|tex_data *|TeXData *", 0, 0, (void*)&_wrap_class_tex_data, 0};
static swig_type_info _swigt__p_tpoint = {"_p_tpoint", "struct tpoint *|tpoint *|TPoint *", 0, 0, (void*)&_wrap_class_tpoint, 0};
static swig_type_info _swigt__p_ttf_table = {"_p_ttf_table", "struct ttf_table *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ttfinfo = {"_p_ttfinfo", "struct ttfinfo *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ttflangname = {"_p_ttflangname", "struct ttflangname *|ttflangname *", 0, 0, (void*)&_wrap_class_ttflangname, 0};
static swig_type_info _swigt__p_undoes = {"_p_undoes", "struct undoes *|Undoes *|undoes *", 0, 0, (void*)&_wrap_class_undoes, 0};
static swig_type_info _swigt__p_unicode_nameannot = {"_p_unicode_nameannot", "struct unicode_nameannot *|unicode_nameannot *", 0, 0, (void*)&_wrap_class_unicode_nameannot, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "DashType *|unsigned char *|uint8 *|uint8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uint32 *|uint32_t *|unsigned int *|unichar_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "uint16 *|unsigned short *|uint16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_val = {"_p_val", "Val *|val *|struct val *", 0, 0, (void*)&_wrap_class_val, 0};
static swig_type_info _swigt__p_val_data = {"_p_val_data", "struct val_data *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_void = {"_p_void", "void *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_vr = {"_p_vr", "struct vr *|vr *", 0, 0, (void*)&_wrap_class_vr, 0};
static swig_type_info _swigt__p_xlfd_components = {"_p_xlfd_components", "struct xlfd_components *|xlfd_components *", 0, 0, (void*)&_wrap_class_xlfd_components, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_ASM_state,
  &_swigt__p_ASM_state_u,
  &_swigt__p_ASM_state_u_context,
  &_swigt__p_ASM_state_u_insert,
  &_swigt__p_ASM_state_u_kern,
  &_swigt__p_BDFChar_dependents,
  &_swigt__p_BDFProperties_u,
  &_swigt__p_Base,
  &_swigt__p_FILE,
  &_swigt__p_FPST_rules,
  &_swigt__p_FPST_rules_lookups,
  &_swigt__p_FPST_rules_u,
  &_swigt__p_FPST_rules_u_class,
  &_swigt__p_FPST_rules_u_coverage,
  &_swigt__p_FPST_rules_u_glyph,
  &_swigt__p_FPST_rules_u_rcoverage,
  &_swigt__p_ItalicInfo_lc,
  &_swigt__p_ItalicInfo_neither,
  &_swigt__p_ItalicInfo_uc,
  &_swigt__p_MATH,
  &_swigt__p_MMSet_axismaps,
  &_swigt__p_MMSet_named_instances,
  &_swigt__p_MacFeat_settings,
  &_swigt__p_NameList_renames,
  &_swigt__p_OTLookup_subtables,
  &_swigt__p_PST_u,
  &_swigt__p_PST_u_alt,
  &_swigt__p_PST_u_lcaret,
  &_swigt__p_PST_u_lig,
  &_swigt__p_PST_u_mult,
  &_swigt__p_PST_u_pair,
  &_swigt__p_PST_u_subs,
  &_swigt__p_RefChar_layers,
  &_swigt__p_SplineChar_altuni,
  &_swigt__p_SplineChar_dependents,
  &_swigt__p_SplineFont_gasp,
  &_swigt__p_SplineFont_pfminfo,
  &_swigt__p_SplineFont_ttf_tab_saved,
  &_swigt__p_SplineFont_ttf_tables,
  &_swigt__p_StemInfo_u,
  &_swigt__p_Undoes_u,
  &_swigt__p_Undoes_u_composit,
  &_swigt__p_Undoes_u_multiple,
  &_swigt__p_Undoes_u_possub,
  &_swigt__p_Undoes_u_state,
  &_swigt__p_Val_u,
  &_swigt__p_a_2__a_16__float,
  &_swigt__p_a_2__float,
  &_swigt__p_a_96_8__unsigned_char,
  &_swigt__p_alltabs,
  &_swigt__p_altuni,
  &_swigt__p_anchorclass,
  &_swigt__p_anchorpoint,
  &_swigt__p_anchorpos,
  &_swigt__p_archivers,
  &_swigt__p_array,
  &_swigt__p_baselangextent,
  &_swigt__p_basepoint,
  &_swigt__p_basescript,
  &_swigt__p_bdfchar,
  &_swigt__p_bdfcharlist,
  &_swigt__p_bdffloat,
  &_swigt__p_bdffont,
  &_swigt__p_bdfprops,
  &_swigt__p_bitmapview,
  &_swigt__p_bluedata,
  &_swigt__p_bluezone,
  &_swigt__p_brush,
  &_swigt__p_char,
  &_swigt__p_charinfo,
  &_swigt__p_charprocs,
  &_swigt__p_charviewbase,
  &_swigt__p_cidbytes,
  &_swigt__p_cidmap,
  &_swigt__p_clut,
  &_swigt__p_compressors,
  &_swigt__p_dbasepoint,
  &_swigt__p_dbounds,
  &_swigt__p_double,
  &_swigt__p_dsteminfo,
  &_swigt__p_enc,
  &_swigt__p_encmap,
  &_swigt__p_f_int__int,
  &_swigt__p_f_int_p_void__void,
  &_swigt__p_f_p_void_int_unsigned_int_unsigned_int__void,
  &_swigt__p_f_p_void_p_struct_spline_float__double,
  &_swigt__p_f_void__void,
  &_swigt__p_fd2data,
  &_swigt__p_featurescriptlanglist,
  &_swigt__p_findsel,
  &_swigt__p_float,
  &_swigt__p_fontdict,
  &_swigt__p_fontviewbase,
  &_swigt__p_fpst_rule,
  &_swigt__p_freetype_raster,
  &_swigt__p_generic_asm,
  &_swigt__p_generic_fpst,
  &_swigt__p_generic_pst,
  &_swigt__p_gfi_data,
  &_swigt__p_gimage,
  &_swigt__p_globalinstrct,
  &_swigt__p_glyphdata,
  &_swigt__p_glyphnamehash,
  &_swigt__p_glyphvariants,
  &_swigt__p_glyphvariants_parts,
  &_swigt__p_gradient,
  &_swigt__p_gradient_grad_stops,
  &_swigt__p_growbuf,
  &_swigt__p_hintinstance,
  &_swigt__p_ibounds,
  &_swigt__p_iconv_t,
  &_swigt__p_imagelist,
  &_swigt__p_instrdata,
  &_swigt__p_int,
  &_swigt__p_intptr_t,
  &_swigt__p_ipoint,
  &_swigt__p_italicinfo,
  &_swigt__p_jstf_lang,
  &_swigt__p_jstf_prio,
  &_swigt__p_jstf_script,
  &_swigt__p_kernclass,
  &_swigt__p_kernclassdlg,
  &_swigt__p_kernclasslistdlg,
  &_swigt__p_kernpair,
  &_swigt__p_lang_frequencies,
  &_swigt__p_layer,
  &_swigt__p_layerinfo,
  &_swigt__p_library_version_configuration,
  &_swigt__p_liglist,
  &_swigt__p_linearapprox,
  &_swigt__p_linelist,
  &_swigt__p_lookup_subtable,
  &_swigt__p_macfeat,
  &_swigt__p_macname,
  &_swigt__p_macsetting,
  &_swigt__p_math_constants_descriptor,
  &_swigt__p_mathkern,
  &_swigt__p_mathkernvertex,
  &_swigt__p_mathkernvertex_mkd,
  &_swigt__p_metricsview,
  &_swigt__p_minimumdistance,
  &_swigt__p_mmset,
  &_swigt__p_namelist,
  &_swigt__p_opentype_feature_friendlynames,
  &_swigt__p_opentype_str,
  &_swigt__p_otffeatname,
  &_swigt__p_otfname,
  &_swigt__p_otlookup,
  &_swigt__p_p_anchorpoint,
  &_swigt__p_p_basepoint,
  &_swigt__p_p_bdfchar,
  &_swigt__p_p_bdffont,
  &_swigt__p_p_char,
  &_swigt__p_p_dsteminfo,
  &_swigt__p_p_macfeat,
  &_swigt__p_p_macsetting,
  &_swigt__p_p_otlookup,
  &_swigt__p_p_p_lang_frequencies,
  &_swigt__p_p_p_p_char,
  &_swigt__p_p_p_splinechar,
  &_swigt__p_p_p_unicode_nameannot,
  &_swigt__p_p_pschars,
  &_swigt__p_p_spline,
  &_swigt__p_p_splinechar,
  &_swigt__p_p_splinefont,
  &_swigt__p_p_splinepoint,
  &_swigt__p_p_splinepointlist,
  &_swigt__p_p_unsigned_char,
  &_swigt__p_pattern,
  &_swigt__p_pen,
  &_swigt__p_pfminfo,
  &_swigt__p_pschars,
  &_swigt__p_pscontext,
  &_swigt__p_psdict,
  &_swigt__p_refbdfc,
  &_swigt__p_refchar,
  &_swigt__p_remap,
  &_swigt__p_scriptlanglist,
  &_swigt__p_sflist,
  &_swigt__p_sfmergecontext,
  &_swigt__p_sfmergecontext_acs,
  &_swigt__p_sfmergecontext_lks,
  &_swigt__p_sfmergecontext_subs,
  &_swigt__p_short,
  &_swigt__p_shortview,
  &_swigt__p_signed_char,
  &_swigt__p_simplifyinfo,
  &_swigt__p_sllk,
  &_swigt__p_spiro_cp,
  &_swigt__p_spline,
  &_swigt__p_spline1d,
  &_swigt__p_splinechar,
  &_swigt__p_splinecharlist,
  &_swigt__p_splinefont,
  &_swigt__p_splinepoint,
  &_swigt__p_splinepointlist,
  &_swigt__p_std_bdf_props,
  &_swigt__p_stdstem,
  &_swigt__p_steminfo,
  &_swigt__p_strokeinfo,
  &_swigt__p_tex_data,
  &_swigt__p_tpoint,
  &_swigt__p_ttf_table,
  &_swigt__p_ttfinfo,
  &_swigt__p_ttflangname,
  &_swigt__p_undoes,
  &_swigt__p_unicode_nameannot,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_short,
  &_swigt__p_val,
  &_swigt__p_val_data,
  &_swigt__p_void,
  &_swigt__p_vr,
  &_swigt__p_xlfd_components,
};

static swig_cast_info _swigc__p_ASM_state[] = {  {&_swigt__p_ASM_state, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ASM_state_u[] = {  {&_swigt__p_ASM_state_u, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ASM_state_u_context[] = {  {&_swigt__p_ASM_state_u_context, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ASM_state_u_insert[] = {  {&_swigt__p_ASM_state_u_insert, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ASM_state_u_kern[] = {  {&_swigt__p_ASM_state_u_kern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BDFChar_dependents[] = {  {&_swigt__p_BDFChar_dependents, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BDFProperties_u[] = {  {&_swigt__p_BDFProperties_u, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Base[] = {  {&_swigt__p_Base, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FILE[] = {  {&_swigt__p_FILE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FPST_rules[] = {  {&_swigt__p_FPST_rules, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FPST_rules_lookups[] = {  {&_swigt__p_FPST_rules_lookups, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FPST_rules_u[] = {  {&_swigt__p_FPST_rules_u, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FPST_rules_u_class[] = {  {&_swigt__p_FPST_rules_u_class, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FPST_rules_u_coverage[] = {  {&_swigt__p_FPST_rules_u_coverage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FPST_rules_u_glyph[] = {  {&_swigt__p_FPST_rules_u_glyph, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FPST_rules_u_rcoverage[] = {  {&_swigt__p_FPST_rules_u_rcoverage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ItalicInfo_lc[] = {  {&_swigt__p_ItalicInfo_lc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ItalicInfo_neither[] = {  {&_swigt__p_ItalicInfo_neither, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ItalicInfo_uc[] = {  {&_swigt__p_ItalicInfo_uc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MATH[] = {  {&_swigt__p_MATH, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MMSet_axismaps[] = {  {&_swigt__p_MMSet_axismaps, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MMSet_named_instances[] = {  {&_swigt__p_MMSet_named_instances, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MacFeat_settings[] = {  {&_swigt__p_MacFeat_settings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NameList_renames[] = {  {&_swigt__p_NameList_renames, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OTLookup_subtables[] = {  {&_swigt__p_OTLookup_subtables, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PST_u[] = {  {&_swigt__p_PST_u, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PST_u_alt[] = {  {&_swigt__p_PST_u_alt, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PST_u_lcaret[] = {  {&_swigt__p_PST_u_lcaret, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PST_u_lig[] = {  {&_swigt__p_PST_u_lig, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PST_u_mult[] = {  {&_swigt__p_PST_u_mult, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PST_u_pair[] = {  {&_swigt__p_PST_u_pair, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PST_u_subs[] = {  {&_swigt__p_PST_u_subs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RefChar_layers[] = {  {&_swigt__p_RefChar_layers, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SplineChar_altuni[] = {  {&_swigt__p_SplineChar_altuni, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SplineChar_dependents[] = {  {&_swigt__p_SplineChar_dependents, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SplineFont_gasp[] = {  {&_swigt__p_SplineFont_gasp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SplineFont_pfminfo[] = {  {&_swigt__p_SplineFont_pfminfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SplineFont_ttf_tab_saved[] = {  {&_swigt__p_SplineFont_ttf_tab_saved, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SplineFont_ttf_tables[] = {  {&_swigt__p_SplineFont_ttf_tables, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StemInfo_u[] = {  {&_swigt__p_StemInfo_u, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Undoes_u[] = {  {&_swigt__p_Undoes_u, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Undoes_u_composit[] = {  {&_swigt__p_Undoes_u_composit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Undoes_u_multiple[] = {  {&_swigt__p_Undoes_u_multiple, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Undoes_u_possub[] = {  {&_swigt__p_Undoes_u_possub, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Undoes_u_state[] = {  {&_swigt__p_Undoes_u_state, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Val_u[] = {  {&_swigt__p_Val_u, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_2__a_16__float[] = {  {&_swigt__p_a_2__a_16__float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_2__float[] = {  {&_swigt__p_a_2__float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_96_8__unsigned_char[] = {  {&_swigt__p_a_96_8__unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_alltabs[] = {  {&_swigt__p_alltabs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_altuni[] = {  {&_swigt__p_altuni, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_anchorclass[] = {  {&_swigt__p_anchorclass, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_anchorpoint[] = {  {&_swigt__p_anchorpoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_anchorpos[] = {  {&_swigt__p_anchorpos, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_archivers[] = {  {&_swigt__p_archivers, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_array[] = {  {&_swigt__p_array, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_baselangextent[] = {  {&_swigt__p_baselangextent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_basepoint[] = {  {&_swigt__p_basepoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_basescript[] = {  {&_swigt__p_basescript, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bdfchar[] = {  {&_swigt__p_bdfchar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bdfcharlist[] = {  {&_swigt__p_bdfcharlist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bdffloat[] = {  {&_swigt__p_bdffloat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bdffont[] = {  {&_swigt__p_bdffont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bdfprops[] = {  {&_swigt__p_bdfprops, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bitmapview[] = {  {&_swigt__p_bitmapview, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bluedata[] = {  {&_swigt__p_bluedata, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bluezone[] = {  {&_swigt__p_bluezone, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_brush[] = {  {&_swigt__p_brush, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_charinfo[] = {  {&_swigt__p_charinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_charprocs[] = {  {&_swigt__p_charprocs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_charviewbase[] = {  {&_swigt__p_charviewbase, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cidbytes[] = {  {&_swigt__p_cidbytes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_cidmap[] = {  {&_swigt__p_cidmap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_clut[] = {  {&_swigt__p_clut, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_compressors[] = {  {&_swigt__p_compressors, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_dbasepoint[] = {  {&_swigt__p_dbasepoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_dbounds[] = {  {&_swigt__p_dbounds, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_dsteminfo[] = {  {&_swigt__p_dsteminfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_enc[] = {  {&_swigt__p_enc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_encmap[] = {  {&_swigt__p_encmap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_int__int[] = {  {&_swigt__p_f_int__int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_int_p_void__void[] = {  {&_swigt__p_f_int_p_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_int_unsigned_int_unsigned_int__void[] = {  {&_swigt__p_f_p_void_int_unsigned_int_unsigned_int__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_p_void_p_struct_spline_float__double[] = {  {&_swigt__p_f_p_void_p_struct_spline_float__double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_f_void__void[] = {  {&_swigt__p_f_void__void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fd2data[] = {  {&_swigt__p_fd2data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_featurescriptlanglist[] = {  {&_swigt__p_featurescriptlanglist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_findsel[] = {  {&_swigt__p_findsel, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_float[] = {  {&_swigt__p_float, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fontdict[] = {  {&_swigt__p_fontdict, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fontviewbase[] = {  {&_swigt__p_fontviewbase, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_fpst_rule[] = {  {&_swigt__p_fpst_rule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_freetype_raster[] = {  {&_swigt__p_freetype_raster, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_generic_asm[] = {  {&_swigt__p_generic_asm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_generic_fpst[] = {  {&_swigt__p_generic_fpst, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_generic_pst[] = {  {&_swigt__p_generic_pst, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gfi_data[] = {  {&_swigt__p_gfi_data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gimage[] = {  {&_swigt__p_gimage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_globalinstrct[] = {  {&_swigt__p_globalinstrct, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glyphdata[] = {  {&_swigt__p_glyphdata, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glyphnamehash[] = {  {&_swigt__p_glyphnamehash, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glyphvariants[] = {  {&_swigt__p_glyphvariants, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_glyphvariants_parts[] = {  {&_swigt__p_glyphvariants_parts, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gradient[] = {  {&_swigt__p_gradient, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_gradient_grad_stops[] = {  {&_swigt__p_gradient_grad_stops, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_growbuf[] = {  {&_swigt__p_growbuf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_hintinstance[] = {  {&_swigt__p_hintinstance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ibounds[] = {  {&_swigt__p_ibounds, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_iconv_t[] = {  {&_swigt__p_iconv_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_imagelist[] = {  {&_swigt__p_imagelist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_instrdata[] = {  {&_swigt__p_instrdata, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_intptr_t[] = {  {&_swigt__p_intptr_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ipoint[] = {  {&_swigt__p_ipoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_italicinfo[] = {  {&_swigt__p_italicinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_jstf_lang[] = {  {&_swigt__p_jstf_lang, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_jstf_prio[] = {  {&_swigt__p_jstf_prio, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_jstf_script[] = {  {&_swigt__p_jstf_script, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_kernclass[] = {  {&_swigt__p_kernclass, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_kernclassdlg[] = {  {&_swigt__p_kernclassdlg, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_kernclasslistdlg[] = {  {&_swigt__p_kernclasslistdlg, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_kernpair[] = {  {&_swigt__p_kernpair, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lang_frequencies[] = {  {&_swigt__p_lang_frequencies, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_layer[] = {  {&_swigt__p_layer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_layerinfo[] = {  {&_swigt__p_layerinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_library_version_configuration[] = {  {&_swigt__p_library_version_configuration, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_liglist[] = {  {&_swigt__p_liglist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_linearapprox[] = {  {&_swigt__p_linearapprox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_linelist[] = {  {&_swigt__p_linelist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_lookup_subtable[] = {  {&_swigt__p_lookup_subtable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_macfeat[] = {  {&_swigt__p_macfeat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_macname[] = {  {&_swigt__p_macname, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_macsetting[] = {  {&_swigt__p_macsetting, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_math_constants_descriptor[] = {  {&_swigt__p_math_constants_descriptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mathkern[] = {  {&_swigt__p_mathkern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mathkernvertex[] = {  {&_swigt__p_mathkernvertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mathkernvertex_mkd[] = {  {&_swigt__p_mathkernvertex_mkd, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_metricsview[] = {  {&_swigt__p_metricsview, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_minimumdistance[] = {  {&_swigt__p_minimumdistance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mmset[] = {  {&_swigt__p_mmset, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_namelist[] = {  {&_swigt__p_namelist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_opentype_feature_friendlynames[] = {  {&_swigt__p_opentype_feature_friendlynames, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_opentype_str[] = {  {&_swigt__p_opentype_str, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_otffeatname[] = {  {&_swigt__p_otffeatname, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_otfname[] = {  {&_swigt__p_otfname, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_otlookup[] = {  {&_swigt__p_otlookup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_anchorpoint[] = {  {&_swigt__p_p_anchorpoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_basepoint[] = {  {&_swigt__p_p_basepoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_bdfchar[] = {  {&_swigt__p_p_bdfchar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_bdffont[] = {  {&_swigt__p_p_bdffont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_char[] = {  {&_swigt__p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_dsteminfo[] = {  {&_swigt__p_p_dsteminfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_macfeat[] = {  {&_swigt__p_p_macfeat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_macsetting[] = {  {&_swigt__p_p_macsetting, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_otlookup[] = {  {&_swigt__p_p_otlookup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_p_lang_frequencies[] = {  {&_swigt__p_p_p_lang_frequencies, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_p_p_char[] = {  {&_swigt__p_p_p_p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_p_splinechar[] = {  {&_swigt__p_p_p_splinechar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_p_unicode_nameannot[] = {  {&_swigt__p_p_p_unicode_nameannot, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_pschars[] = {  {&_swigt__p_p_pschars, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_spline[] = {  {&_swigt__p_p_spline, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_splinechar[] = {  {&_swigt__p_p_splinechar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_splinefont[] = {  {&_swigt__p_p_splinefont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_splinepoint[] = {  {&_swigt__p_p_splinepoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_splinepointlist[] = {  {&_swigt__p_p_splinepointlist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_unsigned_char[] = {  {&_swigt__p_p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pattern[] = {  {&_swigt__p_pattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pen[] = {  {&_swigt__p_pen, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pfminfo[] = {  {&_swigt__p_pfminfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pschars[] = {  {&_swigt__p_pschars, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_pscontext[] = {  {&_swigt__p_pscontext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_psdict[] = {  {&_swigt__p_psdict, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_refbdfc[] = {  {&_swigt__p_refbdfc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_refchar[] = {  {&_swigt__p_refchar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_remap[] = {  {&_swigt__p_remap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_scriptlanglist[] = {  {&_swigt__p_scriptlanglist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sflist[] = {  {&_swigt__p_sflist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sfmergecontext[] = {  {&_swigt__p_sfmergecontext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sfmergecontext_acs[] = {  {&_swigt__p_sfmergecontext_acs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sfmergecontext_lks[] = {  {&_swigt__p_sfmergecontext_lks, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sfmergecontext_subs[] = {  {&_swigt__p_sfmergecontext_subs, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_shortview[] = {  {&_swigt__p_shortview, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_simplifyinfo[] = {  {&_swigt__p_simplifyinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sllk[] = {  {&_swigt__p_sllk, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_spiro_cp[] = {  {&_swigt__p_spiro_cp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_spline[] = {  {&_swigt__p_spline, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_spline1d[] = {  {&_swigt__p_spline1d, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_splinechar[] = {  {&_swigt__p_splinechar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_splinecharlist[] = {  {&_swigt__p_splinecharlist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_splinefont[] = {  {&_swigt__p_splinefont, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_splinepoint[] = {  {&_swigt__p_splinepoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_splinepointlist[] = {  {&_swigt__p_splinepointlist, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std_bdf_props[] = {  {&_swigt__p_std_bdf_props, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_stdstem[] = {  {&_swigt__p_stdstem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_steminfo[] = {  {&_swigt__p_steminfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_strokeinfo[] = {  {&_swigt__p_strokeinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_tex_data[] = {  {&_swigt__p_tex_data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_tpoint[] = {  {&_swigt__p_tpoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ttf_table[] = {  {&_swigt__p_ttf_table, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ttfinfo[] = {  {&_swigt__p_ttfinfo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ttflangname[] = {  {&_swigt__p_ttflangname, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_undoes[] = {  {&_swigt__p_undoes, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unicode_nameannot[] = {  {&_swigt__p_unicode_nameannot, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_val[] = {  {&_swigt__p_val, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_val_data[] = {  {&_swigt__p_val_data, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_void[] = {  {&_swigt__p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_vr[] = {  {&_swigt__p_vr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_xlfd_components[] = {  {&_swigt__p_xlfd_components, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_ASM_state,
  _swigc__p_ASM_state_u,
  _swigc__p_ASM_state_u_context,
  _swigc__p_ASM_state_u_insert,
  _swigc__p_ASM_state_u_kern,
  _swigc__p_BDFChar_dependents,
  _swigc__p_BDFProperties_u,
  _swigc__p_Base,
  _swigc__p_FILE,
  _swigc__p_FPST_rules,
  _swigc__p_FPST_rules_lookups,
  _swigc__p_FPST_rules_u,
  _swigc__p_FPST_rules_u_class,
  _swigc__p_FPST_rules_u_coverage,
  _swigc__p_FPST_rules_u_glyph,
  _swigc__p_FPST_rules_u_rcoverage,
  _swigc__p_ItalicInfo_lc,
  _swigc__p_ItalicInfo_neither,
  _swigc__p_ItalicInfo_uc,
  _swigc__p_MATH,
  _swigc__p_MMSet_axismaps,
  _swigc__p_MMSet_named_instances,
  _swigc__p_MacFeat_settings,
  _swigc__p_NameList_renames,
  _swigc__p_OTLookup_subtables,
  _swigc__p_PST_u,
  _swigc__p_PST_u_alt,
  _swigc__p_PST_u_lcaret,
  _swigc__p_PST_u_lig,
  _swigc__p_PST_u_mult,
  _swigc__p_PST_u_pair,
  _swigc__p_PST_u_subs,
  _swigc__p_RefChar_layers,
  _swigc__p_SplineChar_altuni,
  _swigc__p_SplineChar_dependents,
  _swigc__p_SplineFont_gasp,
  _swigc__p_SplineFont_pfminfo,
  _swigc__p_SplineFont_ttf_tab_saved,
  _swigc__p_SplineFont_ttf_tables,
  _swigc__p_StemInfo_u,
  _swigc__p_Undoes_u,
  _swigc__p_Undoes_u_composit,
  _swigc__p_Undoes_u_multiple,
  _swigc__p_Undoes_u_possub,
  _swigc__p_Undoes_u_state,
  _swigc__p_Val_u,
  _swigc__p_a_2__a_16__float,
  _swigc__p_a_2__float,
  _swigc__p_a_96_8__unsigned_char,
  _swigc__p_alltabs,
  _swigc__p_altuni,
  _swigc__p_anchorclass,
  _swigc__p_anchorpoint,
  _swigc__p_anchorpos,
  _swigc__p_archivers,
  _swigc__p_array,
  _swigc__p_baselangextent,
  _swigc__p_basepoint,
  _swigc__p_basescript,
  _swigc__p_bdfchar,
  _swigc__p_bdfcharlist,
  _swigc__p_bdffloat,
  _swigc__p_bdffont,
  _swigc__p_bdfprops,
  _swigc__p_bitmapview,
  _swigc__p_bluedata,
  _swigc__p_bluezone,
  _swigc__p_brush,
  _swigc__p_char,
  _swigc__p_charinfo,
  _swigc__p_charprocs,
  _swigc__p_charviewbase,
  _swigc__p_cidbytes,
  _swigc__p_cidmap,
  _swigc__p_clut,
  _swigc__p_compressors,
  _swigc__p_dbasepoint,
  _swigc__p_dbounds,
  _swigc__p_double,
  _swigc__p_dsteminfo,
  _swigc__p_enc,
  _swigc__p_encmap,
  _swigc__p_f_int__int,
  _swigc__p_f_int_p_void__void,
  _swigc__p_f_p_void_int_unsigned_int_unsigned_int__void,
  _swigc__p_f_p_void_p_struct_spline_float__double,
  _swigc__p_f_void__void,
  _swigc__p_fd2data,
  _swigc__p_featurescriptlanglist,
  _swigc__p_findsel,
  _swigc__p_float,
  _swigc__p_fontdict,
  _swigc__p_fontviewbase,
  _swigc__p_fpst_rule,
  _swigc__p_freetype_raster,
  _swigc__p_generic_asm,
  _swigc__p_generic_fpst,
  _swigc__p_generic_pst,
  _swigc__p_gfi_data,
  _swigc__p_gimage,
  _swigc__p_globalinstrct,
  _swigc__p_glyphdata,
  _swigc__p_glyphnamehash,
  _swigc__p_glyphvariants,
  _swigc__p_glyphvariants_parts,
  _swigc__p_gradient,
  _swigc__p_gradient_grad_stops,
  _swigc__p_growbuf,
  _swigc__p_hintinstance,
  _swigc__p_ibounds,
  _swigc__p_iconv_t,
  _swigc__p_imagelist,
  _swigc__p_instrdata,
  _swigc__p_int,
  _swigc__p_intptr_t,
  _swigc__p_ipoint,
  _swigc__p_italicinfo,
  _swigc__p_jstf_lang,
  _swigc__p_jstf_prio,
  _swigc__p_jstf_script,
  _swigc__p_kernclass,
  _swigc__p_kernclassdlg,
  _swigc__p_kernclasslistdlg,
  _swigc__p_kernpair,
  _swigc__p_lang_frequencies,
  _swigc__p_layer,
  _swigc__p_layerinfo,
  _swigc__p_library_version_configuration,
  _swigc__p_liglist,
  _swigc__p_linearapprox,
  _swigc__p_linelist,
  _swigc__p_lookup_subtable,
  _swigc__p_macfeat,
  _swigc__p_macname,
  _swigc__p_macsetting,
  _swigc__p_math_constants_descriptor,
  _swigc__p_mathkern,
  _swigc__p_mathkernvertex,
  _swigc__p_mathkernvertex_mkd,
  _swigc__p_metricsview,
  _swigc__p_minimumdistance,
  _swigc__p_mmset,
  _swigc__p_namelist,
  _swigc__p_opentype_feature_friendlynames,
  _swigc__p_opentype_str,
  _swigc__p_otffeatname,
  _swigc__p_otfname,
  _swigc__p_otlookup,
  _swigc__p_p_anchorpoint,
  _swigc__p_p_basepoint,
  _swigc__p_p_bdfchar,
  _swigc__p_p_bdffont,
  _swigc__p_p_char,
  _swigc__p_p_dsteminfo,
  _swigc__p_p_macfeat,
  _swigc__p_p_macsetting,
  _swigc__p_p_otlookup,
  _swigc__p_p_p_lang_frequencies,
  _swigc__p_p_p_p_char,
  _swigc__p_p_p_splinechar,
  _swigc__p_p_p_unicode_nameannot,
  _swigc__p_p_pschars,
  _swigc__p_p_spline,
  _swigc__p_p_splinechar,
  _swigc__p_p_splinefont,
  _swigc__p_p_splinepoint,
  _swigc__p_p_splinepointlist,
  _swigc__p_p_unsigned_char,
  _swigc__p_pattern,
  _swigc__p_pen,
  _swigc__p_pfminfo,
  _swigc__p_pschars,
  _swigc__p_pscontext,
  _swigc__p_psdict,
  _swigc__p_refbdfc,
  _swigc__p_refchar,
  _swigc__p_remap,
  _swigc__p_scriptlanglist,
  _swigc__p_sflist,
  _swigc__p_sfmergecontext,
  _swigc__p_sfmergecontext_acs,
  _swigc__p_sfmergecontext_lks,
  _swigc__p_sfmergecontext_subs,
  _swigc__p_short,
  _swigc__p_shortview,
  _swigc__p_signed_char,
  _swigc__p_simplifyinfo,
  _swigc__p_sllk,
  _swigc__p_spiro_cp,
  _swigc__p_spline,
  _swigc__p_spline1d,
  _swigc__p_splinechar,
  _swigc__p_splinecharlist,
  _swigc__p_splinefont,
  _swigc__p_splinepoint,
  _swigc__p_splinepointlist,
  _swigc__p_std_bdf_props,
  _swigc__p_stdstem,
  _swigc__p_steminfo,
  _swigc__p_strokeinfo,
  _swigc__p_tex_data,
  _swigc__p_tpoint,
  _swigc__p_ttf_table,
  _swigc__p_ttfinfo,
  _swigc__p_ttflangname,
  _swigc__p_undoes,
  _swigc__p_unicode_nameannot,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_short,
  _swigc__p_val,
  _swigc__p_val_data,
  _swigc__p_void,
  _swigc__p_vr,
  _swigc__p_xlfd_components,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif



/* Forward declaration of where the user's %init{} gets inserted */
void SWIG_init_user(lua_State* L );
    
#ifdef __cplusplus
extern "C" {
#endif
/* this is the initialization function
  added at the very end of the code
  the function is always called SWIG_init, but an eariler #define will rename it
*/
#if ((SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUA) || (SWIG_LUA_TARGET == SWIG_LUA_FLAVOR_ELUAC))
LUALIB_API int SWIG_init(lua_State* L)
#else
SWIGEXPORT int SWIG_init(lua_State* L) /* default Lua action */
#endif
{
#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC) /* valid for both Lua and eLua */
  int i;
  /* start with global table */
  lua_pushglobaltable (L);
  /* SWIG's internal initalisation */
  SWIG_InitializeModule((void*)L);
  SWIG_PropagateClientData();
#endif

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC))
  /* add a global fn */
  SWIG_Lua_add_function(L,"swig_type",SWIG_Lua_type);
  SWIG_Lua_add_function(L,"swig_equals",SWIG_Lua_equal);
  /* begin the module (its a table with the same name as the module) */
  SWIG_Lua_module_begin(L,SWIG_name);
  /* add commands/functions */
  for (i = 0; swig_commands[i].name; i++){
    SWIG_Lua_module_add_function(L,swig_commands[i].name,swig_commands[i].func);
  }
  /* add variables */
  for (i = 0; swig_variables[i].name; i++){
    SWIG_Lua_module_add_variable(L,swig_variables[i].name,swig_variables[i].get,swig_variables[i].set);
  }
#endif

#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  /* set up base class pointers (the hierachy) */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_init_base_class(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
  /* additional registration structs & classes in lua */
  for (i = 0; swig_types[i]; i++){
    if (swig_types[i]->clientdata){
      SWIG_Lua_class_register(L,(swig_lua_class*)(swig_types[i]->clientdata));
    }
  }
#endif

#if ((SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUA) && (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC))
  /* constants */
  SWIG_Lua_InstallConstants(L,swig_constants);
#endif

#if (SWIG_LUA_TARGET != SWIG_LUA_FLAVOR_ELUAC)
  /* invoke user-specific initialization */
  SWIG_init_user(L);
  /* end module */
  /* Note: We do not clean up the stack here (Lua will do this for us). At this
     point, we have the globals table and out module table on the stack. Returning
     one value makes the module table the result of the require command. */
  return 1;
#else
  return 0;
#endif
}

#ifdef __cplusplus
}
#endif


const char* SWIG_LUACODE=
  "";

void SWIG_init_user(lua_State* L)
{
  running_script = true;
# ifndef CHR
#  define CHR(ch1,ch2,ch3,ch4) (((ch1)<<24)|((ch2)<<16)|((ch3)<<8)|(ch4))
# endif
  
  /* exec Lua code if applicable */
  SWIG_Lua_dostring(L,SWIG_LUACODE);
}

